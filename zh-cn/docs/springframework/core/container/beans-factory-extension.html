<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<meta name="keywords" content="keywords: docs，jcohy-docs，spring,容器的扩展点" />
	<meta name="description" content="Spring  Framework 中文文档 》 容器的扩展点" />
	<!-- 网页标签标题 -->
	<title>容器的扩展点</title>
	<link rel="shortcut icon" href="/img/jcohy.ico"/>
	<link rel="stylesheet" href="/build/documentation.css" />
</head>
<body>
	<div id="root"><div class="documentation-page" data-reactroot=""><header class="header-container header-container-normal"><div class="header-body"><a href="/zh-cn/index.html"><img class="logo" src="/img/jcohy_colorful.png"/></a><div class="search search-normal"><span class="icon-search"></span></div><span class="language-switch language-switch-normal">En</span><div class="header-menu"><img class="header-menu-toggle" src="/img/system/menu_gray.png"/><ul><li class="menu-item menu-item-normal"><a href="/zh-cn/index.html" target="_self">首页</a></li><li class="menu-item menu-item-normal menu-item-normal-active"><a href="/zh-cn/docs/Overview.html" target="_self">文档</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/blog/index.html" target="_self">博客</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/open/index.html" target="_self">开源项目</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/resource/index.html" target="_self">资源</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/community/index.html" target="_self">社区</a></li></ul></div></div></header><div class="bar"><div class="bar-body"><img src="/img/system/docs.png" class="front-img"/><span>文档</span><img src="/img/system/docs.png" class="back-img"/></div></div><section class="content-section"><div class="sidemenu"><div class="sidemenu-toggle"><img src="https://img.alicdn.com/tfs/TB1E6apXHGYBuNjy0FoXXciBFXa-200-200.png"/></div><ul><li class="menu-item menu-item-level-1"><span>概述</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/Overview.html" target="_self">概述</a></li></ul></li><li class="menu-item menu-item-level-1"><span>Spring Framework</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/springframework/README.html" target="_self">说明</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/springframework/SUMMARY.html" target="_self">摘要</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/springframework/overview/overview.html" target="_self">概述</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>核心组件<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/springframework/core/overview.html" target="_self">全部章节一览</a></li><li class="menu-item menu-item-level-3"><a target="_self">IOC容器</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a target="_self">测试</a></li></ul></li></ul></div><div class="doc-content markdown-body"><h1>Spring  Framework 中文文档</h1>
<h3><a href="#beans-factory-extension"></a>1.8. 容器的扩展点</h3>
<p>通常，应用程序开发者无需继承<code>ApplicationContext</code>的实现类。相反，Spring IoC容器可以通过插入特殊的集成接口实现进行扩展。接下来的几节将介绍这些集成接口。</p>
<p><a id="beans-factory-extension-bpp"></a></p>
<h4><a href="#beans-factory-extension-bpp"></a>1.8.1. 使用<code>BeanPostProcessor</code>自定义Bean</h4>
<p><code>BeanPostProcessor</code>接口定义了可以实现的回调方法，以提供您自己的（或覆盖容器的默认）实例化逻辑，依赖关系解析逻辑等。 如果要在Spring容器完成实例化，配置和初始化bean之后实现某些自定义逻辑，则可以插入一个或多个自定义<code>BeanPostProcessor</code>实现。</p>
<p>您可以配置多个<code>BeanPostProcessor</code> 实例，并且可以通过设置<code>order</code>属性来控制这些 <code>BeanPostProcessor</code> 实例的执行顺序。 仅当<code>BeanPostProcessor</code>实现 <code>Ordered</code>接口时，才能设置此属性。如果编写自己的<code>BeanPostProcessor</code>，则应考虑实现Ordered接口。 有关更多详细信息， 请参阅<a href="https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/beans/factory/config/BeanPostProcessor.html"><code>BeanPostProcessor</code></a> 和 <a href="https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/core/Ordered.html"><code>Ordered</code></a>的javadoc。 另请参阅有关<a href="#beans-factory-programmatically-registering-beanpostprocessors"><code>BeanPostProcessor</code> 实例</a>的编程注册的说明。</p>
<p><code>BeanPostProcessor</code>实例在bean（或对象）实例上运行。 也就是说，Spring IoC容器实例化一个bean实例，然后才能用<code>BeanPostProcessor</code> 对这个实例进行处理。</p>
<p><code>BeanPostProcessor</code>会在整个容器内起作用，所有它仅仅与正在使用的容器相关。如果在一个容器中定义了<code>BeanPostProcessor</code>，那么它只会处理那个容器中的bean。 换句话说，在一个容器中定义的bean不会被另一个容器定义的<code>BeanPostProcessor</code>处理，即使这两个容器都是同一层次结构的一部分。</p>
<p>要更改实际的bean定义（即定义bean的蓝图），您需要使用<code>BeanFactoryPostProcessor</code>，使用BeanFactoryPostProcessor自定义配置元数据。 <a href="#beans-factory-extension-factory-postprocessors">使用 <code>BeanFactoryPostProcessor</code>自定义配置元数据</a>.</p>
<p><code>org.springframework.beans.factory.config.BeanPostProcessor</code>接口由两个回调方法组成，当一个类被注册为容器的后置处理器时，对于容器创建的每个bean实例， 后置处理器都会在容器初始化方法（如<code>InitializingBean.afterPropertiesSet()</code>之前和容器声明的<code>init</code>方法）以及任何bean初始化回调之后被调用。后置处理器可以对bean实例执行任何操作， 包括完全忽略回调。bean后置处理器，通常会检查回调接口或者使用代理包装bean。一些Spring AOP基础架构类为了提供包装好的代理逻辑，会被实现为bean后置处理器。</p>
<p><code>ApplicationContext</code>会自动地检测所有定义在配置元文件中，并实现了<code>BeanPostProcessor</code> 接口的bean。<code>ApplicationContext</code>会注册这些beans为后置处理器， 使他们可以在bean创建完成之后被调用。bean后置处理器可以像其他bean一样部署到容器中。</p>
<p>当在配置类上使用 <code>@Bean</code> 工厂方法声明<code>BeanPostProcessor</code>时，工厂方法返回的类型应该是实现类自身。，或至少也是<code>org.springframework.beans.factory.config.BeanPostProcessor</code>接口， 要清楚地表明这个bean的后置处理器的本质特点。否则，在它完全创建之前，<code>ApplicationContext</code>将不能通过类型自动探测它。由于<code>BeanPostProcessor</code>在早期就需要被实例化， 以适应上下文中其他bean的实例化，因此这个早期的类型检查是至关重要的。</p>
<p>以编程方式注册<code>BeanPostProcessor</code>实例，虽然<code>BeanPostProcessor</code>注册的推荐方法是通过<code>ApplicationContext</code>自动检测（如前所述），但您可以以编程的方式使用<code>ConfigurableBeanFactory</code>的<code>addBeanPostProcessor</code>方法进行注册。 这对于在注册之前需要对条件逻辑进行评估，或者是在继承层次的上下文之间复制bean的后置处理器中是有很有用的。 但请注意，以编程方式添加的<code>BeanPostProcessor</code>实例不遵循<code>Ordered</code>接口。这里，注册顺序决定了执行的顺序。 另请注意，以编程方式注册的<code>BeanPostProcessor</code>实例始终在通过自动检测注册的实例之前处理，而不管任何显式排序。</p>
<p><code>BeanPostProcessor</code> 实例 and AOP 自动代理</p>
<p>实现<code>BeanPostProcessor</code> 接口的类是特殊的，容器会对它们进行不同的处理。所有<code>BeanPostProcessor</code> 和他们直接引用的beans都会在容器启动的时候被实例化， 并作为<code>ApplicationContext</code>特殊启动阶段的一部分。接着，所有的<code>BeanPostProcessor</code> 都会以一个有序的方式进行注册，并应用于容器中的所有bean。 因为AOP自动代理本身被实现为<code>BeanPostProcessor</code>，这个<code>BeanPostProcessor</code>和它直接应用的beans都不适合进行自动代理，因此也就无法在它们中织入切面。</p>
<p>对于所有这样的bean，您应该看到一条信息性日志消息: <code>Bean someBean is not eligible for getting processed by all BeanPostProcessor interfaces (for example: not eligible for auto-proxying)</code>.</p>
<p>如果你使用自动装配或 <code>@Resource</code>（可能会回退到自动装配）将Bean连接到<code>BeanPostProcessor</code>中，Spring可能会在搜索类型匹配的依赖关系候选时访问到意外类型的bean； 因此，对它们不适合进行自动代理，或者对其他类型的bean进行后置处理。例如，如果有一个使用 <code>@Resource</code> 注解的依赖项，其中字段或setter名称不直接对应于bean的声明名称而且没有使用name属性， 则Spring会访问其他bean以按类型匹配它们。</p>
<p>以下示例显示如何在<code>ApplicationContext</code>中编写，注册和使用<code>BeanPostProcessor</code>实例。</p>
<p><a id="beans-factory-extension-bpp-examples-hw"></a></p>
<h5><a href="#beans-factory-extension-bpp-examples-hw"></a>示例: Hello World, <code>BeanPostProcessor</code>-style</h5>
<p>第一个例子说明了基本用法。 该示例显示了一个自定义<code>BeanPostProcessor</code>实现，该实现在容器创建时调用每个bean的 <code>toString()</code> 方法，并将生成的字符串输出到系统控制台。</p>
<p>以下清单显示了自定义<code>BeanPostProcessor</code> 实现类定义:</p>
<pre><code class="language-java"><span class="hljs-keyword">package</span> scripting;

<span class="hljs-keyword">import</span> org.springframework.beans.factory.config.BeanPostProcessor;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InstantiationTracingBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanPostProcessor</span> </span>{

    <span class="hljs-comment">// simply return the instantiated bean as-is</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> </span>{
        <span class="hljs-keyword">return</span> bean; <span class="hljs-comment">// we could potentially return any object reference here...</span>
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> </span>{
        System.out.println(<span class="hljs-string">"Bean '"</span> + beanName + <span class="hljs-string">"' created : "</span> + bean.toString());
        <span class="hljs-keyword">return</span> bean;
    }
}
</code></pre>
<pre><code class="language-kotlin"><span class="hljs-keyword">import</span> org.springframework.beans.factory.config.BeanPostProcessor

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InstantiationTracingBeanPostProcessor</span> : <span class="hljs-type">BeanPostProcessor {</span></span>

    <span class="hljs-comment">// simply return the instantiated bean as-is</span>
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">postProcessBeforeInitialization</span><span class="hljs-params">(bean: <span class="hljs-type">Any</span>, beanName: <span class="hljs-type">String</span>)</span></span>: Any? {
        <span class="hljs-keyword">return</span> bean <span class="hljs-comment">// we could potentially return any object reference here...</span>
    }

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">postProcessAfterInitialization</span><span class="hljs-params">(bean: <span class="hljs-type">Any</span>, beanName: <span class="hljs-type">String</span>)</span></span>: Any? {
        println(<span class="hljs-string">"Bean '<span class="hljs-variable">$beanName</span>' created : <span class="hljs-variable">$bean</span>"</span>)
        <span class="hljs-keyword">return</span> bean
    }
}
</code></pre>
<p>以下beans元素使用<code>InstantiationTracingBeanPostProcessor</code>:</p>
<pre><code class="language-xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span>
    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="hljs-attr">xmlns:lang</span>=<span class="hljs-string">"http://www.springframework.org/schema/lang"</span>
    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/lang
        https://www.springframework.org/schema/lang/spring-lang.xsd"</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">lang:groovy</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"messenger"</span>
            <span class="hljs-attr">script-source</span>=<span class="hljs-string">"classpath:org/springframework/scripting/groovy/Messenger.groovy"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">lang:property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"message"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Fiona Apple Is Just So Dreamy."</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">lang:groovy</span>&gt;</span>

    <span class="hljs-comment">&lt;!--
    when the above bean (messenger) is instantiated, this custom
    BeanPostProcessor implementation will output the fact to the system console
    --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"scripting.InstantiationTracingBeanPostProcessor"</span>/&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span>
</code></pre>
<p>注意<code>InstantiationTracingBeanPostProcessor</code>是如何定义的，它甚至没有名字，因为它是一个bean，所以它可以像任何其他bean一样进行依赖注入 （前面的配置还定义了一个由Groovy脚本支持的bean。在<a href="https://github.com/DocsHome/spring-docs/blob/master/pages/languages/languages.md#dynamic-language">动态语言支持</a>一章中详细介绍了Spring动态语言支持）。</p>
<p>下面简单的Java应用执行了前面代码和配置:</p>
<pre><code class="language-java"><span class="hljs-keyword">import</span> org.springframework.context.ApplicationContext;
<span class="hljs-keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;
<span class="hljs-keyword">import</span> org.springframework.scripting.Messenger;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Boot</span> </span>{

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>{
        ApplicationContext ctx = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"scripting/beans.xml"</span>);
        Messenger messenger = (Messenger) ctx.getBean(<span class="hljs-string">"messenger"</span>);
        System.out.println(messenger);
    }

}
</code></pre>
<pre><code class="language-kotlin"><span class="hljs-keyword">import</span> org.springframework.beans.factory.getBean

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> ctx = ClassPathXmlApplicationContext(<span class="hljs-string">"scripting/beans.xml"</span>)
    <span class="hljs-keyword">val</span> messenger = ctx.getBean&lt;Messenger&gt;(<span class="hljs-string">"messenger"</span>)
    println(messenger)
}
</code></pre>
<p>上述应用程序的输出类似于以下内容:</p>
<pre><code>Bean 'messenger' created :  org.springframework.scripting.groovy.GroovyMessenger@272961
org.springframework.scripting.groovy.GroovyMessenger@272961
</code></pre>
<p><a id="beans-factory-extension-bpp-examples-rabpp"></a></p>
<h5><a href="#beans-factory-extension-bpp-examples-rabpp"></a>示例: The <code>RequiredAnnotationBeanPostProcessor</code></h5>
<p>自定义<code>BeanPostProcessor</code>实现与回调接口或注解配合使用，是一种常见的扩展Spring IoC容器手段，一个例子就是<code>RequiredAnnotationBeanPostProcessor</code>，这是<code>BeanPostProcessor</code>实现。 它确保用（任意）注解标记的bean上的JavaBean属性实际上（配置为）依赖注入值。</p>
<p><a id="beans-factory-extension-factory-postprocessors"></a></p>
<h4><a href="#beans-factory-extension-factory-postprocessors"></a>1.8.2. 使用<code>BeanFactoryPostProcessor</code>自定义元数据配置</h4>
<p>下一个我们要关注的扩展点是<code>org.springframework.beans.factory.config.BeanFactoryPostProcessor</code>。这个接口的语义与<code>BeanPostProcessor</code>类似， 但有一处不同，<code>BeanFactoryPostProcessor</code>操作bean的元数据配置。也就是说，也就是说，Spring IoC容器允许<code>BeanFactoryPostProcessor</code>读取配置元数据， 并可能在容器实例化除<code>BeanFactoryPostProcessor</code>实例之外的任何bean之前更改它。</p>
<p>您可以配置多个<code>BeanFactoryPostProcessor</code>实例，并且可以通过设置<code>order</code>属性来控制这些<code>BeanFactoryPostProcessor</code>实例的运行顺序（<code>BeanFactoryPostProcessor</code>必须实现了<code>Ordered</code>接口才能设置这个属性）。 如果编写自己的BeanFactoryPostProcessor，则应考虑实现Ordered接口。 有关更多详细信息， 请参阅<a href="https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/beans/factory/config/BeanFactoryPostProcessor.html"><code>BeanFactoryPostProcessor</code></a> 和 <a href="https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/core/Ordered.html"><code>Ordered</code></a> 接口的javadoc.</p>
<p>如果想修改实际的bean实例（也就是说，从元数据配置中创建的对象）那么需要使用<code>BeanPostProcessor</code>（前面在使用<a href="#beans-factory-extension-bpp"><code>BeanPostProcessor</code>自定义Bean</a>中进行了描述）来替代。 在<code>BeanFactoryPostProcessor</code>（例如使用<code>BeanFactory.getBean()</code>）中使用这些bean的实例虽然在技术上是可行的，但这么来做会将bean过早实例化， 这违反了标准的容器生命周期。同时也会引发一些副作用，例如绕过bean的后置处理。</p>
<p><code>BeanFactoryPostProcessor</code>会在整个容器内起作用，所有它仅仅与正在使用的容器相关。如果在一个容器中定义了<code>BeanFactoryPostProcessor</code>， 那么它只会处理那个容器中的bean。 换句话说，在一个容器中定义的bean不会被另一个容器定义的<code>BeanFactoryPostProcessor</code>处理，即使这两个容器都是同一层次结构的一部分。</p>
<p>bean工厂后置处理器在<code>ApplicationContext</code>中声明时自动执行，这样就可以对定义在容器中的元数据配置进行修改。 Spring包含许多预定义的bean工厂后处理器， 例如<code>PropertyOverrideConfigurer</code> 和<code>PropertySourcesPlaceholderConfigurer</code>。 您还可以使用自定义<code>BeanFactoryPostProcessor</code>。 例如，注册自定义属性编辑器。 .</p>
<p><code>ApplicationContext</code> 自动检测部署到其中的任何实现<code>BeanFactoryPostProcessor</code>接口的bean。 它在适当的时候使用这些bean作为bean工厂后置处理器。 你可以部署这些后置处理器为你想用的任意其它bean。</p>
<p>注意，和<code>BeanPostProcessor</code>一样，通常不应该配置<code>BeanFactoryPostProcessor</code>来进行延迟初始化。如果没有其它bean引用<code>Bean(Factory)PostProcessor</code>， 那么后置处理器就不会被初始化。因此，标记它为延迟初始化就会被忽略，，即便你在<code>&lt;beans /&gt;</code>元素声明中设置<code>default-lazy-init</code>=true属性，<code>Bean(Factory)PostProcessor</code>也会提前初始化bean。</p>
<p><a id="beans-factory-PropertySourcesPlaceholderConfigurer"></a></p>
<h5>[](#beans-factory-PropertySourcesPlaceholderConfigurer示例: 类名替换<code>PropertySourcesPlaceholderConfigurer</code></h5>
<p>您可以使用<code>PropertySourcesPlaceholderConfigurer</code>通过使用标准Java <code>Properties</code>格式从单独文件中的bean定义外部化属性值。 这样做可以使部署应用程序的人能够定制特定于环境的属性，如数据库URL和密码，而无需修改容器的主XML定义文件或文件的复杂性或风险。</p>
<p>考虑以下这个基于XML的元数据配置代码片段，这里的DataSource使用了占位符来定义:</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.context.support.PropertySourcesPlaceholderConfigurer"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"locations"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"classpath:com/something/jdbc.properties"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"dataSource"</span> <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">"close"</span>
        <span class="hljs-attr">class</span>=<span class="hljs-string">"org.apache.commons.dbcp.BasicDataSource"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"driverClassName"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"${jdbc.driverClassName}"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"url"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"${jdbc.url}"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"${jdbc.username}"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"${jdbc.password}"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>
</code></pre>
<p>该示例显示了从外部属性文件配置的属性。在运行时，<code>PropertySourcesPlaceholderConfigurer</code>应用于替换DataSource的某些属性的元数据。 要替换的值被指定为$ {property-name}形式的占位符，它遵循Ant和log4j以及JSP EL样式。</p>
<p>而真正的值是来自于标准的Java <code>Properties</code>格式的文件:</p>
<pre><code>jdbc.driverClassName=org.hsqldb.jdbcDriver
jdbc.url=jdbc:hsqldb:hsql://production:9002
jdbc.username=sa
jdbc.password=root
</code></pre>
<p>在上面的例子中，<code>${jdbc.username}</code> 字符串在运行时将替换为值'sa'，并且同样适用于与属性文件中的键匹配的其他占位符值。 <code>PropertySourcesPlaceholderConfigurer</code>检查bean定义的大多数属性和属性中的占位符。 此外，您可以自定义占位符前缀和后缀。</p>
<p>使用Spring 2.5中引入的<code>context</code> 命名空间，您可以使用专用配置元素配置属性占位符。 您可以在<code>location</code>属性中以逗号分隔列表的形式提供一个或多个位置，如以下示例所示：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">"classpath:com/something/jdbc.properties"</span>/&gt;</span>
</code></pre>
<p><code>PropertySourcesPlaceholderConfigurer</code>不仅在您指定的属性文件中查找属性。 默认情况下，如果它在指定的属性文件中找不到属性，则会检查Spring Environment属性和常规Java System属性。</p>
<p>你可以使用<code>PropertySourcesPlaceholderConfigurer</code>来替换类名，当开发者在运行时需要选择某个特定的实现类时，这是很有用的。例如</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.beans.factory.config.PropertySourcesPlaceholderConfigurer"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"locations"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>classpath:com/something/strategy.properties<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"properties"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>custom.strategy.class=com.something.DefaultStrategy<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"serviceStrategy"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"${custom.strategy.class}"</span>/&gt;</span>
</code></pre>
<p>如果在运行时无法将类解析为有效类，则在即将创建bean时，bean的解析将失败，这是 <code>ApplicationContext</code>在对非延迟初始化bean的<code>preInstantiateSingletons()</code>阶段发生的事。</p>
<p><a id="beans-factory-overrideconfigurer"></a></p>
<h5><a href="#beans-factory-overrideconfigurer"></a>示例: <code>PropertyOverrideConfigurer</code></h5>
<p><code>PropertyOverrideConfigurer</code>, 另外一种bean工厂后置处理器，类似于<code>PropertyPlaceholderConfigurer</code>，但与后者不同的是：对于所有的bean属性，原始定义可以有默认值或也可能没有值。 如果一个<code>Properties</code>覆盖文件没有配置特定的bean属性，则就会使用默认的上下文定义</p>
<p>注意，bean定义是不知道是否被覆盖的，所以从XML定义文件中不能马上看到那个配置正在被使用。在拥有多个<code>PropertyOverrideConfigurer</code> 实例的情况下，为相同bean的属性定义不同的值时，基于覆盖机制只会有最后一个生效。</p>
<p>属性文件配置行采用以下格式:</p>
<pre><code>beanName.property=value
</code></pre>
<p>例如:</p>
<pre><code>dataSource.driverClassName=com.mysql.jdbc.Driver
dataSource.url=jdbc:mysql:mydb
</code></pre>
<p>这个示例文件可以和容器定义一起使用，该容器定义包含一个名为<code>dataSource</code>的bean，该bean具有 <code>driver</code>和<code>url</code>属性</p>
<p>复合属性名称也是被支持的，只要被重写的最后一个属性以外的路径中每个组件都已经是非空时（假设由构造方法初始化）。 在下面的示例中，<code>tom</code> bean的<code>fred</code>属性的 <code>bob</code>属性的<code>sammy</code>属性设置值为<code>123</code>：</p>
<pre><code>tom.fred.bob.sammy=123
</code></pre>
<p>指定的覆盖值通常是文字值，它们不会被转换成bean的引用。这个约定也适用于当XML中的bean定义的原始值指定了bean引用时。</p>
<p>使用Spring 2.5中引入的<code>context</code>命名空间，可以使用专用配置元素配置属性覆盖，如以下示例所示：</p>
<pre><code>&lt;context:property-override location=&quot;classpath:override.properties&quot;/&gt;
</code></pre>
<p><a id="beans-factory-extension-factorybean"></a></p>
<h4><a href="#beans-factory-extension-factorybean"></a>1.8.3. 使用<code>FactoryBean</code>自定义初始化逻辑</h4>
<p>为自己工厂的对象实现<code>org.springframework.beans.factory.FactoryBean</code>接口。</p>
<p><code>FactoryBean</code>接口就是Spring IoC容器实例化逻辑的可插拔点，如果你的初始化代码非常复杂，那么相对于（潜在地）大量详细的XML而言，最好是使用Java语言来表达。 你可以创建自定义的<code>FactoryBean</code>，在该类中编写复杂的初始化代码。然后将自定义的<code>FactoryBean</code>插入到容器中。</p>
<p><code>FactoryBean</code>接口提供下面三个方法</p>
<ul>
<li>
<p><code>Object getObject()</code>: 返回这个工厂创建的对象实例。这个实例可能是共享的，这取决于这个工厂返回的是单例还是原型实例。</p>
</li>
<li>
<p><code>boolean isSingleton()</code>: 如果<code>FactoryBean</code>返回单例，那么这个方法就返回<code>true</code>，否则返回<code>false</code>。</p>
</li>
<li>
<p><code>Class getObjectType()</code>: 返回由<code>getObject()</code>方法返回的对象类型，如果事先不知道的类型则会返回null。</p>
</li>
</ul>
<p>Spring框架大量地使用了<code>FactoryBean</code> 的概念和接口，<code>FactoryBean</code> 接口的50多个实现都随着Spring一同提供。</p>
<p>当开发者需要向容器请求一个真实的<code>FactoryBean</code>实例（而不是它生产的bean）时，调用 <code>ApplicationContext</code>的<code>getBean()</code>方法时在bean的id之前需要添加连字符（&amp;） 所以对于一个给定id为myBean的<code>FactoryBean</code>，调用容器的<code>getBean(&quot;myBean&quot;)</code>方法返回的是FactoryBean的代理，而调用<code>getBean(&quot;&amp;myBean&quot;)</code>方法则返回FactoryBean实例本身</p>
</div></section><footer class="footer-container"><div class="footer-body"><img src="/img/jcohy.png"/><div class="cols-container"><div class="col col-12"><p>jia_chao23@126.com</p><p>https://www.github.com/jiachao23</p></div><div class="col col-6"><dl><dt>文档</dt><dd><a href="/zh-cn/docs/springframework/demo.html" target="_self">Spring Framework</a></dd><dd><a href="/zh-cn/docs/springboot/demo.html" target="_self">SpringBoot</a></dd><dd><a href="/zh-cn/docs/microservices/demo.html" target="_self">Microservices</a></dd></dl></div><div class="col col-6"><dl><dt>资源</dt><dd><a href="/zh-cn/blog/index.html" target="_self">博客</a></dd><dd><a href="/zh-cn/open/index.html" target="_self">开源项目</a></dd></dl></div></div><div class="copyright"><span>Copyright © 2019 www.jcohy.com</span></div></div></footer></div></div>
	<script src="https://f.alicdn.com/react/15.4.1/react-with-addons.min.js"></script>
	<script src="https://f.alicdn.com/react/15.4.1/react-dom.min.js"></script>
	<script>
		window.rootPath = '';
  </script>
	<script src="/build/documentation.js"></script>
</body>
</html>

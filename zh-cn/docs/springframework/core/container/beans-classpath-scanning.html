<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<meta name="keywords" content="keywords: docs，jcohy-docs，spring,类路径扫描和管理组件" />
	<meta name="description" content="Spring  Framework 中文文档 》 类路径扫描和管理组件" />
	<!-- 网页标签标题 -->
	<title>类路径扫描和管理组件</title>
	<link rel="shortcut icon" href="/img/jcohy.ico"/>
	<link rel="stylesheet" href="/build/documentation.css" />
</head>
<body>
	<div id="root"><div class="documentation-page" data-reactroot=""><header class="header-container header-container-normal"><div class="header-body"><a href="/zh-cn/index.html"><img class="logo" src="/img/jcohy_colorful.png"/></a><div class="search search-normal"><span class="icon-search"></span></div><span class="language-switch language-switch-normal">En</span><div class="header-menu"><img class="header-menu-toggle" src="/img/system/menu_gray.png"/><ul><li class="menu-item menu-item-normal"><a href="/zh-cn/index.html" target="_self">首页</a></li><li class="menu-item menu-item-normal menu-item-normal-active"><a href="/zh-cn/docs/Overview.html" target="_self">文档</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/blog/index.html" target="_self">博客</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/open/index.html" target="_self">开源项目</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/resource/index.html" target="_self">资源</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/community/index.html" target="_self">社区</a></li></ul></div></div></header><div class="bar"><div class="bar-body"><img src="/img/system/docs.png" class="front-img"/><span>文档</span><img src="/img/system/docs.png" class="back-img"/></div></div><section class="content-section"><div class="sidemenu"><div class="sidemenu-toggle"><img src="https://img.alicdn.com/tfs/TB1E6apXHGYBuNjy0FoXXciBFXa-200-200.png"/></div><ul><li class="menu-item menu-item-level-1"><span>概述</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/Overview.html" target="_self">概述</a></li></ul></li><li class="menu-item menu-item-level-1"><span>Spring Framework</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/springframework/README.html" target="_self">说明</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/springframework/SUMMARY.html" target="_self">摘要</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/springframework/overview/overview.html" target="_self">概述</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>核心组件<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/springframework/core/overview.html" target="_self">全部章节一览</a></li><li class="menu-item menu-item-level-3"><a target="_self">IOC容器</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a target="_self">测试</a></li></ul></li></ul></div><div class="doc-content markdown-body"><h1>Spring  Framework 中文文档</h1>
<h3><a href="#beans-classpath-scanning"></a>1.10. 类路径扫描和管理组件</h3>
<p>本章中的大多数示例会使用XML配置指定在Spring容器中生成每个<code>BeanDefinition</code>的元数据，上一节（<a href="#beans-annotation-config">基于注解的容器配置</a>）演示了如何通过源代码注解提供大量的元数据配置。 然而，即使在这些示例中，注解也仅仅用于驱动依赖注入。 “base” bean依然会显式地在XML文件中定义。本节介绍通过扫描类路径隐式检测候选组件的选项。候选者组件是class类， 这些类经过过滤匹配，由Spring容器注册的bean定义会成为Spring bean。这消除了使用XML执行bean注册的需要(也就是没有XML什么事儿了),可以使用注解(例如<code>@Component</code>)， AspectJ类型表达式或开发者自定义过滤条件来选择哪些类将在容器中注册bean定义。</p>
<p>从Spring 3.0开始，Spring JavaConfig项目提供的许多功能都是核心Spring 框架的一部分。这允许开发者使用Java而不是使用传统的XML文件来定义bean。 有关如何使用这些新功能的示例，请查看<code>@Configuration</code>, <code>@Bean</code>,<code>@Import</code>, 和 <code>@DependsOn</code>注解。</p>
<p><a id="beans-stereotype-annotations"></a></p>
<h4><a href="#beans-stereotype-annotations"></a>1.10.1. <code>@Component</code>注解和更多模板注解</h4>
<p><code>@Repository</code>注解用于满足存储库(也称为数据访问对象或DAO)的情况,这个注解的用途是自动转换异常。如<a href="https://github.com/DocsHome/spring-docs/blob/master/pages/dataaccess/data-access.md#orm-exception-translation">异常转换</a>中所述。</p>
<p>Spring提供了更多的构造型注解：<code>@Component</code>, <code>@Service</code>, 和<code>@Controller</code>. <code>@Component</code> 可用于管理任何Spring的组件。 <code>@Repository</code>, <code>@Service</code>, 或 <code>@Controller</code>是<code>@Component</code>的特殊化。用于更具体的用例（分别在持久性，服务和表示层中）。 因此，您可以使用<code>@Component</code>注解组件类，但是，通过使用<code>@Repository</code>, <code>@Service</code>, 和 <code>@Controller</code>注解它们，能够让你的类更易于被合适的工具处理或与相应的切面关联。 例如，这些注解可以使目标组件变成切入点。在Spring框架的未来版本中，<code>@Repository</code>, <code>@Service</code>, 和 <code>@Controller</code>也可能带有附加的语义。 因此，如果在使用<code>@Component</code> 或 <code>@Service</code> 来选择服务层时，@Service显然是更好的选择。同理，在持久化层要选择<code>@Repository</code>，它能自动转换异常。</p>
<p><a id="beans-meta-annotations"></a></p>
<h4><a href="#beans-meta-annotations"></a>1.10.2. 使用元注解和组合注解</h4>
<p>Spring提供的许多注解都可以在您自己的代码中用作元注解。 元注解是可以应用于另一个注解的注解。 例如，<a href="#beans-stereotype-annotations">前面提到的</a> <code>@Service</code>注解是使用<code>@Component</code>进行元注解的，如下例所示：</p>
<pre><code class="language-java"><span class="hljs-meta">@Target</span>(ElementType.TYPE)
<span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)
<span class="hljs-meta">@Documented</span>
<span class="hljs-meta">@Component</span> (<span class="hljs-number">1</span>)
<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Service {

    <span class="hljs-comment">// ....</span>
}
</code></pre>
<p>kotlin:</p>
<pre><code class="language-kotlin"><span class="hljs-meta">@Target(AnnotationTarget.TYPE)</span>
<span class="hljs-meta">@Retention(AnnotationRetention.RUNTIME)</span>
<span class="hljs-meta">@MustBeDocumented</span>
<span class="hljs-meta">@Component</span> 
<span class="hljs-keyword">annotation</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Service</span> </span>{

    <span class="hljs-comment">// ...</span>
}
</code></pre>
<p><strong>1</strong>、<code>Component</code>使<code>@Service</code>以与@<code>@Component</code>相同的方式处理。</p>
<p>元注解也可以进行组合，进而创建组合注解。例如，来自Spring MVC的<code>@RestController</code>注解是由<code>@Controller</code>和<code>@ResponseBody</code>组成的</p>
<p>此外，组合注解也可以重新定义来自元注解的属性。这在只想公开元注解的部分属性时非常有用。例如，Spring的<code>@SessionScope</code>注解将它的作用域硬编码为<code>session</code>，但仍允许自定义<code>proxyMode</code>。 以下清单显示了<code>SessionScope</code>注解的定义：</p>
<pre><code class="language-java"><span class="hljs-meta">@Target</span>({ElementType.TYPE, ElementType.METHOD})
<span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)
<span class="hljs-meta">@Documented</span>
<span class="hljs-meta">@Scope</span>(WebApplicationContext.SCOPE_SESSION)
<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SessionScope {

    <span class="hljs-comment">/**
     * Alias for {<span class="hljs-doctag">@link</span> Scope#proxyMode}.
     * &lt;p&gt;Defaults to {<span class="hljs-doctag">@link</span> ScopedProxyMode#TARGET_CLASS}.
     */</span>
    <span class="hljs-meta">@AliasFor</span>(annotation = Scope<span class="hljs-class">.<span class="hljs-keyword">class</span>)
    <span class="hljs-title">ScopedProxyMode</span> <span class="hljs-title">proxyMode</span>() <span class="hljs-title">default</span> <span class="hljs-title">ScopedProxyMode</span>.<span class="hljs-title">TARGET_CLASS</span></span>;

}
</code></pre>
<pre><code class="language-kotlin"><span class="hljs-meta">@Target(AnnotationTarget.TYPE, AnnotationTarget.FUNCTION)</span>
<span class="hljs-meta">@Retention(AnnotationRetention.RUNTIME)</span>
<span class="hljs-meta">@MustBeDocumented</span>
<span class="hljs-meta">@Scope(WebApplicationContext.SCOPE_SESSION)</span>
<span class="hljs-keyword">annotation</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SessionScope</span></span>(
        <span class="hljs-meta">@get:AliasFor</span>(<span class="hljs-keyword">annotation</span> = Scope::<span class="hljs-class"><span class="hljs-keyword">class</span>)</span>
        <span class="hljs-keyword">val</span> proxyMode: ScopedProxyMode = ScopedProxyMode.TARGET_CLASS
)
</code></pre>
<p>然后，您可以使用<code>@SessionScope</code>而不声明<code>proxyMode</code>，如下所示：</p>
<pre><code class="language-java"><span class="hljs-meta">@Service</span>
<span class="hljs-meta">@SessionScope</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SessionScopedService</span> </span>{
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<pre><code class="language-kotlin"><span class="hljs-meta">@Service</span>
<span class="hljs-meta">@SessionScope</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SessionScopedService</span> </span>{
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>您还可以覆盖<code>proxyMode</code>的值，如以下示例所示:</p>
<pre><code class="language-java"><span class="hljs-meta">@Service</span>
<span class="hljs-meta">@SessionScope</span>(proxyMode = ScopedProxyMode.INTERFACES)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SessionScopedUserService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>{
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<pre><code class="language-kotlin"><span class="hljs-meta">@Service</span>
<span class="hljs-meta">@SessionScope(proxyMode = ScopedProxyMode.INTERFACES)</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SessionScopedUserService</span> : <span class="hljs-type">UserService {</span></span>
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>有关更多详细信息，请参阅<a href="https://github.com/spring-projects/spring-framework/wiki/Spring-Annotation-Programming-Model">Spring注解编程模型</a>wiki页面.</p>
<p><a id="beans-scanning-autodetection"></a></p>
<h4><a href="#beans-scanning-autodetection"></a>1.10.3. 自动探测类并注册bean定义</h4>
<p>Spring可以自动检测各代码层中被注解的类，并使用<code>ApplicationContext</code>内注册相应的<code>BeanDefinition</code>。例如，以下两个类就可以被自动探测：</p>
<pre><code class="language-java"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleMovieLister</span> </span>{

    <span class="hljs-keyword">private</span> MovieFinder movieFinder;

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SimpleMovieLister</span><span class="hljs-params">(MovieFinder movieFinder)</span> </span>{
        <span class="hljs-keyword">this</span>.movieFinder = movieFinder;
    }
}

<span class="hljs-meta">@Repository</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JpaMovieFinder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MovieFinder</span> </span>{
    <span class="hljs-comment">// implementation elided for clarity</span>
}
</code></pre>
<pre><code class="language-kotlin"><span class="hljs-meta">@Service</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleMovieLister</span></span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> movieFinder: MovieFinder)

<span class="hljs-meta">@Repository</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JpaMovieFinder</span> : <span class="hljs-type">MovieFinder {</span></span>
    <span class="hljs-comment">// implementation elided for clarity</span>
}
</code></pre>
<p>想要自动检测这些类并注册相应的bean，需要在<code>@Configuration</code>配置中添加<code>@ComponentScan</code>注解，其中<code>basePackages</code>属性是两个类的父包路径。 （或者，您可以指定以逗号或分号或空格分隔的列表，其中包含每个类的父包）。</p>
<pre><code class="language-java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@ComponentScan</span>(basePackages = <span class="hljs-string">"org.example"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span>  </span>{
    ...
}
</code></pre>
<pre><code class="language-kotlin"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@ComponentScan(basePackages = [<span class="hljs-meta-string">"org.example"</span>])</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span>  </span>{
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>为简洁起见，前面的示例可能使用了注解的<code>value</code>属性（即<code>@ComponentScan(&quot;org.example&quot;)</code>）。</p>
<p>或者使用XML配置代替扫描:</p>
<pre><code class="language-xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span>
    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">"http://www.springframework.org/schema/context"</span>
    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">"org.example"</span>/&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span>
</code></pre>
<p>使用<code>&lt;context:component-scan&gt;</code>隐式启用<code>&lt;context:annotation-config&gt;</code>的功能。 使用<code>&lt;context:component-scan&gt;</code>时，通常不需要包含<code>&lt;context:annotation-config&gt;</code>元素。</p>
<p>类路径扫描的包必须保证这些包出现在类路径中。当使用Ant构建JAR时，请确保你没有激活JAR任务的纯文件开关。此外在某些环境装由于安全策略，类路径目录可能不能访问。 JDK 1.7.0_45及更高版本上的独立应用程序（需要在清单中设置“Trusted-Library”） - 请参阅 <a href="https://stackoverflow.com/questions/19394570/java-jre-7u45-breaks-classloader-getresources">http://stackoverflow.com/questions/19394570/java-jre-7u45-breaks-classloader-getresources</a>）。</p>
<p>在JDK 9的模块路径（Jigsaw）上，Spring的类路径扫描通常按预期工作。，但是，请确保在模块信息描述符中导出组件类。 如果您希望Spring调用类的非公共成员，请确保它们已“打开”（即，它们在<code>module-info</code>描述符中使用<code>opens</code> 声明而不是<code>exports</code>声明）。</p>
<p>在使用component-scan元素时， <code>AutowiredAnnotationBeanPostProcessor</code> 和 <code>CommonAnnotationBeanPostProcessor</code>都会隐式包含。意味着这两个组件也是自动探测和注入的。 所有这些都无需XML配置。</p>
<p>您可以通过annotation-config=false属性来禁用<code>AutowiredAnnotationBeanPostProcessor</code> 和<code>CommonAnnotationBeanPostProcessor</code>的注册。</p>
<p><a id="beans-scanning-filters"></a></p>
<h4><a href="#beans-scanning-filters"></a>1.10.4. 在自定义扫描中使用过滤器</h4>
<p>默认情况下，使用<code>@Component</code>, <code>@Repository</code>, <code>@Service</code>,<code>@Controller</code>  <code>@Configuration</code>注解的类或者注解为<code>@Component</code>的自定义注解类才能被检测为候选组件。 但是，开发者可以通过应用自定义过滤器来修改和扩展此行为。将它们添加为<code>@ComponentScan</code>注解的<code>includeFilters</code>或<code>excludeFilters</code>参数(或作为<code>component-scan</code> 元素。元素的<code>include-filter</code>或<code>exclude-filter</code>子元素。每个filter元素都需要包含<code>type</code>和<code>expression</code>属性。下表介绍了筛选选项：</p>
<p>Table 5.过滤类型</p>
<table>
<thead>
<tr>
<th>过滤类型</th>
<th>表达式例子</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>annotation (default)</td>
<td><code>org.example.SomeAnnotation</code></td>
<td>要在目标组件中的类级别出现的注解。</td>
</tr>
<tr>
<td>assignable</td>
<td><code>org.example.SomeClass</code></td>
<td>目标组件可分配给（继承或实现）的类（或接口）。</td>
</tr>
<tr>
<td>aspectj</td>
<td><code>org.example..*Service+</code></td>
<td>要由目标组件匹配的AspectJ类型表达式。</td>
</tr>
<tr>
<td>regex</td>
<td><code>org\.example\.Default.*</code></td>
<td>要由目标组件类名匹配的正则表达式。</td>
</tr>
<tr>
<td>custom</td>
<td><code>org.example.MyTypeFilter</code></td>
<td><code>org.springframework.core.type .TypeFilter</code>接口的自定义实现。</td>
</tr>
</tbody>
</table>
<p>以下示例显示忽略所有<code>@Repository</code> 注解并使用“stub”存储库的配置：</p>
<pre><code class="language-java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@ComponentScan</span>(basePackages = <span class="hljs-string">"org.example"</span>,
        includeFilters = <span class="hljs-meta">@Filter</span>(type = FilterType.REGEX, pattern = <span class="hljs-string">".*Stub.*Repository"</span>),
        excludeFilters = <span class="hljs-meta">@Filter</span>(Repository<span class="hljs-class">.<span class="hljs-keyword">class</span>))
<span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">AppConfig</span> </span>{
    ...
}
</code></pre>
<pre><code class="language-kotlin"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@ComponentScan(basePackages = <span class="hljs-meta-string">"org.example"</span>,
        includeFilters = [Filter(type = FilterType.REGEX, pattern = [<span class="hljs-meta-string">".*Stub.*Repository"</span>])</span>],
        excludeFilters = [Filter(Repository::<span class="hljs-class"><span class="hljs-keyword">class</span>)])</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>{
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>以下清单显示了等效的XML：:</p>
<pre><code class="language-java">&lt;beans&gt;
    &lt;context:component-scan base-package="org.example"&gt;
        &lt;context:include-filter type="regex"
                expression=".*Stub.*Repository"/&gt;
        &lt;context:exclude-filter type="annotation"
                expression="org.springframework.stereotype.Repository"/&gt;
    &lt;/context:component-scan&gt;
&lt;/beans&gt;
</code></pre>
<p>你还可以通过在注解上设置<code>useDefaultFilters=false</code>或通过<code>use-default-filters=&quot;false&quot;</code>作为&lt;<code>&lt;component-scan/&gt;</code> 元素的属性来禁用默认过滤器。这样将不会自动检测带有<code>@Component</code>, <code>@Repository</code>,<code>@Service</code>, <code>@Controller</code>, 或 <code>@Configuration</code>.</p>
<p><a id="beans-factorybeans-annotations"></a></p>
<h4><a href="#beans-factorybeans-annotations"></a>1.10.5.在组件中定义bean的元数据</h4>
<p>Spring组件也可以向容器提供bean定义元数据，。在<code>@Configuration</code>注解的类中使用<code>@Bean</code>注解定义bean元数据(也就是Spring bean),以下示例显示了如何执行此操作：</p>
<pre><code class="language-java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FactoryMethodComponent</span> </span>{

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-meta">@Qualifier</span>(<span class="hljs-string">"public"</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> TestBean <span class="hljs-title">publicInstance</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TestBean(<span class="hljs-string">"publicInstance"</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doWork</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// Component method implementation omitted</span>
    }
}
</code></pre>
<pre><code class="language-kotlin"><span class="hljs-meta">@Component</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FactoryMethodComponent</span> </span>{

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-meta">@Qualifier(<span class="hljs-meta-string">"public"</span>)</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">publicInstance</span><span class="hljs-params">()</span></span> = TestBean(<span class="hljs-string">"publicInstance"</span>)

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doWork</span><span class="hljs-params">()</span></span> {
        <span class="hljs-comment">// Component method implementation omitted</span>
    }
}
</code></pre>
<p>这个类是一个Spring组件，它有个 <code>doWork()</code>方法。然而，它还有一个工厂方法 <code>publicInstance()</code>用于产生bean定义。<code>@Bean</code>注解了工厂方法， 还设置了其他bean定义的属性，例如通过<code>@Qualifier</code>注解的qualifier值。可以指定的其他方法级别的注解是 <code>@Scope</code>, <code>@Lazy</code>以及自定义的qualifier注解。</p>
<p>除了用于组件初始化的角色之外，<code>@Lazy</code>注解也可以在<code>@Autowired</code>或者code&gt;@Inject注解上，在这种情况下，该注入将会变成延迟注入代理lazy-resolution proxy（也就是懒加载）。</p>
<p>自动注入的字段和方法也可以像前面讨论的一样被支持，也支持<code>@Bean</code>方法的自动注入。以下示例显示了如何执行此操作：:</p>
<pre><code class="language-java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FactoryMethodComponent</span> </span>{

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-meta">@Qualifier</span>(<span class="hljs-string">"public"</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> TestBean <span class="hljs-title">publicInstance</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TestBean(<span class="hljs-string">"publicInstance"</span>);
    }

    <span class="hljs-comment">// use of a custom qualifier and autowiring of method parameters</span>
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> TestBean <span class="hljs-title">protectedInstance</span><span class="hljs-params">(
            @Qualifier(<span class="hljs-string">"public"</span>)</span> TestBean spouse,
            @<span class="hljs-title">Value</span><span class="hljs-params">(<span class="hljs-string">"#{privateInstance.age}"</span>)</span> String country) </span>{
        TestBean tb = <span class="hljs-keyword">new</span> TestBean(<span class="hljs-string">"protectedInstance"</span>, <span class="hljs-number">1</span>);
        tb.setSpouse(spouse);
        tb.setCountry(country);
        <span class="hljs-keyword">return</span> tb;
    }

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> TestBean <span class="hljs-title">privateInstance</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TestBean(<span class="hljs-string">"privateInstance"</span>, i++);
    }

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-meta">@RequestScope</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> TestBean <span class="hljs-title">requestScopedInstance</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TestBean(<span class="hljs-string">"requestScopedInstance"</span>, <span class="hljs-number">3</span>);
    }
}
</code></pre>
<pre><code class="language-kotlin"><span class="hljs-meta">@Component</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FactoryMethodComponent</span> </span>{

    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> {
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> i: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span>
    }

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-meta">@Qualifier(<span class="hljs-meta-string">"public"</span>)</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">publicInstance</span><span class="hljs-params">()</span></span> = TestBean(<span class="hljs-string">"publicInstance"</span>)

    <span class="hljs-comment">// use of a custom qualifier and autowiring of method parameters</span>
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">protectedInstance</span><span class="hljs-params">(
            <span class="hljs-meta">@Qualifier(<span class="hljs-meta-string">"public"</span>)</span> spouse: <span class="hljs-type">TestBean</span>,
            <span class="hljs-meta">@Value(<span class="hljs-meta-string">"#{privateInstance.age}"</span>)</span> country: <span class="hljs-type">String</span>)</span></span> = TestBean(<span class="hljs-string">"protectedInstance"</span>, <span class="hljs-number">1</span>).apply {
        <span class="hljs-keyword">this</span>.spouse = spouse
        <span class="hljs-keyword">this</span>.country = country
    }

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">privateInstance</span><span class="hljs-params">()</span></span> = TestBean(<span class="hljs-string">"privateInstance"</span>, i++)

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-meta">@RequestScope</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">requestScopedInstance</span><span class="hljs-params">()</span></span> = TestBean(<span class="hljs-string">"requestScopedInstance"</span>, <span class="hljs-number">3</span>)
}
</code></pre>
<p>该示例将方法参数为<code>String</code>，名称为<code>country</code>的bean自动装配为另一个名为<code>privateInstance</code>的bean的<code>age</code>属性值。 Spring表达式语言元素通过记号<code>#{ &lt;expression&gt; }</code>来定义属性的值。对于 <code>@Value</code>注解，表达式解析器在解析表达式后，会查找bean的名字并设置value值。</p>
<p>从Spring4.3开始，您还可以声明一个类型为<code>InjectionPoint</code>的工厂方法参数（或其更具体的子类：<code>DependencyDescriptor</code>）以访问触发创建当前bean的请求注入点。 请注意，这仅适用于真实创建的bean实例，而不适用于注入现有实例。因此，这个特性对prototype scope的bean最有意义。对于其他作用域，工厂方法将只能看到触发在给定scope中创建新bean实例的注入点。 例如，触发创建一个延迟单例bean的依赖。在这种情况下，使用提供的注入点元数据拥有优雅的语义。 以下示例显示了如何使用<code>InjectionPoint</code>:</p>
<pre><code class="language-java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FactoryMethodComponent</span> </span>{

    <span class="hljs-meta">@Bean</span> <span class="hljs-meta">@Scope</span>(<span class="hljs-string">"prototype"</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> TestBean <span class="hljs-title">prototypeInstance</span><span class="hljs-params">(InjectionPoint injectionPoint)</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TestBean(<span class="hljs-string">"prototypeInstance for "</span> + injectionPoint.getMember());
    }
}
</code></pre>
<pre><code class="language-kotlin"><span class="hljs-meta">@Component</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FactoryMethodComponent</span> </span>{

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-meta">@Scope(<span class="hljs-meta-string">"prototype"</span>)</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">prototypeInstance</span><span class="hljs-params">(injectionPoint: <span class="hljs-type">InjectionPoint</span>)</span></span> =
            TestBean(<span class="hljs-string">"prototypeInstance for <span class="hljs-subst">${injectionPoint.member}</span>"</span>)
}
</code></pre>
<p>在Spring组件中处理<code>@Bean</code>和在code&gt;@Configuration中处理是不一样的，区别在于，在<code>@Component</code>中，不会使用CGLIB增强去拦截方法和属性的调用。在<code>@Configuration</code>注解的类中， <code>@Bean</code>注解创建的bean对象会使用CGLIB代理对方法和属性进行调用。方法的调用不是常规的Java语法，而是通过容器来提供通用的生命周期管理和代理Spring bean， 甚至在通过编程的方式调用<code>@Bean</code>方法时也会产生对其它bean的引用。相比之下，在一个简单的<code>@Component</code>类中调用<code>@Bean</code>方法中的方法或字段具有标准Java语义，这里没有用到特殊的CGLIB处理或其他约束。</p>
<p>开发者可以将<code>@Bean</code>方法声明为<code>static</code>的，并允许在不将其包含的配置类作为实例的情况下调用它们。这在定义后置处理器bean时是特别有意义的。 例如<code>BeanFactoryPostProcessor</code> 或<code>BeanPostProcessor</code>),，因为这类bean会在容器的生命周期前期被初始化，而不会触发其它部分的配置。</p>
<p>对静态<code>@Bean</code>方法的调用永远不会被容器拦截，即使在<code>@Configuration</code>类内部。这是用为CGLIB的子类代理限制了只会重写非静态方法。因此， 对另一个<code>@Bean</code>方法的直接调用只能使用标准的Java语法。也只能从工厂方法本身直接返回一个独立的实例。</p>
<p>由于Java语言的可见性，<code>@Bean</code>方法并不一定会对容器中的bean有效。开发者可能很随意的在非<code>@Configuration</code>类中定义或定义为静态方法。然而， 在<code>@Configuration</code>类中的正常<code>@Bean</code>方法都会被重写，因此，它们不应该定义为<code>private</code>或<code>final</code>。</p>
<p><code>@Bean</code>方法也可以用在父类中，同样适用于Java 8接口中的默认方法。这使得组建复杂的配置时能具有更好的灵活性，甚至可能通过Java 8的默认方法实现多重继承。 这种特性在Spring 4.2开始支持。</p>
<p>最后，请注意，单个类可以为同一个bean保存多个<code>@Bean</code>方法，例如根据运行时可用的依赖关系选择合适的工厂方法。使用算法会选择 “最贪婪“的构造方法， 一些场景可能会按如下方法选择相应的工厂方法：满足最多依赖的会被选择，这与使用<code>@Autowired</code> 时选择多个构造方法时类似。</p>
<p><a id="beans-scanning-name-generator"></a></p>
<h4><a href="#beans-scanning-name-generator"></a>1.10.6. 命名自动注册组件</h4>
<p>扫描处理过程，其中一步就是自动探测组件，扫描器使用<code>BeanNameGenerator</code>对探测到的组件命名。默认情况下，各代码层注解(<code>@Component</code>, <code>@Repository</code>, <code>@Service</code>, 和 <code>@Controller</code>)所包含的name值，将会作为相应的bean定义的名字。</p>
<p>如果这些注解没有name值，或者是其他一些被探测到的组件（比如使用自定义过滤器探测到的)，默认会又bean name生成器生成，使用小写类名作为bean名字。 例如，如果检测到以下组件类，则名称为<code>myMovieLister</code>和<code>movieFinderImpl</code>:</p>
<pre><code class="language-java"><span class="hljs-meta">@Service</span>(<span class="hljs-string">"myMovieLister"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleMovieLister</span> </span>{
    <span class="hljs-comment">// ...</span>
}

<span class="hljs-meta">@Repository</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MovieFinderImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MovieFinder</span> </span>{
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<pre><code class="language-kotlin"><span class="hljs-meta">@Service(<span class="hljs-meta-string">"myMovieLister"</span>)</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleMovieLister</span> </span>{
    <span class="hljs-comment">// ...</span>
}

<span class="hljs-meta">@Repository</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MovieFinderImpl</span> : <span class="hljs-type">MovieFinder {</span></span>
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>如果您不想依赖默认的bean命名策略，则可以提供自定义bean命名策略。首先，实现 <a href="https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/beans/factory/support/BeanNameGenerator.html"><code>BeanNameGenerator</code></a>接口，并确保包括一个默认的无参构造函数。 然后，在配置扫描程序时提供完全限定的类名，如以下示例注解和bean定义所示：</p>
<pre><code>@Configuration
@ComponentScan(basePackages = &quot;org.example&quot;, nameGenerator = MyNameGenerator.class)
public class AppConfig {
    ...
}
//kotlin
@Configuration
@ComponentScan(basePackages = [&quot;org.example&quot;], nameGenerator = MyNameGenerator::class)
class AppConfig {
    // ...
}

&lt;beans&gt;
    &lt;context:component-scan base-package=&quot;org.example&quot;
        name-generator=&quot;org.example.MyNameGenerator&quot; /&gt;
&lt;/beans&gt;
</code></pre>
<p>作为一般规则，考虑在其他组件可能对其进行显式引用时使用注解指定名称。 另一方面，只要容器负责装配时，自动生成的名称就足够了。</p>
<p><a id="beans-scanning-scope-resolver"></a></p>
<h4><a href="#beans-scanning-scope-resolver"></a>1.10.7.为自动检测组件提供范围</h4>
<p>与一般的Spring管理组件一样，自动检测组件的默认和最常见的作用域是<code>singleton</code>。但是，有时您需要一个可由<code>@Scope</code>注解指定的不同作用域。 您可以在注解中提供作用域的名称，如以下示例所示：</p>
<pre><code class="language-java"><span class="hljs-meta">@Scope</span>(<span class="hljs-string">"prototype"</span>)
<span class="hljs-meta">@Repository</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MovieFinderImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MovieFinder</span> </span>{
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<pre><code class="language-kotlin"><span class="hljs-meta">@Scope(<span class="hljs-meta-string">"prototype"</span>)</span>
<span class="hljs-meta">@Repository</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MovieFinderImpl</span> : <span class="hljs-type">MovieFinder {</span></span>
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<p><code>@Scope</code>注解仅在具体bean类（用于带注解的组件）或工厂方法（用于<code>@Bean</code>方法）上进行关联。 与XML bean定义相比，没有bean继承的概念，并且 类级别的继承结构与元数据无关。</p>
<p>有关特定于Web的范围（如Spring上下文中的“request” or “session”）的详细信息，请参阅<a href="#beans-factory-scopes-other">请求，会话，应用程序和WebSocket作用域</a>。 这些作用域与构建注解一样，您也可以使用Spring的元注解方法编写自己的作用域注解：例如，使用<code>@Scope(&quot;prototype&quot;)</code>进行元注解的自定义注解，可能还会声明自定义作用域代理模式。</p>
<p>想要提供自定义作用域的解析策略，而不是依赖于基于注解的方法，那么需要实现<a href="https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/context/annotation/ScopeMetadataResolver.html"><code>ScopeMetadataResolver</code></a>接口，并确保包含一个默认的无参数构造函数。 然后，在配置扫描程序时提供完全限定类名。以下注解和bean定义示例显示：</p>
<pre><code class="language-java">//java
@Configuration
@ComponentScan(basePackages = "org.example", scopeResolver = MyScopeResolver.class)
public class AppConfig {
    ...
}
//kotlin
@Configuration
@ComponentScan(basePackages = ["org.example"], scopeResolver = MyScopeResolver::class)
class AppConfig {
    // ...
}
&lt;beans&gt;
    &lt;context:component-scan base-package="org.example" scope-resolver="org.example.MyScopeResolver"/&gt;
&lt;/beans&gt;
</code></pre>
<p>当使用某个非单例作用域时，为作用域对象生成代理可能非常必要，原因参看 <a href="#beans-factory-scopes-other-injection">作为依赖关系的作用域bean</a>。 为此，组件扫描元素上提供了scoped-proxy属性。 三个可能的值是：<code>no</code>, <code>interfaces</code>, 和 <code>targetClass</code>。 例如，以下配置导致标准JDK动态代理：</p>
<pre><code class="language-java">//java
@Configuration
@ComponentScan(basePackages = "org.example", scopedProxy = ScopedProxyMode.INTERFACES)
public class AppConfig {
    ...
}

//kotlin
@Configuration
@ComponentScan(basePackages = ["org.example"], scopedProxy = ScopedProxyMode.INTERFACES)
class AppConfig {
    // ...
}


&lt;beans&gt;
    &lt;context:component-scan base-package="org.example" scoped-proxy="interfaces"/&gt;
&lt;/beans&gt;
</code></pre>
<p><a id="beans-scanning-qualifiers"></a></p>
<h4><a href="#beans-scanning-qualifiers"></a>1.10.8. 为注解提供Qualifier元数据</h4>
<p>在前面<a href="#beans-autowired-annotation-qualifiers">使用qualifiers微调基于注解自动装配</a>讨论过<code>@Qualifier</code> 注解。该部分中的示例演示了在解析自动注入候选者时使用 <code>@Qualifier</code>注解和自定义限定符注解以提供细粒度控制。 因为这些示例基于XML bean定义，所以使用XML中的<code>bean</code>元素的 <code>qualifier</code> 或 <code>meta</code>子元素在候选bean定义上提供了限定符元数据。当依靠类路径扫描并自动检测组件时， 可以在候选类上提供具有类型级别注解的限定符元数据。以下三个示例演示了此技术：</p>
<pre><code class="language-java"><span class="hljs-meta">@Component</span>
<span class="hljs-meta">@Qualifier</span>(<span class="hljs-string">"Action"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ActionMovieCatalog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MovieCatalog</span> </span>{
    <span class="hljs-comment">// ...</span>
}

<span class="hljs-meta">@Component</span>
<span class="hljs-meta">@Genre</span>(<span class="hljs-string">"Action"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ActionMovieCatalog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MovieCatalog</span> </span>{
    <span class="hljs-comment">// ...</span>
}

<span class="hljs-meta">@Component</span>
<span class="hljs-meta">@Offline</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CachingMovieCatalog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MovieCatalog</span> </span>{
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<pre><code class="language-kotlin"><span class="hljs-meta">@Component</span>
<span class="hljs-meta">@Qualifier(<span class="hljs-meta-string">"Action"</span>)</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ActionMovieCatalog</span> : <span class="hljs-type">MovieCatalog</span></span>

<span class="hljs-meta">@Component</span>
<span class="hljs-meta">@Genre(<span class="hljs-meta-string">"Action"</span>)</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ActionMovieCatalog</span> : <span class="hljs-type">MovieCatalog {</span></span>
    <span class="hljs-comment">// ...</span>
}

<span class="hljs-meta">@Component</span>
<span class="hljs-meta">@Offline</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CachingMovieCatalog</span> : <span class="hljs-type">MovieCatalog {</span></span>
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>与大多数基于注解的替代方法一样，注解元数据绑定到类定义本身，而使用在XML配置时，允许同一类型的beans在qualifier元数据中提供变量， 因为元数据是依据实例而不是类来提供的。</p>
<p><a id="beans-scanning-index"></a></p>
<h4><a href="#beans-scanning-index"></a>1.10.9. 生成候选组件的索引</h4>
<p>虽然类路径扫描非常快，但通过在编译时创建候选的静态列表。可以提高大型应用程序的启动性能。在此模式下，应用程序的所有模块都必须使用此机制， 当 <code>ApplicationContext</code>检测到此类索引时，它将自动使用它，而不是扫描类路径。</p>
<p>若要生成索引， 只需向包含组件扫描指令目标组件的每个模块添加一个附加依赖项。以下示例显示了如何使用Maven执行此操作：</p>
<pre><code class="language-java">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-context-indexer&lt;/artifactId&gt;
        &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;
        &lt;optional&gt;true&lt;/optional&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>以下示例显示了如何使用Gradle执行此操作:</p>
<pre><code class="language-groovy">dependencies {
     compileOnly <span class="hljs-string">"org.springframework:spring-context-indexer:5.2.0.RELEASE"</span>
}
</code></pre>
<p>对于Gradle 4.6和更高版本，应在 <code>annotationProcessor</code> 配置中声明依赖项，如以下示例所示：</p>
<pre><code class="language-groovy">dependencies {
    annotationProcessor <span class="hljs-string">"org.springframework:spring-context-indexer:{spring-version}"</span>
}
</code></pre>
<p>这个过程将产生一个名为<code>META-INF/spring.components</code>的文件，并将包含在jar包中。</p>
<p>在IDE中使用此模式时，必须将<code>spring-context-indexer</code>注册为注解处理器， 以确保更新候选组件时索引是最新的。</p>
<p>如果在类路径中找到 <code>META-INF/spring.components</code> 时，将自动启用索引。如果某个索引对于某些库(或用例)是不可用的， 但不能为整个应用程序构建，则可以将<code>spring.index.ignore</code>设置为<code>true</code>，从而将其回退到常规类路径的排列(即根本不存在索引)， 或者作为系统属性或在<code>spring.properties</code>文件位于类路径的根目录中。</p>
</div></section><footer class="footer-container"><div class="footer-body"><img src="/img/jcohy.png"/><div class="cols-container"><div class="col col-12"><p>jia_chao23@126.com</p><p>https://www.github.com/jiachao23</p></div><div class="col col-6"><dl><dt>文档</dt><dd><a href="/zh-cn/docs/springframework/demo.html" target="_self">Spring Framework</a></dd><dd><a href="/zh-cn/docs/springboot/demo.html" target="_self">SpringBoot</a></dd><dd><a href="/zh-cn/docs/microservices/demo.html" target="_self">Microservices</a></dd></dl></div><div class="col col-6"><dl><dt>资源</dt><dd><a href="/zh-cn/blog/index.html" target="_self">博客</a></dd><dd><a href="/zh-cn/open/index.html" target="_self">开源项目</a></dd></dl></div></div><div class="copyright"><span>Copyright © 2019 www.jcohy.com</span></div></div></footer></div></div>
	<script src="https://f.alicdn.com/react/15.4.1/react-with-addons.min.js"></script>
	<script src="https://f.alicdn.com/react/15.4.1/react-dom.min.js"></script>
	<script>
		window.rootPath = '';
  </script>
	<script src="/build/documentation.js"></script>
</body>
</html>

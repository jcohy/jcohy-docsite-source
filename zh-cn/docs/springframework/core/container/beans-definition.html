<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<meta name="keywords" content="keywords: docs，jcohy-docs，spring,Bean 的概述" />
	<meta name="description" content="Spring  Framework 中文文档 》 Bean 的概述" />
	<!-- 网页标签标题 -->
	<title>Bean 的概述</title>
	<link rel="shortcut icon" href="/img/jcohy.ico"/>
	<link rel="stylesheet" href="/build/documentation.css" />
</head>
<body>
	<div id="root"><div class="documentation-page" data-reactroot=""><header class="header-container header-container-normal"><div class="header-body"><a href="/zh-cn/index.html"><img class="logo" src="/img/jcohy_colorful.png"/></a><div class="search search-normal"><span class="icon-search"></span></div><span class="language-switch language-switch-normal">En</span><div class="header-menu"><img class="header-menu-toggle" src="/img/system/menu_gray.png"/><ul><li class="menu-item menu-item-normal"><a href="/zh-cn/index.html" target="_self">首页</a></li><li class="menu-item menu-item-normal menu-item-normal-active"><a href="/zh-cn/docs/Overview.html" target="_self">文档</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/blog/index.html" target="_self">博客</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/open/index.html" target="_self">开源项目</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/resource/index.html" target="_self">资源</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/community/index.html" target="_self">社区</a></li></ul></div></div></header><div class="bar"><div class="bar-body"><img src="/img/system/docs.png" class="front-img"/><span>文档</span><img src="/img/system/docs.png" class="back-img"/></div></div><section class="content-section"><div class="sidemenu"><div class="sidemenu-toggle"><img src="https://img.alicdn.com/tfs/TB1E6apXHGYBuNjy0FoXXciBFXa-200-200.png"/></div><ul><li class="menu-item menu-item-level-1"><span>概述</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/Overview.html" target="_self">概述</a></li></ul></li><li class="menu-item menu-item-level-1"><span>Spring Framework</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/springframework/README.html" target="_self">说明</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/springframework/SUMMARY.html" target="_self">摘要</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/springframework/overview/overview.html" target="_self">概述</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>核心组件<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/springframework/core/overview.html" target="_self">全部章节一览</a></li><li class="menu-item menu-item-level-3"><a target="_self">IOC容器</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a target="_self">测试</a></li></ul></li></ul></div><div class="doc-content markdown-body"><h1>Spring  Framework 中文文档</h1>
<h3><a href="#beans-definition"></a>1.3. Bean 的概述</h3>
<p>Spring IoC容器管理一个或多个bean。这些bean是由您提供给容器的元数据配置创建的(例如，XML <code>&lt;bean/&gt;</code>定义的形式)。</p>
<p>在容器内部，这些bean定义表示为<code>BeanDefinition</code>对象，其中包含（其他信息）以下元数据</p>
<ul>
<li>
<p>限定包类名称: 通常，定义的bean的实际实现类。</p>
</li>
<li>
<p>bean行为配置元素, 定义Bean的行为约束(例如作用域，生命周期回调等等）</p>
</li>
<li>
<p>bean需要引用其他bean来完成工作. 这些引用也称为协作或依赖关系.</p>
</li>
<li>
<p>其他配置用于新对象的创建，例如使用bean的数量来管理连接池，或者限制池的大小。</p>
</li>
</ul>
<p>以下是每个bean定义的属性:</p>
<p>Table 1. Bean的定义</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>对应的章节名</th>
</tr>
</thead>
<tbody>
<tr>
<td>Class</td>
<td><a href="#beans-factory-class">实例化Bean</a></td>
</tr>
<tr>
<td>Name</td>
<td><a href="#beans-beanname">命名Bean</a></td>
</tr>
<tr>
<td>Scope</td>
<td><a href="#beans-factory-scopes">Bean 的作用域</a></td>
</tr>
<tr>
<td>Constructor arguments</td>
<td><a href="#beans-factory-collaborators">依赖注入</a></td>
</tr>
<tr>
<td>Properties</td>
<td><a href="#beans-factory-collaborators">依赖注入</a></td>
</tr>
<tr>
<td>Autowiring mode</td>
<td><a href="#beans-factory-autowire">自动装配</a></td>
</tr>
<tr>
<td>Lazy initialization mode</td>
<td><a href="#beans-factory-lazy-init">懒加载Bean</a></td>
</tr>
<tr>
<td>Initialization method</td>
<td><a href="#beans-factory-lifecycle-initializingbean">初始化方法回调</a></td>
</tr>
<tr>
<td>Destruction method</td>
<td><a href="#beans-factory-lifecycle-disposablebean">销毁方法回调</a></td>
</tr>
</tbody>
</table>
<p>除了bean定义包含如何创建特定的bean的信息外，<code>ApplicationContext</code>实现还允许用户在容器中注册现有的、已创建的对象。 通过<code>getBeanFactory()</code>访问到返回值为<code>DefaultListableBeanFactory</code>的实现的ApplicationContext的BeanFactory <code>DefaultListableBeanFactory</code>支持通过<code>registerSingleton(..)</code>和<code>registerBeanDefinition(..)</code>方法来注册对象。 然而，典型的应用程序只能通过元数据配置来定义bean。</p>
<p>为了让容器正确推断它们在自动装配和其它内置步骤，需要尽早注册Bean的元数据和手动使用单例的实例。虽然覆盖现有的元数据和现有的单例实例在某种程度上是支持的， 但是新bean在运行时(同时访问动态工厂）注册官方并不支持，可能会导致并发访问异常、bean容器中的不一致状态，或者两者兼有。</p>
<p><a id="beans-beanname"></a></p>
<h4><a href="#beans-beanname"></a>1.3.1. 命名bean</h4>
<p>每个bean都有一个或多个标识符，这些标识符在容器托管时必须是唯一的。bean通常只有一个标识符，但如果需要到的标识不止一个时，可以考虑使用别名。</p>
<p>在基于XML的配置中，开发者可以使用<code>id</code>属性，name属性或两者都指定bean的标识符。 <code>id</code>属性允许您指定一个<code>id</code>，通常这些名字使用字母和数字的组合(例如'myBean', 'someService'，等等），但也可以包含特殊字符。 如果你想使用bean别名，您可以在name属性上定义，使用逗号(<code>,</code>），分号(<code>;</code>)，或白色空格进行分隔。由于历史因素， 请注意，在Spring 3.1之前的版本中，id属性被定义为<code>xsd:ID</code>类型，它会限制某些字符。从3.1开始，它被定义为<code>xsd:string</code>类型。请注意，由于bean <code>id</code>的唯一性，他仍然由容器执行，不再由XML解析器执行。</p>
<p>您也无需提供bean的<code>name</code>或 <code>id</code>，如果没有显式地提供<code>name</code>或 <code>id</code>，容器会给bean生成唯一的名称。 然而，如果你想引用bean的名字，可以使用ref元素或使用<a href="#beans-servicelocator">Service Locator</a>（服务定位器）来进行查找（此时必须提供名称）。 不使用名称的情况有： <a href="#beans-inner-beans">内部bean</a>和<a href="#beans-factory-autowire">自动装配的协作者</a></p>
<p>Bean 的命名约定</p>
<p>bean的命名是按照标准的Java字段名称命名来进行的。也就是说，bean名称开始需要以小写字母开头，后面采用“驼峰式”的方法。 例如<code>accountManager</code>,<code>accountService</code>, <code>userDao</code>, <code>loginController</code>等。</p>
<p>一致的beans命名能够让配置更方便阅读和理解，如果你正在使用Spring AOP，当你通过bean名称应用到通知时，这种命名方式会有很大的帮助。</p>
<p>在类路径中进行组件扫描时， Spring 会根据上面的规则为未命名的组件生成 bean 名称，规则是：采用简单的类名，并将其初始字符转化为小写字母。 然而，在特殊情况下，当有一个以上的字符，同时第一个和第二个字符都是大写时，原来的规则仍然应该保留。这些规则与Java中定义实例的相同。 例如Spring使用的<code>java.beans.Introspector.decapitalize</code> 类。</p>
<p><a id="beans-beanname-alias"></a></p>
<h5><a href="#beans-beanname-alias"></a>为外部定义的bean起别名</h5>
<p>在对bean定义时，除了使用<code>id</code>属性指定唯一的名称外，还可以提供多个别名，这需要通过<code>name</code>属性指定。 所有这个名称都会指向同一个bean，在某些情况下提供别名非常有用，例如为了让应用每一个组件都能更容易的对公共组件进行引用。</p>
<p>然而，在定义bean时就指定所有的别名并不是很恰当的。有时期望能够在当前位置为那些在别处定义的bean引入别名。在XML配置文件中， 可以通过<code>&lt;alias/&gt;</code>元素来定义bean别名，例如：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">alias</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"fromName"</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">"toName"</span>/&gt;</span>
</code></pre>
<p>上面示例中，在同一个容器中名为<code>fromName</code> 的bean定义，在增加别名定义后，也可以使用<code>toName</code>来引用。</p>
<p>例如，在子系统A中通过名字<code>subsystemA-dataSource</code>配置的数据源。在子系统B中可能通过名字 <code>subsystemB-dataSource</code>来引用。 当两个子系统构成主应用的时候，主应用可能通过名字<code>myApp-dataSource</code>引用数据源，将全部三个名字引用同一个对象，你可以将下面的别名定义添加到应用配置中：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">alias</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"subsystemA-dataSource"</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">"subsystemB-dataSource"</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">alias</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"subsystemA-dataSource"</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">"myApp-dataSource"</span> /&gt;</span>
</code></pre>
<p>现在，每个组件和主应用程序都可以通过一个唯一的名称引用dataSource，并保证不与任何其他定义冲突（有效地创建命名空间），但它们引用相同的bean。 .</p>
<p>Java配置</p>
<p>如果你是用java配置， <code>@Bean</code>可以用来提供别名，详情见<a href="#beans-java-bean-annotation">使用<code>@Bean</code> 注解。</a></p>
<p><a id="beans-factory-class"></a></p>
<h4><a href="#beans-factory-class"></a>1.3.2. 实例化Bean</h4>
<p>bean定义基本上就是用来创建一个或多个对象的配置，当需要bean的时候，容器会查找配置并且根据bean定义封装的元数据来创建（或获取）实际对象。</p>
<p>如果你使用基于XML的配置，那么可以在<code>&lt;bean/&gt;</code> 元素中通过 <code>class</code>属性来指定对象类型。 class属性实际上就是<code>BeanDefinition</code>实例中的<code>class</code>属性。他通常是必需的（一些例外情况，查看 <a href="#beans-factory-class-instance-factory-method">使用实例工厂方法实例化</a> 和 <a href="#beans-child-bean-definitions">Bean 定义的继承</a>)。有两种方式使用Class属性</p>
<ul>
<li>
<p>通常情况下，会直接通过反射调用构造方法来创建bean，这种方式与Java代码的<code>new</code>创建相似。</p>
</li>
<li>
<p>通过静态工厂方法创建，类中包含静态方法。通过调用静态方法返回对象的类型可能和Class一样，也可能完全不一样。</p>
</li>
</ul>
<p>内部类名</p>
<p>如果你想配置静态内部类，那么必须使用内部类的二进制名称。</p>
<p>例如，在<code>com.example</code>有个<code>SomeThing</code>类，这个类里面有个静态内部类<code>OtherThing</code>，这种情况下bean定义的class属性应该写作 <code>com.example.SomeThing$OtherThing</code>.</p>
<p>使用$字符来分隔外部类和内部类的名称</p>
<p><a id="beans-factory-class-ctor"></a></p>
<h5><a href="#beans-factory-class-ctor"></a>使用构造器实例化</h5>
<p>当您通过构造方法创建bean时，所有普通类都可以使用并与Spring兼容。也就是说，正在开发的类不需要实现任何特定接口或以特定方式编码。 只要指定bean类就足够了。但是，根据您为该特定bean使用的IoC类型，您可能需要一个默认（空）构造函数。</p>
<p>Spring IoC容器几乎可以管理您希望它管理的任何类。它不仅限于管理真正的JavaBeans。大多数Spring用户更喜欢管理那些只有一个默认构造函数（无参数） 和有合适的setter和getter方法的真实的JavaBeans，还可以在容器中放置更多的外部非bean形式（non-bean-style)类，例如：如果需要使用一个绝对违反JavaBean规范的遗留连接池时 Spring也是可以管理它的。</p>
<p>使用基于XML的配置元数据，您可以按如下方式指定bean类：:</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"exampleBean"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"examples.ExampleBean"</span>/&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"anotherExample"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"examples.ExampleBeanTwo"</span>/&gt;</span>
</code></pre>
<p>给构造方法指定参数以及为bean实例化设置属性将在后面的<a href="#beans-factory-collaborators">依赖注入</a>中说明。</p>
<p><a id="beans-factory-class-static-factory-method"></a></p>
<h5><a href="#beans-factory-class-static-factory-method"></a>使用静态工厂方法实例化</h5>
<p>当采用静态工厂方法创建bean时，除了需要指定class属性外，还需要通过<code>factory-method</code> 属性来指定创建bean实例的工厂方法。 Spring将会调用此方法（其可选参数接下来会介绍）返回实例对象。从这样看来，它与通过普通构造器创建类实例没什么两样。</p>
<p>下面的bean定义展示了如何通过工厂方法来创建bean实例。注意，此定义并未指定对象的返回类型，只是指定了该类包含的工厂方法，在这个例中， <code>createInstance()</code>必须是一个静态（static）的方法。</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"clientService"</span>
    <span class="hljs-attr">class</span>=<span class="hljs-string">"examples.ClientService"</span>
    <span class="hljs-attr">factory-method</span>=<span class="hljs-string">"createInstance"</span>/&gt;</span>
</code></pre>
<p>以下示例显示了一个可以使用前面的bean定义的类:</p>
<p>java:</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClientService</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ClientService clientService = <span class="hljs-keyword">new</span> ClientService();
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">ClientService</span><span class="hljs-params">()</span> </span>{}

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ClientService <span class="hljs-title">createInstance</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> clientService;
    }
}
</code></pre>
<p>kotlin:</p>
<pre><code class="language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClientService</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">constructor</span></span>() {
    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> {
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> clientService = ClientService()
        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createInstance</span><span class="hljs-params">()</span></span> = clientService
    }
}
</code></pre>
<p>给工厂方法指定参数以及为bean实例设置属性的详细内容请查阅<a href="#beans-factory-properties-detailed">依赖和配置详解</a> 。</p>
<p><a id="beans-factory-class-instance-factory-method"></a></p>
<h5><a href="#beans-factory-class-instance-factory-method"></a>使用实例工厂方法实例化</h5>
<p>通过调用工厂实例的非静态方法进行实例化与通过<a href="#beans-factory-class-static-factory-method">静态工厂方法</a>实例化类似， 要使用此机制，请将class属性保留为空，并在<code>factory-bean</code>属性中指定当前（或父级或祖先）容器中bean的名称，该容器包含要调用以创建对象的实例方法。 使用<code>factory-method</code>属性设置工厂方法本身的名称。以下示例显示如何配置此类bean：</p>
<pre><code class="language-xml"><span class="hljs-comment">&lt;!-- the factory bean, which contains a method called createInstance() --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"serviceLocator"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"examples.DefaultServiceLocator"</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- inject any dependencies required by this locator bean --&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

<span class="hljs-comment">&lt;!-- the bean to be created via the factory bean --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"clientService"</span>
    <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">"serviceLocator"</span>
    <span class="hljs-attr">factory-method</span>=<span class="hljs-string">"createClientServiceInstance"</span>/&gt;</span>
</code></pre>
<p>以下示例显示了相应的Java类:</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultServiceLocator</span> </span>{

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ClientService clientService = <span class="hljs-keyword">new</span> ClientServiceImpl();

    <span class="hljs-function"><span class="hljs-keyword">public</span> ClientService <span class="hljs-title">createClientServiceInstance</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> clientService;
    }
}
</code></pre>
<p>kotlin:</p>
<pre><code class="language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultServiceLocator</span> </span>{
    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> {
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> clientService = ClientServiceImpl()
    }
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createClientServiceInstance</span><span class="hljs-params">()</span></span>: ClientService {
        <span class="hljs-keyword">return</span> clientService
    }
}
</code></pre>
<p>一个工厂类也可以包含多个工厂方法，如以下示例所示:</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"serviceLocator"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"examples.DefaultServiceLocator"</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- inject any dependencies required by this locator bean --&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"clientService"</span>
    <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">"serviceLocator"</span>
    <span class="hljs-attr">factory-method</span>=<span class="hljs-string">"createClientServiceInstance"</span>/&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"accountService"</span>
    <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">"serviceLocator"</span>
    <span class="hljs-attr">factory-method</span>=<span class="hljs-string">"createAccountServiceInstance"</span>/&gt;</span>
</code></pre>
<p>以下示例显示了相应的Java类:</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultServiceLocator</span> </span>{

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ClientService clientService = <span class="hljs-keyword">new</span> ClientServiceImpl();

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> AccountService accountService = <span class="hljs-keyword">new</span> AccountServiceImpl();

    <span class="hljs-function"><span class="hljs-keyword">public</span> ClientService <span class="hljs-title">createClientServiceInstance</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> clientService;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> AccountService <span class="hljs-title">createAccountServiceInstance</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> accountService;
    }
}
</code></pre>
<p>kotlin:</p>
<pre><code class="language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultServiceLocator</span> </span>{
    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> {
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> clientService = ClientServiceImpl()
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> accountService = AccountServiceImpl()
    }

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createClientServiceInstance</span><span class="hljs-params">()</span></span>: ClientService {
        <span class="hljs-keyword">return</span> clientService
    }

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createAccountServiceInstance</span><span class="hljs-params">()</span></span>: AccountService {
        <span class="hljs-keyword">return</span> accountService
    }
}	
</code></pre>
<p>这种方法表明可以通过依赖注入（DI）来管理和配置工厂bean本身。请参阅详细信息中的<a href="#beans-factory-properties-detailed">依赖和配置详解</a>。</p>
<p>在Spring文档中，“factory bean”是指在Spring容器中配置并通过<a href="#beans-factory-class-instance-factory-method">实例</a> 或 <a href="#beans-factory-class-static-factory-method">静态工厂方法</a> 创建对象的bean。相比之下，FactoryBean（注意大小写）是指Spring特定的<a href="#beans-factory-extension-factorybean"><code>FactoryBean</code></a>。</p>
</div></section><footer class="footer-container"><div class="footer-body"><img src="/img/jcohy.png"/><div class="cols-container"><div class="col col-12"><p>jia_chao23@126.com</p><p>https://www.github.com/jiachao23</p></div><div class="col col-6"><dl><dt>文档</dt><dd><a href="/zh-cn/docs/springframework/demo.html" target="_self">Spring Framework</a></dd><dd><a href="/zh-cn/docs/springboot/demo.html" target="_self">SpringBoot</a></dd><dd><a href="/zh-cn/docs/microservices/demo.html" target="_self">Microservices</a></dd></dl></div><div class="col col-6"><dl><dt>资源</dt><dd><a href="/zh-cn/blog/index.html" target="_self">博客</a></dd><dd><a href="/zh-cn/open/index.html" target="_self">开源项目</a></dd></dl></div></div><div class="copyright"><span>Copyright © 2019 www.jcohy.com</span></div></div></footer></div></div>
	<script src="https://f.alicdn.com/react/15.4.1/react-with-addons.min.js"></script>
	<script src="https://f.alicdn.com/react/15.4.1/react-dom.min.js"></script>
	<script>
		window.rootPath = '';
  </script>
	<script src="/build/documentation.js"></script>
</body>
</html>

{
  "filename": "beans-basics.md",
  "__html": "<h1>Spring  Framework 中文文档</h1>\n<h3><a href=\"#beans-basics\"></a>1.2. 容器概述</h3>\n<p><code>org.springframework.context.ApplicationContext</code>是Spring IoC容器实现的代表，它负责实例化，配置和组装Bean。容器通过读取配置元数据获取有关实例化、配置和组装哪些对象的说明 。配置元数据可以使用XML、Java注解或Java代码来呈现。它允许你处理应用程序的对象与其他对象之间的互相依赖关系。</p>\n<p>Spring提供了<code>ApplicationContext</code>接口的几个实现。 在独立应用程序中，通常创建<a href=\"https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/context/support/ClassPathXmlApplicationContext.html\"><code>ClassPathXmlApplicationContext</code></a>或<a href=\"https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/context/support/FileSystemXmlApplicationContext.html\"><code>FileSystemXmlApplicationContext</code></a>的实例。虽然XML一直是定义配置元数据的传统格式， 但是您可以指定容器使用Java注解或编程的方式编写元数据格式，并通过提供少量的XML配置以声明对某些额外元数据的支持。</p>\n<p>在大多数应用场景中，不需要用户显式的编写代码来实例化IOC容器的一个或者多个实例。例如，在Web应用场景中，只需要在web.xml中添加大概8行简单的web描述样板就行了。（ <a href=\"#context-create\">便捷的ApplicationContext实例化Web应用程序</a>） 如果你使用的是基于Eclipse的<a href=\"https://spring.io/tools/sts\">Spring Tool Suite</a>开发环境，该样板配置只需点击几下鼠标或按几下键盘就能创建了。</p>\n<p>下图展示了Spring工作方式的高级视图，应用程序的类与元数据配置相互配合，这样，在<code>ApplicationContext</code>创建和初始化后，你立即拥有一个可配置的，可执行的系统或应用程序。</p>\n<p><img src=\"https://github.com/DocsHome/spring-docs/blob/master/pages/images/container-magic.png\" alt=\"container magic\"></p>\n<p>图 1. IOC容器</p>\n<p><a id=\"beans-factory-metadata\"></a></p>\n<h4><a href=\"#beans-factory-metadata\"></a>1.2.1. 配置元数据</h4>\n<p>如上图所示，Spring IOC容器使用元数据配置这种形式，这个配置元数据表示了应用开发人员告诉Spring容器以何种方式实例化、配置和组装应用程序中的对象。</p>\n<p>配置元数据通常以简单、直观的XML格式提供，本章的大部分内容都使用这种格式来说明Spring IoC容器的关键概念和特性。</p>\n<p>XML并不是配置元数据的唯一方式，Spring IoC容器本身是完全与元数据配置的实际格式分离的。现在，许多开发人员选择<a href=\"#beans-java\">基于Java的配置</a>来开发应用程序。</p>\n<p>更多其他格式的元数据见:</p>\n<ul>\n<li>\n<p><a href=\"#beans-annotation-config\">基于注解的配置</a>: Spring 2.5 支持基于注解的元数据配置.</p>\n</li>\n<li>\n<p><a href=\"#beans-java\">基于Java的配置</a>: 从 Spring 3.0开始, 由Spring JavaConfig项目提供的功能已经成为Spring核心框架的一部分。因此，你可以使用Java配置来代替XML配置定义外部bean 。要使用这些新功能，请参阅 <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Configuration.html\"><code>@Configuration</code></a>, <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Bean.html\"><code>@Bean</code></a>, <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Import.html\"><code>@Import</code></a>, 和 <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/DependsOn.html\"><code>@DependsOn</code></a> annotations.</p>\n</li>\n</ul>\n<p>Spring配置至少一个（通常不止一个）由容器来管理。基于XML的元数据配置将这些bean配置为<code>&lt;bean/&gt;</code>元素，并放置于<code>&lt;bean/&gt;</code>元素内部。 典型的Java配置是在使用<code>@Configuration</code>注解过的类中，在它的方法上使用<code>@Bean</code>注解。</p>\n<p>这些bean定义会对应到构成应用程序的实际对象。通常你会定义服务层对象，数据访问对象（DAOs），表示对象(如Struts <code>Action</code>的实例)，基础对象（如Hibernate 的<code>SessionFactories</code>, JMS <code>Queues</code>）。通常不会在容器中配置细粒度的域对象，但是，因为它的创建和加载通常是DAO和业务逻辑的任务。 但是，你可以使用Spring与AspectJ 集成独立于 IoC 容器来创建的对象，请参阅<a href=\"#aop-atconfigurable\">AspectJ在Spring中进行依赖关系注入域对象</a></p>\n<p>下面的示例显示了基于XML元数据配置的基本结构:</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-meta\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">beans</span> <span class=\"hljs-attr\">xmlns</span>=<span class=\"hljs-string\">\"http://www.springframework.org/schema/beans\"</span>\n    <span class=\"hljs-attr\">xmlns:xsi</span>=<span class=\"hljs-string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span>\n    <span class=\"hljs-attr\">xsi:schemaLocation</span>=<span class=\"hljs-string\">\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\"</span>&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">bean</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"...\"</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"...\"</span>&gt;</span>  (1) (2)\n        <span class=\"hljs-comment\">&lt;!-- collaborators and configuration for this bean go here --&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">bean</span>&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">bean</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"...\"</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"...\"</span>&gt;</span>\n        <span class=\"hljs-comment\">&lt;!-- collaborators and configuration for this bean go here --&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">bean</span>&gt;</span>\n\n    <span class=\"hljs-comment\">&lt;!-- more bean definitions go here --&gt;</span>\n\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">beans</span>&gt;</span>\n</code></pre>\n<p><strong>1</strong></p>\n<p><code>id</code> 属性是字符串 ，用来识别唯一的bean定义.</p>\n<p><strong>2</strong></p>\n<p><code>class</code> 属性定义了bean的类型，使用全类名.</p>\n<p><code>id</code>属性的值是指引用协作对象（在这个例子没有显示用于引用协作对象的XML）。请参阅<a href=\"#beans-dependencies\">依赖</a>获取更多信息</p>\n<p><a id=\"beans-factory-instantiation\"></a></p>\n<h4><a href=\"#beans-factory-instantiation\"></a>1.2.2. 实例化容器</h4>\n<p>提供给ApplicationContext构造函数的路径就是实际的资源字符串，使容器能从各种外部资源(如本地文件系统、Java类路径等)装载元数据配置。</p>\n<p>java:</p>\n<pre><code class=\"language-java\">    ApplicationContext context = <span class=\"hljs-keyword\">new</span> ClassPathXmlApplicationContext(<span class=\"hljs-string\">\"services.xml\"</span>, <span class=\"hljs-string\">\"daos.xml\"</span>);\n</code></pre>\n<p>kotlin:</p>\n<pre><code class=\"language-kotlin\">    <span class=\"hljs-keyword\">val</span> context = ClassPathXmlApplicationContext(<span class=\"hljs-string\">\"services.xml\"</span>, <span class=\"hljs-string\">\"daos.xml\"</span>);\n</code></pre>\n<p>当你了解Spring IoC容器，你可能想知道更多关于Spring的抽象资源（详细描述<a href=\"#resources\">资源</a>）它提供了一种方便的，由URI语法定义的位置读取InputStream描述的方式 ，资源路径被用于构建应用程序上下文<a href=\"#resources-app-ctx\">应用环境和资源路径</a></p>\n<p>下面的例子显示了服务层对象(<code>services.xml</code>)配置文件::</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-meta\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">beans</span> <span class=\"hljs-attr\">xmlns</span>=<span class=\"hljs-string\">\"http://www.springframework.org/schema/beans\"</span>\n    <span class=\"hljs-attr\">xmlns:xsi</span>=<span class=\"hljs-string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span>\n    <span class=\"hljs-attr\">xsi:schemaLocation</span>=<span class=\"hljs-string\">\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\"</span>&gt;</span>\n\n    <span class=\"hljs-comment\">&lt;!-- services --&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">bean</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"petStore\"</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"org.springframework.samples.jpetstore.services.PetStoreServiceImpl\"</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">property</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"accountDao\"</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"accountDao\"</span>/&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">property</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"itemDao\"</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"itemDao\"</span>/&gt;</span>\n        <span class=\"hljs-comment\">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">bean</span>&gt;</span>\n\n    <span class=\"hljs-comment\">&lt;!-- more bean definitions for services go here --&gt;</span>\n\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">beans</span>&gt;</span>\n</code></pre>\n<p>下面的示例显示了数据访问对象（<code>daos.xml</code>）配置文件:</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-meta\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">beans</span> <span class=\"hljs-attr\">xmlns</span>=<span class=\"hljs-string\">\"http://www.springframework.org/schema/beans\"</span>\n    <span class=\"hljs-attr\">xmlns:xsi</span>=<span class=\"hljs-string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span>\n    <span class=\"hljs-attr\">xsi:schemaLocation</span>=<span class=\"hljs-string\">\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\"</span>&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">bean</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"accountDao\"</span>\n        <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao\"</span>&gt;</span>\n        <span class=\"hljs-comment\">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">bean</span>&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">bean</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"itemDao\"</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"org.springframework.samples.jpetstore.dao.jpa.JpaItemDao\"</span>&gt;</span>\n        <span class=\"hljs-comment\">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">bean</span>&gt;</span>\n\n    <span class=\"hljs-comment\">&lt;!-- more bean definitions for data access objects go here --&gt;</span>\n\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">beans</span>&gt;</span>\n</code></pre>\n<p>在上面的例子中，服务层由PetStoreServiceImpl类，两个数据访问对象JpaAccountDao类和JpaItemDao类（基于JPA对象/关系映射标准）组成 property name元素是指JavaBean属性的名称，而ref元素引用另一个bean定义的名称。id和ref元素之间的这种联系表达了组合对象之间的相互依赖关系。有关对象间的依赖关系，请参阅<a href=\"#beans-dependencies\">依赖</a> .</p>\n<p><a id=\"beans-factory-xml-import\"></a></p>\n<h5><a href=\"#beans-factory-xml-import\"></a>组合基于XML的元数据配置</h5>\n<p>使用XML配置，可以让bean定义分布在多个XML文件上，这种方法直观优雅清晰明显。通常，每个单独的XML配置文件代表架构中的一个逻辑层或模块。</p>\n<p>你可以使用应用程序上下文构造函数从所有这些XML片段加载bean定义，这个构造函数可以输入多个资源位置，<a href=\"#beans-factory-instantiation\">如上一节所示</a>。 或者，使用<code>&lt;import/&gt;</code>元素也可以从另一个（或多个）文件加载bean定义。例如：</p>\n<pre><code>&lt;beans&gt;\n    &lt;import resource=&quot;services.xml&quot;/&gt;\n    &lt;import resource=&quot;resources/messageSource.xml&quot;/&gt;\n    &lt;import resource=&quot;/resources/themeSource.xml&quot;/&gt;\n\n    &lt;bean id=&quot;bean1&quot; class=&quot;...&quot;/&gt;\n    &lt;bean id=&quot;bean2&quot; class=&quot;...&quot;/&gt;\n&lt;/beans&gt;\n</code></pre>\n<p>上面的例子中，使用了3个文件：<code>services.xml</code>, <code>messageSource.xml</code>, 和 <code>themeSource.xml</code>来加载外部Bean的定义。 导入文件采用的都是相对路径，因此<code>services.xml</code>必须和导入文件位于同一目录或类路径中，而<code>messageSource.xml</code> 和 <code>themeSource.xml</code> 必须在导入文件的资源位置中。正如你所看到的，前面的斜线将会被忽略，但考虑到这些路径是相对的，最佳的使用是不用斜线的。 这个XML文件的内容都会被导入，包括顶级的 <code>&lt;beans/&gt;</code>元素，但必须遵循Spring Schema定义XML bean定义的规则 。</p>\n<p>这种相对路径的配置是可行的，但不推荐这样做，引用在使用相对于&quot;../&quot;路径的父目录文件中，这样做会对当前应用程序之外的文件产生依赖关系。 特别是对于<code>classpath:</code>: URLs(例如<code>classpath:../services.xml</code>)，不建议使用此引用，因为在该引用中，运行时解析过程选择“最近的”classpath根目录，然后查看其父目录。 类路径的变化或者选择了不正确的目录都会导致此配置不可用。</p>\n<p>您可以使用完全限定的资源位置而不是相对路径:例如，<code>file:C:/config/services.xml</code>或者<code>classpath:/config/services.xml</code>.。 但是，请注意，您正在将应用程序的配置与特定的绝对位置耦合。通常会选取间接的方式应对这种绝对路径，例如使用占位符“${…}”来解决对JVM系统属性的引用。</p>\n<p>import 是由bean命名空间本身提供的功能。在Spring提供的XML命名空间中，如“<code>context</code>”和“<code>util</code>”命名空间，可以用于对普通bean定义进行更高级的功能配置。</p>\n<p><a id=\"groovy-bean-definition-dsl\"></a></p>\n<h5><a href=\"#groovy-bean-definition-dsl\"></a>DSL定义Groovy Bean</h5>\n<p>作为从外部配置元数据的另一个示例，bean定义也可以使用Spring的Groovy DSL来定义。Grails框架有此配置实例，通常， 可以在具有以下结构的&quot;.groovy&quot;文件中配置bean定义。例如：</p>\n<pre><code class=\"language-groovy\">beans {\n    dataSource(BasicDataSource) {\n        driverClassName = <span class=\"hljs-string\">\"org.hsqldb.jdbcDriver\"</span>\n        url = <span class=\"hljs-string\">\"jdbc:hsqldb:mem:grailsDB\"</span>\n        username = <span class=\"hljs-string\">\"sa\"</span>\n        password = <span class=\"hljs-string\">\"\"</span>\n        settings = [<span class=\"hljs-string\">mynew:</span><span class=\"hljs-string\">\"setting\"</span>]\n    }\n    sessionFactory(SessionFactory) {\n        dataSource = dataSource\n    }\n    myService(MyService) {\n        nestedBean = { AnotherBean bean -&gt;\n            dataSource = dataSource\n        }\n    }\n}\n</code></pre>\n<p>这种配置风格在很大程度上等价于XML bean定义，甚至支持Spring的XML配置名称空间。它还允许通过<code>importBeans</code>指令导入XML bean定义文件。</p>\n<p><a id=\"beans-factory-client\"></a></p>\n<h4><a href=\"#beans-factory-client\"></a>1.2.3. 使用容器</h4>\n<p><code>ApplicationContext</code>是能够创建bean定义以及处理相互依赖关系的高级工厂接口，使用方法<code>T getBean(String name, Class&lt;T&gt; requiredType)</code>获取容器实例。</p>\n<p><code>ApplicationContext</code>可以读取bean定义并访问它们 如下 :</p>\n<p>java:</p>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">// create and configure beans</span>\nApplicationContext context = <span class=\"hljs-keyword\">new</span> ClassPathXmlApplicationContext(<span class=\"hljs-string\">\"services.xml\"</span>, <span class=\"hljs-string\">\"daos.xml\"</span>);\n\n<span class=\"hljs-comment\">// retrieve configured instance</span>\nPetStoreService service = context.getBean(<span class=\"hljs-string\">\"petStore\"</span>, PetStoreService<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n\n<span class=\"hljs-comment\">// use configured instance</span>\nList&lt;String&gt; userList = service.getUsernameList();\n</code></pre>\n<p>kotlin:</p>\n<pre><code class=\"language-kotlin\"><span class=\"hljs-keyword\">import</span> org.springframework.beans.factory.getBean\n\n<span class=\"hljs-comment\">// create and configure beans</span>\n<span class=\"hljs-keyword\">val</span> context = ClassPathXmlApplicationContext(<span class=\"hljs-string\">\"services.xml\"</span>, <span class=\"hljs-string\">\"daos.xml\"</span>)\n\n<span class=\"hljs-comment\">// retrieve configured instance</span>\n<span class=\"hljs-keyword\">val</span> service = context.getBean&lt;PetStoreService&gt;(<span class=\"hljs-string\">\"petStore\"</span>)\n\n<span class=\"hljs-comment\">// use configured instance</span>\n<span class=\"hljs-keyword\">var</span> userList = service.getUsernameList()\n</code></pre>\n<p>使用Groovy配置引导看起来非常相似，只是用到不同的上下文实现类：它是Groovy感知的（但也需理解XML bean定义） 如下:</p>\n<p>java:</p>\n<pre><code class=\"language-groovy\">ApplicationContext context = <span class=\"hljs-keyword\">new</span> GenericGroovyApplicationContext(<span class=\"hljs-string\">\"services.groovy\"</span>, <span class=\"hljs-string\">\"daos.groovy\"</span>);\n</code></pre>\n<p>kotlin:</p>\n<pre><code class=\"language-kotlin\"><span class=\"hljs-keyword\">val</span> context = GenericGroovyApplicationContext(<span class=\"hljs-string\">\"services.groovy\"</span>, <span class=\"hljs-string\">\"daos.groovy\"</span>)\n</code></pre>\n<p>最灵活的变体是<code>GenericApplicationContext</code>，例如读取XML文件的<code>XmlBeanDefinitionReader</code>。如下面的示例所示:</p>\n<p>java:</p>\n<pre><code class=\"language-java\">GenericApplicationContext context = <span class=\"hljs-keyword\">new</span> GenericApplicationContext();\n<span class=\"hljs-keyword\">new</span> XmlBeanDefinitionReader(context).loadBeanDefinitions(<span class=\"hljs-string\">\"services.xml\"</span>, <span class=\"hljs-string\">\"daos.xml\"</span>);\ncontext.refresh();\n</code></pre>\n<p>kotlin:</p>\n<pre><code class=\"language-kotlin\"><span class=\"hljs-keyword\">val</span> context = GenericApplicationContext()\nGroovyBeanDefinitionReader(context).loadBeanDefinitions(<span class=\"hljs-string\">\"services.groovy\"</span>, <span class=\"hljs-string\">\"daos.groovy\"</span>)\ncontext.refresh()\n</code></pre>\n<p>您还可以为Groovy文件使用<code>GroovyBeanDefinitionReader</code>，如下面的示例所示:</p>\n<pre><code class=\"language-groovy\">GenericApplicationContext context = <span class=\"hljs-keyword\">new</span> GenericApplicationContext();\n<span class=\"hljs-keyword\">new</span> GroovyBeanDefinitionReader(context).loadBeanDefinitions(<span class=\"hljs-string\">\"services.groovy\"</span>, <span class=\"hljs-string\">\"daos.groovy\"</span>);\ncontext.refresh();\n</code></pre>\n<p>这一类的读取可以在同一个 <code>ApplicationContext</code>上混合使用，也可以自动匹配，如果需要可以从不同的配置源读取bean定义。</p>\n<p>您可以使用 <code>getBean</code>来获取bean实例， <code>ApplicationContext</code>接口也可以使用其他的方法来获取bean。但是在理想情况下，应用程序代码永远不应该使用它们。 事实上，你的应用程序代码也不应该调用的<code>getBean()</code>方法，因此对Spring API没有依赖。例如，Spring与Web框架的集成为各种Web框架组件(如控制器和JSF管理bean） 提供了依赖项注入功能，从而允许开发者通过元数据声明对特定bean的依赖(例如，自动注解）。</p>\n",
  "link": "\\zh-cn\\docs\\springframework\\core\\container\\beans-basics.html",
  "meta": {
    "title": "容器概述",
    "keywords": "keywords: docs，jcohy-docs，spring,容器概述",
    "description": "Spring  Framework 中文文档 》 容器概述"
  }
}
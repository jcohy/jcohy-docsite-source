<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<meta name="keywords" content="keywords: docs，jcohy-docs，spring,抽象环境" />
	<meta name="description" content="Spring  Framework 中文文档 》 抽象环境" />
	<!-- 网页标签标题 -->
	<title>抽象环境</title>
	<link rel="shortcut icon" href="/img/jcohy.ico"/>
	<link rel="stylesheet" href="/build/documentation.css" />
</head>
<body>
	<div id="root"><div class="documentation-page" data-reactroot=""><header class="header-container header-container-normal"><div class="header-body"><a href="/zh-cn/index.html"><img class="logo" src="/img/jcohy_colorful.png"/></a><div class="search search-normal"><span class="icon-search"></span></div><span class="language-switch language-switch-normal">En</span><div class="header-menu"><img class="header-menu-toggle" src="/img/system/menu_gray.png"/><ul><li class="menu-item menu-item-normal"><a href="/zh-cn/index.html" target="_self">首页</a></li><li class="menu-item menu-item-normal menu-item-normal-active"><a href="/zh-cn/docs/Overview.html" target="_self">文档</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/blog/index.html" target="_self">博客</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/open/index.html" target="_self">开源项目</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/resource/index.html" target="_self">资源</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/community/index.html" target="_self">社区</a></li></ul></div></div></header><div class="bar"><div class="bar-body"><img src="/img/system/docs.png" class="front-img"/><span>文档</span><img src="/img/system/docs.png" class="back-img"/></div></div><section class="content-section"><div class="sidemenu"><div class="sidemenu-toggle"><img src="https://img.alicdn.com/tfs/TB1E6apXHGYBuNjy0FoXXciBFXa-200-200.png"/></div><ul><li class="menu-item menu-item-level-1"><span>概述</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/Overview.html" target="_self">概述</a></li></ul></li><li class="menu-item menu-item-level-1"><span>Spring Framework</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/springframework/README.html" target="_self">说明</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/springframework/SUMMARY.html" target="_self">摘要</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/springframework/overview/overview.html" target="_self">概述</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>核心组件<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/springframework/core/overview.html" target="_self">全部章节一览</a></li><li class="menu-item menu-item-level-3"><a target="_self">IOC容器</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a target="_self">测试</a></li></ul></li></ul></div><div class="doc-content markdown-body"><h1>Spring  Framework 中文文档</h1>
<h3><a href="#beans-environment"></a>1.13. 抽象环境</h3>
<p><a href="https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/core/env/Environment.html"><code>Environment</code></a>接口是集成在容器中的抽象，它模拟了应用程序环境的两个关键方面：<a href="#beans-definition-profiles">profiles</a> 和 <a href="#beans-property-source-abstraction">properties</a>。</p>
<p>profile配置是一个被命名的,bean定义的逻辑组,这些bean只有在给定的profile配置激活时才会注册到容器.无论是以XML还是通过注解定义,Bean都可以分配给配置文件 。<code>Environment</code>对象在profile中的角色是判断哪一个profile应该在当前激活和哪一个profile应该在默认情况下激活。</p>
<p>属性在几乎所有应用程序中都发挥着重要作用，可能源自各种源：属性文件，JVM系统属性，系统环境变量，JNDI，servlet上下文参数，ad-hoc属性对象，Map对象等。 与属性相关的<code>Environment</code>对象的作用是为用户提供方便的服务接口，用于配置属性源和从中解析属性。</p>
<p><a id="beans-definition-profiles"></a></p>
<h4><a href="#beans-definition-profiles"></a>1.13.1. Bean定义Profiles</h4>
<p>bean定义profiles是核心容器内的一种机制，该机制能在不同环境中注册不同的bean。“环境”这个词对不同的用户来说意味着不同的东西，这个功能可以帮助解决许多用例，包括：</p>
<ul>
<li>
<p>在QA或生产环境中，针对开发中的内存数据源而不是从JNDI查找相同的数据源。</p>
</li>
<li>
<p>开发期使用监控组件，当部署以后则关闭监控组件，使应用更高效</p>
</li>
<li>
<p>为用户各自注册自定义bean实现</p>
</li>
</ul>
<p>考虑<code>DataSource</code>的实际应用程序中的第一个用例。 在测试环境中，配置可能类似于以下内容：</p>
<pre><code class="language-java"><span class="hljs-meta">@Bean</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">dataSource</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> EmbeddedDatabaseBuilder()
        .setType(EmbeddedDatabaseType.HSQL)
        .addScript(<span class="hljs-string">"my-schema.sql"</span>)
        .addScript(<span class="hljs-string">"my-test-data.sql"</span>)
        .build();
}
</code></pre>
<pre><code class="language-kotlin"><span class="hljs-meta">@Bean</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dataSource</span><span class="hljs-params">()</span></span>: DataSource {
    <span class="hljs-keyword">return</span> EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.HSQL)
            .addScript(<span class="hljs-string">"my-schema.sql"</span>)
            .addScript(<span class="hljs-string">"my-test-data.sql"</span>)
            .build()
}
</code></pre>
<p>现在考虑如何将此应用程序部署到QA或生产环境中，假设应用程序的数据源已注册到生产应用程序服务器的JNDI目录。 我们的<code>dataSource</code> bean现在看起来如下：</p>
<pre><code class="language-java"><span class="hljs-meta">@Bean</span>(destroyMethod=<span class="hljs-string">""</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">dataSource</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{
    Context ctx = <span class="hljs-keyword">new</span> InitialContext();
    <span class="hljs-keyword">return</span> (DataSource) ctx.lookup(<span class="hljs-string">"java:comp/env/jdbc/datasource"</span>);
}
</code></pre>
<pre><code class="language-kotlin"><span class="hljs-meta">@Bean(destroyMethod = <span class="hljs-meta-string">""</span>)</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dataSource</span><span class="hljs-params">()</span></span>: DataSource {
    <span class="hljs-keyword">val</span> ctx = InitialContext()
    <span class="hljs-keyword">return</span> ctx.lookup(<span class="hljs-string">"java:comp/env/jdbc/datasource"</span>) <span class="hljs-keyword">as</span> DataSource
}
</code></pre>
<p>问题是如何根据当前环境在使用这两种变体之间切换。随着时间的推移，Spring用户已经设计了许多方法来完成这项工作，通常依赖于系统环境变量和包含<code>${placeholder}</code>标记的XML<code>&lt;import/&gt;</code>语句的组合， 这些标记根据值解析为正确的配置文件路径一个环境变量。 Bean定义profiles是核心容器功能，可为此问题提供解决方案。</p>
<p>概括一下上面的场景，环境决定bean定义,最后发现,我们需要在某些上下文环境中使用某些bean,在其他环境中则不用这些bean.或者说, 在场景A中注册一组bean定义,而在场景B中注册另外一组。先看看如何通过修改配置来完成此需求：</p>
<p><a id="beans-definition-profiles-java"></a></p>
<h5><a href="#beans-definition-profiles-java"></a>使用 <code>@Profile</code></h5>
<p><a href="https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/context/annotation/Profile.html"><code>@Profile</code></a>注解用于当一个或多个配置文件激活的时候,用来指定组件是否有资格注册。使用前面的示例，我们可以重写<code>dataSource</code>配置，如下所示：</p>
<pre><code class="language-java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@Profile</span>(<span class="hljs-string">"development"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StandaloneDataConfig</span> </span>{

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">dataSource</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.HSQL)
            .addScript(<span class="hljs-string">"classpath:com/bank/config/sql/schema.sql"</span>)
            .addScript(<span class="hljs-string">"classpath:com/bank/config/sql/test-data.sql"</span>)
            .build();
    }
}

<span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@Profile</span>(<span class="hljs-string">"production"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JndiDataConfig</span> </span>{

    <span class="hljs-meta">@Bean</span>(destroyMethod=<span class="hljs-string">""</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">dataSource</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{
        Context ctx = <span class="hljs-keyword">new</span> InitialContext();
        <span class="hljs-keyword">return</span> (DataSource) ctx.lookup(<span class="hljs-string">"java:comp/env/jdbc/datasource"</span>);
    }
}
</code></pre>
<pre><code class="language-kotlin"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@Profile(<span class="hljs-meta-string">"development"</span>)</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StandaloneDataConfig</span> </span>{

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dataSource</span><span class="hljs-params">()</span></span>: DataSource {
        <span class="hljs-keyword">return</span> EmbeddedDatabaseBuilder()
                .setType(EmbeddedDatabaseType.HSQL)
                .addScript(<span class="hljs-string">"classpath:com/bank/config/sql/schema.sql"</span>)
                .addScript(<span class="hljs-string">"classpath:com/bank/config/sql/test-data.sql"</span>)
                .build()
    }
}

<span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@Profile(<span class="hljs-meta-string">"production"</span>)</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JndiDataConfig</span> </span>{

    <span class="hljs-meta">@Bean(destroyMethod = <span class="hljs-meta-string">""</span>)</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dataSource</span><span class="hljs-params">()</span></span>: DataSource {
        <span class="hljs-keyword">val</span> ctx = InitialContext()
        <span class="hljs-keyword">return</span> ctx.lookup(<span class="hljs-string">"java:comp/env/jdbc/datasource"</span>) <span class="hljs-keyword">as</span> DataSource
    }
}
</code></pre>
<p>如前所述，使用<code>@Bean</code>方法，您通常选择使用Spring的<code>JndiTemplate</code>/<code>JndiLocatorDelegate</code>帮助程序或前面显示的 直接JNDI <code>InitialContext</code>用法但不使用<code>JndiObjectFactoryBean</code>变量来使用编程JNDI查找，这会强制您将返回类型声明为 <code>FactoryBean</code>类型。 As mentioned earlier, with <code>@Bean</code> methods, you typically choose to use programmatic JNDI lookups, by using either Spring’s <code>JndiTemplate</code>/<code>JndiLocatorDelegate</code> helpers or the straight JNDI <code>InitialContext</code> usage shown earlier but not the <code>JndiObjectFactoryBean</code> variant, which would force you to declare the return type as the <code>FactoryBean</code> type.</p>
<p>profile字符串可以包含简单的profile名称（例如，<code>production</code>）或profile表达式。 profile表达式允许表达更复杂的概要逻辑（例如，<code>production &amp; us-east</code>）。 profile表达式支持以下运算符：</p>
<ul>
<li>
<p><code>!</code>: A logical “not” of the profile</p>
</li>
<li>
<p><code>&amp;</code>: A logical “and” of the profiles</p>
</li>
<li>
<p><code>|</code>: A logical “or” of the profiles</p>
</li>
</ul>
<p>你不能不使用括号而混合 <code>&amp;</code> 和 <code>|</code> 。 例如，<code>production &amp; us-east | eu-central</code>不是一个有效的表达。 它必须表示为 <code>production &amp; (us-east | eu-central)</code>.。</p>
<p>您可以将<code>@Profile</code>用作<a href="#beans-meta-annotations">元注解</a>，以创建自定义组合注解。 以下示例定义了一个自定义<code>@Production</code>注解，您可以将其用作<code>@Profile(&quot;production&quot;)</code>的替代品：</p>
<pre><code class="language-java"><span class="hljs-meta">@Target</span>(ElementType.TYPE)
<span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)
<span class="hljs-meta">@Profile</span>(<span class="hljs-string">"production"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Production {
}
</code></pre>
<pre><code class="language-kotlin"><span class="hljs-meta">@Target(AnnotationTarget.TYPE)</span>
<span class="hljs-meta">@Retention(AnnotationRetention.RUNTIME)</span>
<span class="hljs-meta">@Profile(<span class="hljs-meta-string">"production"</span>)</span>
<span class="hljs-keyword">annotation</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Production</span></span>
</code></pre>
<p>如果<code>@Configuration</code>类标有 <code>@Profile</code>,类中所有<code>@Bean</code>和<code>@Import</code>注解相关的类都将被忽略,除非该profile被激活。 如果一个<code>@Component</code>或<code>@Configuration</code>类被标记为<code>@Profile({&quot;p1&quot;, &quot;p2&quot;})</code>。那么除非profile 'p1' or 'p2' 已被激活。 否则该类将不会注册/处理。如果给定的配置文件以NOT运算符(<code>!</code>)为前缀，如果配置文件为not active，则注册的元素将被注册。 例如，给定<code>@Profile({&quot;p1&quot;, &quot;!p2&quot;})</code>，如果配置文件“p1”处于活动状态或配置文件“p2”未激活，则会进行注册。</p>
<p><code>@Profile</code>也能注解方法，用于配置一个配置类中的指定bean。如以下示例所示：</p>
<pre><code class="language-java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>{

    <span class="hljs-meta">@Bean</span>(<span class="hljs-string">"dataSource"</span>)
    <span class="hljs-meta">@Profile</span>(<span class="hljs-string">"development"</span>) (<span class="hljs-number">1</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">standaloneDataSource</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.HSQL)
            .addScript(<span class="hljs-string">"classpath:com/bank/config/sql/schema.sql"</span>)
            .addScript(<span class="hljs-string">"classpath:com/bank/config/sql/test-data.sql"</span>)
            .build();
    }

    <span class="hljs-meta">@Bean</span>(<span class="hljs-string">"dataSource"</span>)
    <span class="hljs-meta">@Profile</span>(<span class="hljs-string">"production"</span>) (<span class="hljs-number">2</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">jndiDataSource</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{
        Context ctx = <span class="hljs-keyword">new</span> InitialContext();
        <span class="hljs-keyword">return</span> (DataSource) ctx.lookup(<span class="hljs-string">"java:comp/env/jdbc/datasource"</span>);
    }
}
</code></pre>
<pre><code class="language-kotlin"><span class="hljs-meta">@Configuration</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>{

    <span class="hljs-meta">@Bean(<span class="hljs-meta-string">"dataSource"</span>)</span>
    <span class="hljs-meta">@Profile(<span class="hljs-meta-string">"development"</span>)</span> 
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">standaloneDataSource</span><span class="hljs-params">()</span></span>: DataSource {
        <span class="hljs-keyword">return</span> EmbeddedDatabaseBuilder()
                .setType(EmbeddedDatabaseType.HSQL)
                .addScript(<span class="hljs-string">"classpath:com/bank/config/sql/schema.sql"</span>)
                .addScript(<span class="hljs-string">"classpath:com/bank/config/sql/test-data.sql"</span>)
                .build()
    }

    <span class="hljs-meta">@Bean(<span class="hljs-meta-string">"dataSource"</span>)</span>
    <span class="hljs-meta">@Profile(<span class="hljs-meta-string">"production"</span>)</span> 
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">jndiDataSource</span><span class="hljs-params">()</span></span> =
        InitialContext().lookup(<span class="hljs-string">"java:comp/env/jdbc/datasource"</span>) <span class="hljs-keyword">as</span> DataSource
}
</code></pre>
<p><strong>1</strong>、<code>standaloneDataSource</code> 方法仅在 <code>development</code> 环境可用.</p>
<p><strong>2</strong>、<code>jndiDataSource</code>方法仅在 <code>production</code> 环境可用.</p>
<p>在<code>@Bean</code> 方法上还添加有<code>@Profile</code>注解,可能会应用在特殊情况。在相同Java方法名称的重载<code>@Bean</code>方法(类似于构造函数重载）的情况下， 需要在所有重载方法上一致声明<code>@Profile</code>条件，如果条件不一致，则只有重载方法中第一个声明的条件才重要。因此，<code>@Profile</code>不能用于选择具有特定参数签名的重载方法， 所有工厂方法对相同的bean在Spring构造器中的解析算法在创建时是相同的。</p>
<p>如果想定义具有不同配置文件条件的备用bean，请使用不同的Java方法名称，通过<code>@Bean</code>名称属性指向相同的bean名称。如上例所示。 如果参数签名都是相同的（例如，所有的变体都是无参的工厂方法），这是安排有效Java类放在首要位置的唯一方法（因为只有一个 特定名称和参数签名的方法）。</p>
<p><a id="beans-definition-profiles-xml"></a></p>
<h5><a href="#beans-definition-profiles-xml"></a>XML bean定义profiles</h5>
<p>XML中的<code>&lt;beans&gt;</code> 元素有一个<code>profile</code> 属性,我们之前的示例配置可以在两个XML文件中重写，如下所示：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">profile</span>=<span class="hljs-string">"development"</span>
    <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span>
    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="hljs-attr">xmlns:jdbc</span>=<span class="hljs-string">"http://www.springframework.org/schema/jdbc"</span>
    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"..."</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">jdbc:embedded-database</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"dataSource"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">jdbc:script</span> <span class="hljs-attr">location</span>=<span class="hljs-string">"classpath:com/bank/config/sql/schema.sql"</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">jdbc:script</span> <span class="hljs-attr">location</span>=<span class="hljs-string">"classpath:com/bank/config/sql/test-data.sql"</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">jdbc:embedded-database</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">profile</span>=<span class="hljs-string">"production"</span>
    <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span>
    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="hljs-attr">xmlns:jee</span>=<span class="hljs-string">"http://www.springframework.org/schema/jee"</span>
    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"..."</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">jee:jndi-lookup</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"dataSource"</span> <span class="hljs-attr">jndi-name</span>=<span class="hljs-string">"java:comp/env/jdbc/datasource"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span>
</code></pre>
<p>也可以不用分开2个文件，在同一个XML中配置2个<code>&lt;beans/&gt;</code>，<code>&lt;beans/&gt;</code>元素也有profile属性。如以下示例所示：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span>
    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="hljs-attr">xmlns:jdbc</span>=<span class="hljs-string">"http://www.springframework.org/schema/jdbc"</span>
    <span class="hljs-attr">xmlns:jee</span>=<span class="hljs-string">"http://www.springframework.org/schema/jee"</span>
    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"..."</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- other bean definitions --&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">profile</span>=<span class="hljs-string">"development"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">jdbc:embedded-database</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"dataSource"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">jdbc:script</span> <span class="hljs-attr">location</span>=<span class="hljs-string">"classpath:com/bank/config/sql/schema.sql"</span>/&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">jdbc:script</span> <span class="hljs-attr">location</span>=<span class="hljs-string">"classpath:com/bank/config/sql/test-data.sql"</span>/&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">jdbc:embedded-database</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">profile</span>=<span class="hljs-string">"production"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">jee:jndi-lookup</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"dataSource"</span> <span class="hljs-attr">jndi-name</span>=<span class="hljs-string">"java:comp/env/jdbc/datasource"</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span>
</code></pre>
<p><code>spring-bean.xsd</code> 强制允许将profile元素定义在文件的最后面，这有助于在XML文件中提供灵活的方式而又不引起混乱。</p>
<p>对应XML不支持前面描述的profile表达式。 但是，有可能通过使用<code>!</code> 来否定一个profile表达式。 也可以通过嵌套profiles来应用“and”，如以下示例所示：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span>
    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="hljs-attr">xmlns:jdbc</span>=<span class="hljs-string">"http://www.springframework.org/schema/jdbc"</span>
    <span class="hljs-attr">xmlns:jee</span>=<span class="hljs-string">"http://www.springframework.org/schema/jee"</span>
    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"..."</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- other bean definitions --&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">profile</span>=<span class="hljs-string">"production"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">profile</span>=<span class="hljs-string">"us-east"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">jee:jndi-lookup</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"dataSource"</span> <span class="hljs-attr">jndi-name</span>=<span class="hljs-string">"java:comp/env/jdbc/datasource"</span>/&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span>
</code></pre>
<p>在前面的示例中，如果<code>production</code> 和<code>us-east</code> profiles都处于活动状态，则会暴露<code>dataSource</code> bean。</p>
<p><a id="beans-definition-profiles-enable"></a></p>
<h5><a href="#beans-definition-profiles-enable"></a>启用profile</h5>
<p>现在已经更新了配置,但仍然需要指定要激活哪个配置文件, 如果我们现在开始我们的示例应用程序， 我们会看到抛出<code>NoSuchBeanDefinitionException</code>，因为容器找不到名为<code>dataSource</code>的Spring bean。</p>
<p>激活配置文件可以通过多种方式完成，但最直接的方法是以编程方式对可通过<code>ApplicationContext</code>提供的<code>Environment</code> API进行操作。 以下示例显示了如何执行此操作：</p>
<pre><code class="language-java">AnnotationConfigApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext();
ctx.getEnvironment().setActiveProfiles(<span class="hljs-string">"development"</span>);
ctx.register(SomeConfig<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">StandaloneDataConfig</span>.<span class="hljs-title">class</span>, <span class="hljs-title">JndiDataConfig</span>.<span class="hljs-title">class</span>)</span>;
ctx.refresh();
</code></pre>
<pre><code class="language-kotlin"><span class="hljs-keyword">val</span> ctx = AnnotationConfigApplicationContext().apply {
    environment.setActiveProfiles(<span class="hljs-string">"development"</span>)
    register(SomeConfig::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>, <span class="hljs-type">StandaloneDataConfig::class.java</span>, <span class="hljs-type">JndiDataConfig::class.java)</span></span>
    refresh()
}
</code></pre>
<p>此外,配置文件也可以通过<code>spring.profiles.active</code>属性声明式性地激活,可以通过系统环境变量，JVM系统属性，<code>web.xml</code>中的Servlet上下文参数指定， 甚至作为JNDI中的一个条目设置（<a href="#beans-property-source-abstraction"><code>PropertySource</code> 抽象</a>）。在集成测试中，可以通过 <code>spring-test</code>模块中的<code>@ActiveProfiles</code>注解来声明活动配置文件(参见使用<a href="https://github.com/DocsHome/spring-docs/blob/master/pages/test/testing.mdl#testcontext-ctx-management-env-profiles">环境配置文件的上下文配置</a>)</p>
<p>配置文件不是“二选一”的。开发者可以一次激活多个配置文件。使用编程方式，您可以为<code>setActiveProfiles()</code>方法提供多个配置文件名称，该方法接受 <code>String…</code>varargs。 以下示例激活多个配置文件：</p>
<pre><code class="language-java">ctx.getEnvironment().setActiveProfiles(<span class="hljs-string">"profile1"</span>, <span class="hljs-string">"profile2"</span>);
</code></pre>
<pre><code class="language-kotlin">ctx.getEnvironment().setActiveProfiles(<span class="hljs-string">"profile1"</span>, <span class="hljs-string">"profile2"</span>)
</code></pre>
<p>声明性地，<code>spring.profiles.active</code>可以接受以逗号分隔的profile名列表，如以下示例所示：</p>
<pre><code class="language-java">-Dspring.profiles.active=<span class="hljs-string">"profile1,profile2"</span>
</code></pre>
<p><a id="beans-definition-profiles-default"></a></p>
<h5><a href="#beans-definition-profiles-default"></a>默认 Profile</h5>
<p>default配置文件表示默认开启的profile配置。考虑以下配置:</p>
<pre><code class="language-java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@Profile</span>(<span class="hljs-string">"default"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultDataConfig</span> </span>{

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">dataSource</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.HSQL)
            .addScript(<span class="hljs-string">"classpath:com/bank/config/sql/schema.sql"</span>)
            .build();
    }
}
</code></pre>
<pre><code class="language-kotlin"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@Profile(<span class="hljs-meta-string">"default"</span>)</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultDataConfig</span> </span>{

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dataSource</span><span class="hljs-params">()</span></span>: DataSource {
        <span class="hljs-keyword">return</span> EmbeddedDatabaseBuilder()
                .setType(EmbeddedDatabaseType.HSQL)
                .addScript(<span class="hljs-string">"classpath:com/bank/config/sql/schema.sql"</span>)
                .build()
    }
}
</code></pre>
<p>如果没有配置文件激活，上面的<code>dataSource</code>就会被创建。这提供了一种默认的方式，如果有任何一个配置文件启用，default配置就不会生效。</p>
<p>默认配置文件的名字(default）可以通过<code>Environment</code>的<code>setDefaultProfiles()</code>方法或者<code>spring.profiles.default</code>属性修改。</p>
<p><a id="beans-property-source-abstraction"></a></p>
<h4><a href="#beans-property-source-abstraction"></a>1.13.2. <code>PropertySource</code> 抽象</h4>
<p>Spring的<code>Environment</code>抽象提供用于一系列的propertysources属性配置文件的搜索操作.请考虑以下列表：</p>
<pre><code class="language-java">ApplicationContext ctx = <span class="hljs-keyword">new</span> GenericApplicationContext();
Environment env = ctx.getEnvironment();
<span class="hljs-keyword">boolean</span> containsMyProperty = env.containsProperty(<span class="hljs-string">"my-property"</span>);
System.out.println(<span class="hljs-string">"Does my environment contain the 'my-property' property? "</span> + containsMyProperty);
</code></pre>
<pre><code class="language-kotlin"><span class="hljs-keyword">val</span> ctx = GenericApplicationContext()
<span class="hljs-keyword">val</span> env = ctx.environment
<span class="hljs-keyword">val</span> containsMyProperty = env.containsProperty(<span class="hljs-string">"my-property"</span>)
println(<span class="hljs-string">"Does my environment contain the 'my-property' property? <span class="hljs-variable">$containsMyProperty</span>"</span>)
</code></pre>
<p>在上面的代码段中,一个高级别的方法用于访问Spring是否为当前环境定义了<code>my-property</code> 属性。为了回答这个问题，<code>Environment</code>对象对一组PropertySource对象进行搜索。 <a href="https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/core/env/PropertySource.html"><code>PropertySource</code></a>是对任何键值对的简单抽象，Spring的<a href="https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/core/env/StandardEnvironment.html"><code>StandardEnvironment</code></a>配置有两个<code>PropertySource</code>对象 ，一个表示JVM系统属性(<code>System.getProperties()</code>),一个表示系统环境变量(<code>System.getenv()</code>)。</p>
<p>这些默认property源位于<code>StandardEnvironment</code>中,用于独立应用程序。<a href="https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/web/context/support/StandardServletEnvironment.html"><code>StandardServletEnvironment</code></a>用默认的property配置源填充。 默认配置源包括Servlet配置和Servlet上下文参数，它可以选择启用<a href="https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/jndi/JndiPropertySource.html"><code>JndiPropertySource</code></a>。有关详细信息，请参阅它的javadocs</p>
<p>具体地说，当您使用<code>StandardEnvironment</code>时，如果在运行时存在<code>my-property</code>系统属性或<code>my-propertyi</code>环境变量，则对 <code>env.containsProperty(&quot;my-property&quot;)</code>的调用将返回true。</p>
<p>执行的搜索是分层的。默认情况下，系统属性优先于环境变量，因此如果在调用<code>env.getProperty(&quot;my-property&quot;)</code>期间碰巧在两个位置都设置了<code>my-property</code>属性， 系统属性值返回优先于环境变量。 请注意，属性值未合并，而是由前面的条目完全覆盖。</p>
<p>对于常见的 <code>StandardServletEnvironment</code>，完整层次结构如下，最高优先级条目位于顶部：</p>
<ol>
<li>
<p>ServletConfig参数（如果适用 - 例如，在DispatcherServlet上下文的情况下）</p>
</li>
<li>
<p>ServletContext参数（web.xml context-param条目）</p>
</li>
<li>
<p>JNDI环境变量（<code>java:comp/env/</code>entries）</p>
</li>
<li>
<p>JVM系统属性（<code>-D</code>命令行参数）</p>
</li>
<li>
<p>JVM系统环境（操作系统环境变量）</p>
</li>
</ol>
<p>最重要的是,整个机制都是可配置的。也许开发者需要一个自定义的properties源，并将该源整合到这个检索层级中。为此，请实现并实例化您自己的<code>PropertySource</code>，并将其添加到当前<code>Environment</code>的<code>PropertySource</code>集合中。 以下示例显示了如何执行此操作：</p>
<pre><code class="language-java">ConfigurableApplicationContext ctx = <span class="hljs-keyword">new</span> GenericApplicationContext();
MutablePropertySources sources = ctx.getEnvironment().getPropertySources();
sources.addFirst(<span class="hljs-keyword">new</span> MyPropertySource());
</code></pre>
<pre><code class="language-kotlin"><span class="hljs-keyword">val</span> ctx = GenericApplicationContext()
<span class="hljs-keyword">val</span> sources = ctx.environment.propertySources
sources.addFirst(MyPropertySource())
</code></pre>
<p>在上面的代码中， <code>MyPropertySource</code>在搜索中添加了最高优先级。如果它包含<code>my-property</code>属性，则会检测并返回该属性， 优先于其他 <code>PropertySource</code>中的任何<code>my-property</code>属性。 <a href="https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/core/env/MutablePropertySources.html"><code>MutablePropertySources</code></a> API公开了许多方法，允许你显式操作property属性源。</p>
<p><a id="beans-using-propertysource"></a></p>
<h4><a href="#beans-using-propertysource"></a>1.13.3. 使用 <code>@PropertySource</code></h4>
<p><a href="https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/context/annotation/PropertySource.html"><code>@PropertySource</code></a> 注解提供了便捷的方式，用于增加<code>PropertySource</code>到Spring的 <code>Environment</code>中。</p>
<p>给定一个名为<code>app.properties</code>的文件，其中包含键值对<code>testbean.name=myTestBean</code>， 以下<code>@Configuration</code>类使用<code>@PropertySource</code>，以便调用<code>testBean.getName()</code> 返回<code>myTestBean</code>：</p>
<pre><code class="language-java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@PropertySource</span>(<span class="hljs-string">"classpath:/com/myco/app.properties"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>{

    <span class="hljs-meta">@Autowired</span>
    Environment env;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> TestBean <span class="hljs-title">testBean</span><span class="hljs-params">()</span> </span>{
        TestBean testBean = <span class="hljs-keyword">new</span> TestBean();
        testBean.setName(env.getProperty(<span class="hljs-string">"testbean.name"</span>));
        <span class="hljs-keyword">return</span> testBean;
    }
}
</code></pre>
<pre><code class="language-kotlin"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@PropertySource(<span class="hljs-meta-string">"classpath:/com/myco/app.properties"</span>)</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>{

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> env: Environment

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">testBean</span><span class="hljs-params">()</span></span> = TestBean().apply {
        name = env.getProperty(<span class="hljs-string">"testbean.name"</span>)!!
    }
}
</code></pre>
<p>任何的存在于<code>@PropertySource</code>中的<code>${…}</code>占位符，将会被解析为定义在环境中的属性配置文件中的属性值。 如以下示例所示：</p>
<pre><code class="language-java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@PropertySource</span>(<span class="hljs-string">"classpath:/com/${my.placeholder:default/path}/app.properties"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>{

    <span class="hljs-meta">@Autowired</span>
    Environment env;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> TestBean <span class="hljs-title">testBean</span><span class="hljs-params">()</span> </span>{
        TestBean testBean = <span class="hljs-keyword">new</span> TestBean();
        testBean.setName(env.getProperty(<span class="hljs-string">"testbean.name"</span>));
        <span class="hljs-keyword">return</span> testBean;
    }
}
</code></pre>
<pre><code class="language-kotlin"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@PropertySource(<span class="hljs-meta-string">"classpath:/com/\${my.placeholder:default/path}/app.properties"</span>)</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>{

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> env: Environment

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">testBean</span><span class="hljs-params">()</span></span> = TestBean().apply {
        name = env.getProperty(<span class="hljs-string">"testbean.name"</span>)!!
    }
}
</code></pre>
<p>假设<code>my.placeholder</code>存在于已注册的其中一个属性源中（例如，系统属性或环境变量），则占位符将解析为相应的值。 如果不是，则<code>default/path</code>用作默认值。 如果未指定默认值且无法解析属性，则抛出<code>IllegalArgumentException</code>。</p>
<p>根据Java 8惯例，<code>@PropertySource</code>注解是可重复的。 但是，所有这些<code>@PropertySource</code>注解都需要在同一级别声明，可以直接在配置类上声明， 也可以在同一自定义注解中作为元注解声明。 不建议混合直接注解和元注解，因为直接注解有效地覆盖了元注解。</p>
<p><a id="beans-placeholder-resolution-in-statements"></a></p>
<h4><a href="#beans-placeholder-resolution-in-statements"></a>1.13.4. 在声明中的占位符</h4>
<p>之前，元素中占位符的值只能针对JVM系统属性或环境变量进行解析。现在已经打破了这种情况。因为环境抽象集成在整个容器中，所以很容易通过它来对占位符进行解析. 这意味着开发者可以以任何喜欢的方式来配置这个解析过程，可以改变是优先查找系统properties或者是有限查找环境变量，或者删除它们；增加自定义property源，使之成为更合适的配置</p>
<p>具体而言，只要在<code>Environment</code>中可用，无论<code>customer</code>属性在何处定义，以下语句都可以工作：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">"com/bank/service/${customer}-config.xml"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span>
</code></pre>
</div></section><footer class="footer-container"><div class="footer-body"><img src="/img/jcohy.png"/><div class="cols-container"><div class="col col-12"><p>jia_chao23@126.com</p><p>https://www.github.com/jiachao23</p></div><div class="col col-6"><dl><dt>文档</dt><dd><a href="/zh-cn/docs/springframework/demo.html" target="_self">Spring Framework</a></dd><dd><a href="/zh-cn/docs/springboot/demo.html" target="_self">SpringBoot</a></dd><dd><a href="/zh-cn/docs/microservices/demo.html" target="_self">Microservices</a></dd></dl></div><div class="col col-6"><dl><dt>资源</dt><dd><a href="/zh-cn/blog/index.html" target="_self">博客</a></dd><dd><a href="/zh-cn/open/index.html" target="_self">开源项目</a></dd></dl></div></div><div class="copyright"><span>Copyright © 2019 www.jcohy.com</span></div></div></footer></div></div>
	<script src="https://f.alicdn.com/react/15.4.1/react-with-addons.min.js"></script>
	<script src="https://f.alicdn.com/react/15.4.1/react-dom.min.js"></script>
	<script>
		window.rootPath = '';
  </script>
	<script src="/build/documentation.js"></script>
</body>
</html>

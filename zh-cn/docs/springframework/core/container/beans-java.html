<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<meta name="keywords" content="keywords: docs，jcohy-docs，spring,基于Java的容器配置" />
	<meta name="description" content="Spring  Framework 中文文档 》 基于Java的容器配置" />
	<!-- 网页标签标题 -->
	<title>基于Java的容器配置</title>
	<link rel="shortcut icon" href="/img/jcohy.ico"/>
	<link rel="stylesheet" href="/build/documentation.css" />
</head>
<body>
	<div id="root"><div class="documentation-page" data-reactroot=""><header class="header-container header-container-normal"><div class="header-body"><a href="/zh-cn/index.html"><img class="logo" src="/img/jcohy_colorful.png"/></a><div class="search search-normal"><span class="icon-search"></span></div><span class="language-switch language-switch-normal">En</span><div class="header-menu"><img class="header-menu-toggle" src="/img/system/menu_gray.png"/><ul><li class="menu-item menu-item-normal"><a href="/zh-cn/index.html" target="_self">首页</a></li><li class="menu-item menu-item-normal menu-item-normal-active"><a href="/zh-cn/docs/Overview.html" target="_self">文档</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/blog/index.html" target="_self">博客</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/open/index.html" target="_self">开源项目</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/resource/index.html" target="_self">资源</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/community/index.html" target="_self">社区</a></li></ul></div></div></header><div class="bar"><div class="bar-body"><img src="/img/system/docs.png" class="front-img"/><span>文档</span><img src="/img/system/docs.png" class="back-img"/></div></div><section class="content-section"><div class="sidemenu"><div class="sidemenu-toggle"><img src="https://img.alicdn.com/tfs/TB1E6apXHGYBuNjy0FoXXciBFXa-200-200.png"/></div><ul><li class="menu-item menu-item-level-1"><span>概述</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/Overview.html" target="_self">概述</a></li></ul></li><li class="menu-item menu-item-level-1"><span>Spring Framework</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/springframework/README.html" target="_self">说明</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/springframework/SUMMARY.html" target="_self">摘要</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/springframework/overview/overview.html" target="_self">概述</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>核心组件<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/springframework/core/overview.html" target="_self">全部章节一览</a></li><li class="menu-item menu-item-level-3"><a target="_self">IOC容器</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a target="_self">测试</a></li></ul></li></ul></div><div class="doc-content markdown-body"><h1>Spring  Framework 中文文档</h1>
<h3><a href="#beans-java"></a>1.12. 基于Java的容器配置</h3>
<p>本节介绍如何在Java代码中使用注解来配置Spring容器。 它包括以下主题：:</p>
<ul>
<li>
<p><a href="#beans-java-basic-concepts">基本概念: <code>@Bean</code> 和 <code>@Configuration</code></a></p>
</li>
<li>
<p><a href="#beans-java-instantiating-container">使用<code>AnnotationConfigApplicationContext</code>实例化Spring容器</a></p>
</li>
<li>
<p><a href="#beans-java-bean-annotation">使用<code>@Bean</code>注解</a></p>
</li>
<li>
<p><a href="#beans-java-configuration-annotation">使用<code>@Configuration</code>注解</a></p>
</li>
<li>
<p><a href="#beans-java-composing-configuration-classes">编写基于Java的配置</a></p>
</li>
<li>
<p><a href="#beans-definition-profiles">定义Bean配置文件</a></p>
</li>
<li>
<p><a href="#beans-property-source-abstraction"><code>PropertySource</code> 抽象</a></p>
</li>
<li>
<p><a href="#beans-using-propertysource">使用 <code>@PropertySource</code></a></p>
</li>
<li>
<p><a href="#beans-placeholder-resolution-in-statements">声明中的占位符</a></p>
</li>
</ul>
<p><a id="beans-java-basic-concepts"></a></p>
<h4><a href="#beans-java-basic-concepts"></a>1.12.1. 基本概念: <code>@Bean</code> 和 <code>@Configuration</code></h4>
<p>Spring新的基于Java配置的核心内容是<code>@Configuration</code>注解的类和<code>@Bean</code>注解的方法。</p>
<p><code>@Bean</code>注解用于表明方法的实例化，、配置和初始化都是由Spring IoC容器管理的新对象，对于那些熟悉Spring的<code>&lt;beans/&gt;</code>XML配置的人来说， <code>@Bean</code>注解扮演的角色与<code>&lt;beans/&gt;</code>元素相同。开发者可以在任意的Spring <code>@Component</code>中使用<code>@Bean</code>注解方法 ，但大多数情况下，<code>@Bean</code>是配合<code>@Configuration</code>使用的。</p>
<p>使用<code>@Configuration</code>注解类时，这个类的目的就是作为bean定义的地方。此外，<code>@Configuration</code>类允许通过调用同一个类中的其他<code>@Bean</code>方法来定义bean间依赖关系。 最简单的<code>@Configuration</code>类如下所示：</p>
<pre><code class="language-java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>{

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> MyService <span class="hljs-title">myService</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyServiceImpl();
    }
}
</code></pre>
<p>kotlin:</p>
<pre><code class="language-kotlin"><span class="hljs-meta">@Configuration</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>{

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">myService</span><span class="hljs-params">()</span></span>: MyService {
        <span class="hljs-keyword">return</span> MyServiceImpl()
    }
}
</code></pre>
<p>前面的<code>AppConfig</code>类等效于以下Spring <code>&lt;beans/&gt;</code>XML：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"myService"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.acme.services.MyServiceImpl"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span>
</code></pre>
<p>完整的@Configuration模式对比“lite”模式的@Bean?</p>
<p>当<code>@Bean</code>方法在没有用 <code>@Configuration</code>注解的类中声明时，它们将会被称为“lite”的模式处理。例如，<code>@Component</code>中声明的bean方法或者一个普通的旧类中的bean方法将被视为 “lite”的。包含类的主要目的不同，而<code>@Bean</code>方法在这里是一种额外的好处。。例如，服务组件可以通过在每个适用的组件类上使用额外的 <code>@Bean</code>方法将管理视图公开给容器。 在这种情况下，<code>@Bean</code>方法是一种通用的工厂方法机制。</p>
<p>与完整的 <code>@Configuration</code>不同，lite的<code>@Bean</code>方法不能声明bean之间的依赖关系。 相反，它们对其包含组件的内部状态进行操作，并且可以有选择的对它们可能声明的参数进行操作。因此，这样的<code>@Bean</code>注解的方法不应该调用其他<code>@Bean</code>注解的方法。 每个这样的方法实际上只是特定bean引用的工厂方法，没有任何特殊的运行时语义。不经过CGLIB处理，所以在类设计方面没有限制（即，包含类可能是最终的）。</p>
<p>在常见的场景中，<code>@Bean</code>方法将在<code>@Configuration</code>类中声明，确保始终使用“full”模式，这将防止相同的<code>@Bean</code>方法被意外地多次调用，这有助于减少在 “lite”模式下操作时难以跟踪的细微错误。</p>
<p><code>@Bean</code>和<code>@Configuration</code>注解将在下面的章节深入讨论，首先，我们将介绍使用基于Java代码的配置来创建Spring容器的各种方法。</p>
<p><a id="beans-java-instantiating-container"></a></p>
<h4><a href="#beans-java-instantiating-container"></a>1.12.2. 使用<code>AnnotationConfigApplicationContext</code>初始化Spring容器</h4>
<p>以下部分介绍了Spring的<code>AnnotationConfigApplicationContext</code>，它是在Spring 3.0中引入的。这是一个强大的(versatile)<code>ApplicationContext</code> 实现,它不仅能解析<code>@Configuration</code>注解类 ,也能解析 <code>@Component</code>注解的类和使用JSR-330注解的类.</p>
<p>当使用<code>@Configuration</code>类作为输入时,<code>@Configuration</code>类本身被注册为一个bean定义,类中所有声明的<code>@Bean</code>方法也被注册为bean定义.</p>
<p>当提供 <code>@Component</code>和JSR-330类时，它们被注册为bean定义，并且假定在必要时在这些类中使用DI元数据，例如<code>@Autowired</code> 或 <code>@Inject</code>。</p>
<p><a id="beans-java-instantiating-container-contstructor"></a></p>
<h5><a href="#beans-java-instantiating-container-contstructor"></a>简单结构</h5>
<p>与实例化<code>ClassPathXmlApplicationContext</code>时Spring XML文件用作输入的方式大致相同， 在实例化<code>AnnotationConfigApplicationContext</code>时可以使用<code>@Configuration</code> 类作为输入。 这允许完全无XML使用Spring容器，如以下示例所示：</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
    ApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(AppConfig<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
    MyService myService = ctx.getBean(MyService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
    myService.doStuff();
}
</code></pre>
<p>kotlin:</p>
<pre><code class="language-kotlin"><span class="hljs-keyword">import</span> org.springframework.beans.factory.getBean

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> ctx = AnnotationConfigApplicationContext(AppConfig::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>)</span>
    <span class="hljs-keyword">val</span> myService = ctx.getBean&lt;MyService&gt;()
    myService.doStuff()
}
</code></pre>
<p>如前所述，<code>AnnotationConfigApplicationContext</code>不仅限于使用<code>@Configuration</code>类。 任何<code>@Component</code>或JSR-330带注解的类都可以作为输入提供给构造函数，如以下示例所示：</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
    ApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(MyServiceImpl<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">Dependency1</span>.<span class="hljs-title">class</span>, <span class="hljs-title">Dependency2</span>.<span class="hljs-title">class</span>)</span>;
    MyService myService = ctx.getBean(MyService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
    myService.doStuff();
}
</code></pre>
<p>kotlin:</p>
<pre><code class="language-kotlin"><span class="hljs-keyword">import</span> org.springframework.beans.factory.getBean

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> ctx = AnnotationConfigApplicationContext(MyServiceImpl::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>, <span class="hljs-type">Dependency1::class.java</span>, <span class="hljs-type">Dependency2::class.java)</span></span>
    <span class="hljs-keyword">val</span> myService = ctx.getBean&lt;MyService&gt;()
    myService.doStuff()
}
</code></pre>
<p>上面假设<code>MyServiceImpl</code>, <code>Dependency1</code>, 和 <code>Dependency2</code>使用Spring依赖注入注解，例如<code>@Autowired</code>。</p>
<p><a id="beans-java-instantiating-container-register"></a></p>
<h5><a href="#beans-java-instantiating-container-register"></a>使用<code>register(Class&lt;?&gt;…)</code>编程构建容器</h5>
<p><code>AnnotationConfigApplicationContext</code>可以通过无参构造函数实例化，然后调用<code>register()</code> 方法进行配置。 这种方法在以编程的方式构建 <code>AnnotationConfigApplicationContext</code>时特别有用。下列示例显示了如何执行此操作</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
    AnnotationConfigApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext();
    ctx.register(AppConfig<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">OtherConfig</span>.<span class="hljs-title">class</span>)</span>;
    ctx.register(AdditionalConfig<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
    ctx.refresh();
    MyService myService = ctx.getBean(MyService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
    myService.doStuff();
}
</code></pre>
<pre><code class="language-kotlin"><span class="hljs-keyword">import</span> org.springframework.beans.factory.getBean

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> ctx = AnnotationConfigApplicationContext()
    ctx.register(AppConfig::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>, <span class="hljs-type">OtherConfig::class.java)</span></span>
    ctx.register(AdditionalConfig::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>)</span>
    ctx.refresh()
    <span class="hljs-keyword">val</span> myService = ctx.getBean&lt;MyService&gt;()
    myService.doStuff()
}
</code></pre>
<p><a id="beans-java-instantiating-container-scan"></a></p>
<h5><a href="#beans-java-instantiating-container-scan"></a>3 使用<code>scan(String…)</code>扫描组件</h5>
<p>要启用组件扫描，可以按如下方式注解<code>@Configuration</code>类:</p>
<pre><code class="language-java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@ComponentScan</span>(basePackages = <span class="hljs-string">"com.acme"</span>) (<span class="hljs-number">1</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span>  </span>{
    ...
}
</code></pre>
<pre><code class="language-kotlin"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@ComponentScan(basePackages = [<span class="hljs-meta-string">"com.acme"</span>])</span> 
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span>  </span>{
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<p><strong>1</strong>、此注解可启用组件扫描。</p>
<p>有经验的用户可能更熟悉使用XML的等价配置形式，如下例所示：</p>
<pre><code>&lt;beans&gt;
    &lt;context:component-scan base-package=&quot;com.acme&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<p>上面的例子中，<code>com.acme</code>包会被扫描，只要是使用了<code>@Component</code>注解的类，都会被注册进容器中。同样地，<code>AnnotationConfigApplicationContext</code>公开的<code>scan(String…)</code> 方法也允许扫描类完成同样的功能 如以下示例所示：</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
    AnnotationConfigApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext();
    ctx.scan(<span class="hljs-string">"com.acme"</span>);
    ctx.refresh();
    MyService myService = ctx.getBean(MyService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}
</code></pre>
<pre><code class="language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> ctx = AnnotationConfigApplicationContext()
    ctx.scan(<span class="hljs-string">"com.acme"</span>)
    ctx.refresh()
    <span class="hljs-keyword">val</span> myService = ctx.getBean&lt;MyService&gt;()
}
</code></pre>
<p>请记住<code>@Configuration</code>类是使用<code>@Component</code>进行<a href="#beans-meta-annotations">元注解</a>的，因此它们是组件扫描的候选者。 在前面的示例中， 假设AppConfig在com.acme包（或下面的任何包）中声明，它在<code>scan()</code>调用期间被拾取。 在<code>refresh()</code>之后，它的所有<code>@Bean</code>方法都被处理并在容器中注册为bean定义。</p>
<p><a id="beans-java-instantiating-container-web"></a></p>
<h5><a href="#beans-java-instantiating-container-web"></a>使用<code>AnnotationConfigWebApplicationContext</code>支持Web应用程序</h5>
<p><code>WebApplicationContext</code>与<code>AnnotationConfigApplicationContext</code>的变种是 <code>AnnotationConfigWebApplicationContext</code>配置。这个实现可以用于配置Spring <code>ContextLoaderListener</code> servlet监听器 ，Spring MVC的 <code>DispatcherServlet</code>等等。以下web.xml代码段配置典型的Spring MVC Web应用程序（请注意<code>contextClass</code> context-param和init-param的使用）：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- Configure ContextLoaderListener to use AnnotationConfigWebApplicationContext
        instead of the default XmlWebApplicationContext --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextClass<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>
            org.springframework.web.context.support.AnnotationConfigWebApplicationContext
        <span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- Configuration locations must consist of one or more comma- or space-delimited
        fully-qualified @Configuration classes. Fully-qualified packages may also be
        specified for component-scanning --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>com.acme.AppConfig<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- Bootstrap the root application context as usual using ContextLoaderListener --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- Declare a Spring MVC DispatcherServlet as usual --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>dispatcher<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- Configure DispatcherServlet to use AnnotationConfigWebApplicationContext
            instead of the default XmlWebApplicationContext --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextClass<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>
                org.springframework.web.context.support.AnnotationConfigWebApplicationContext
            <span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- Again, config locations must consist of one or more comma- or space-delimited
            and fully-qualified @Configuration classes --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>com.acme.web.MvcConfig<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- map all requests for /app/* to the dispatcher servlet --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>dispatcher<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/app/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span>
</code></pre>
<p><a id="beans-java-bean-annotation"></a></p>
<h4><a href="#beans-java-bean-annotation"></a>1.12.3. 使用<code>@Bean</code> 注解</h4>
<p><code>@Bean</code> @Bean是一个方法级别的注解，它与XML中的 <code>&lt;bean/&gt;</code>元素类似。注解支持 <code>&lt;bean/&gt;</code>提供的一些属性，例如 * <a href="#beans-factory-lifecycle-initializingbean">init-method</a> * <a href="#beans-factory-lifecycle-disposablebean">destroy-method</a> * <a href="#beans-factory-autowire">autowiring</a> * <code>name</code></p>
<p>开发者可以在<code>@Configuration</code>类或<code>@Component</code>类中使用<code>@Bean</code>注解。</p>
<p><a id="beans-java-declaring-a-bean"></a></p>
<h5><a href="#beans-java-declaring-a-bean"></a>声明一个Bean</h5>
<p>要声明一个bean，只需使用<code>@Bean</code>注解方法即可。使用此方法，将会在<code>ApplicationContext</code>内注册一个bean，bean的类型是方法的返回值类型。默认情况下， bean名称将与方法名称相同。以下示例显示了<code>@Bean</code>方法声明：</p>
<pre><code class="language-java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>{

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> TransferServiceImpl <span class="hljs-title">transferService</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TransferServiceImpl();
    }
}
</code></pre>
<p>kotlin:</p>
<pre><code class="language-kotlin"><span class="hljs-meta">@Configuration</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>{

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">transferService</span><span class="hljs-params">()</span></span> = TransferServiceImpl()
}
</code></pre>
<p>前面的配置完全等同于以下Spring XML:</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"transferService"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.acme.TransferServiceImpl"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span>
</code></pre>
<p>这两个声明都在<code>ApplicationContext</code>中创建一个名为<code>transferService</code>的bean，并且绑定了<code>TransferServiceImpl</code>的实例。如下图所示：</p>
<pre><code>transferService -&gt; com.acme.TransferServiceImpl
</code></pre>
<p>您还可以使用接口（或基类）返回类型声明<code>@Bean</code>方法，如以下示例所示：</p>
<pre><code class="language-java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>{

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> TransferService <span class="hljs-title">transferService</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TransferServiceImpl();
    }
}
</code></pre>
<pre><code class="language-kotlin"><span class="hljs-meta">@Configuration</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>{

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">transferService</span><span class="hljs-params">()</span></span>: TransferService {
        <span class="hljs-keyword">return</span> TransferServiceImpl()
    }
}
</code></pre>
<p>但是，这会将预先类型预测的可见性限制为指定的接口类型(<code>TransferService</code>),然后在实例化受影响的单一bean时,只知道容器的完整类型(<code>TransferServiceImpl</code>）。 。非延迟的单例bean根据它们的声明顺序进行实例化，因此开发者可能会看到不同类型的匹配结果，这具体取决于另一个组件尝试按未类型匹配的时间(如<code>@Autowired TransferServiceImpl</code>， 一旦<code>transferService</code> bean已被实例化,这个问题就被解决了).</p>
<p>如果通过声明的服务接口都是引用类型,那么<code>@Bean</code> 返回类型可以安全地加入该设计决策.但是,对于实现多个接口的组件或可能由其实现类型引用的组件, 更安全的方法是声明可能的最具体的返回类型(至少按照注入点所要求的特定你的bean）。</p>
<p><a id="beans-java-dependencies"></a></p>
<h5><a href="#beans-java-dependencies"></a>Bean之间的依赖</h5>
<p>一个使用<code>@Bean</code>注解的方法可以具有任意数量的参数描述构建该bean所需的依赖，例如，如果我们的<code>TransferService</code>需要<code>AccountRepository</code>， 我们可以使用方法参数来实现该依赖关系，如以下示例所示：</p>
<pre><code class="language-java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>{

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> TransferService <span class="hljs-title">transferService</span><span class="hljs-params">(AccountRepository accountRepository)</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TransferServiceImpl(accountRepository);
    }
}
</code></pre>
<pre><code class="language-kotlin"><span class="hljs-meta">@Configuration</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>{

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">transferService</span><span class="hljs-params">(accountRepository: <span class="hljs-type">AccountRepository</span>)</span></span>: TransferService {
        <span class="hljs-keyword">return</span> TransferServiceImpl(accountRepository)
    }
}
</code></pre>
<p>这个解析机制与基于构造函数的依赖注入非常相似。有关详细信息，请参阅<a href="#beans-constructor-injection">相关部分</a>。</p>
<p><a id="beans-java-lifecycle-callbacks"></a></p>
<h5><a href="#beans-java-lifecycle-callbacks"></a>接收生命周期回调</h5>
<p>使用<code>@Bean</code>注解定义的任何类都支持常规的生命周期回调，并且可以使用JSR-的<code>@PostConstruct</code>和<code>@PreDestroy</code>注解。 有关更多详细信息，请参阅 <a href="#beans-postconstruct-and-predestroy-annotations">JSR-250</a> 注解。</p>
<p>完全支持常规的Spring<a href="#beans-factory-nature">生命周期</a>回调。 如果bean实现<code>InitializingBean</code>, <code>DisposableBean</code>, 或 <code>Lifecycle</code>，则它们各自的方法由容器调用。</p>
<p>同样地，还完全支持标准的<code>*Aware</code>，如<a href="#beans-beanfactory">BeanFactoryAware</a>, <a href="#beans-factory-aware">BeanNameAware</a>, <a href="#context-functionality-messagesource">MessageSourceAware</a>, <a href="#beans-factory-aware">ApplicationContextAware</a>。</p>
<p><code>@Bean</code>注解支持指定任意初始化和销毁回调方法，就像<code>bean</code>元素上的Spring XML的 <code>init-method</code>和<code>destroy-method</code> 属性一样，如下例所示：</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeanOne</span> </span>{

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// initialization logic</span>
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeanTwo</span> </span>{

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cleanup</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// destruction logic</span>
    }
}

<span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>{

    <span class="hljs-meta">@Bean</span>(initMethod = <span class="hljs-string">"init"</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> BeanOne <span class="hljs-title">beanOne</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BeanOne();
    }

    <span class="hljs-meta">@Bean</span>(destroyMethod = <span class="hljs-string">"cleanup"</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> BeanTwo <span class="hljs-title">beanTwo</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BeanTwo();
    }
}
</code></pre>
<pre><code class="language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeanOne</span> </span>{

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> {
        <span class="hljs-comment">// initialization logic</span>
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeanTwo</span> </span>{

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">cleanup</span><span class="hljs-params">()</span></span> {
        <span class="hljs-comment">// destruction logic</span>
    }
}

<span class="hljs-meta">@Configuration</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>{

    <span class="hljs-meta">@Bean(initMethod = <span class="hljs-meta-string">"init"</span>)</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">beanOne</span><span class="hljs-params">()</span></span> = BeanOne()

    <span class="hljs-meta">@Bean(destroyMethod = <span class="hljs-meta-string">"cleanup"</span>)</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">beanTwo</span><span class="hljs-params">()</span></span> = BeanTwo()
}

</code></pre>
<p>默认情况下，使用Java Config定义的bean中<code>close</code>方法或者<code>shutdown</code>方法，会作为销毁回调而自动调用。若bean中有<code>close</code> 或 <code>shutdown</code> 方法，并且您不希望在容器关闭时调用它，则可以将<code>@Bean(destroyMethod=&quot;&quot;)</code> 添加到bean定义中以禁用默认<code>(inferred)</code> 模式。</p>
<p>开发者可能希望对通过JNDI获取的资源执行此操作，因为它的生命周期是在应用程序外部管理的。更进一步，使用 <code>DataSource</code>时一定要关闭它，不关闭将会出问题。</p>
<p>以下示例说明如何防止<code>DataSource</code>的自动销毁回调：</p>
<pre><code class="language-java"><span class="hljs-meta">@Bean</span>(destroyMethod=<span class="hljs-string">""</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">dataSource</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> NamingException </span>{
    <span class="hljs-keyword">return</span> (DataSource) jndiTemplate.lookup(<span class="hljs-string">"MyDS"</span>);
}
</code></pre>
<pre><code class="language-kotlin"><span class="hljs-meta">@Bean(destroyMethod = <span class="hljs-meta-string">""</span>)</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dataSource</span><span class="hljs-params">()</span></span>: DataSource {
    <span class="hljs-keyword">return</span> jndiTemplate.lookup(<span class="hljs-string">"MyDS"</span>) <span class="hljs-keyword">as</span> DataSource
}
</code></pre>
<p>同样地，使用<code>@Bean</code>方法，通常会选择使用程序化的JNDI查找：使用Spring的<code>JndiTemplate</code> / <code>JndiLocatorDelegate</code>帮助类或直接使用JNDI的<code>InitialContext</code> ，但是不要使用<code>JndiObjectFactoryBean</code>的变体，因为它会强制开发者声明一个返回类型作为<code>FactoryBean</code>的类型用于代替实际的目标类型，这会使得交叉引用变得很困难。</p>
<p>对于前面注解中上面示例中的<code>BeanOne</code>，在构造期间直接调用<code>init()</code>方法同样有效，如下例所示：</p>
<pre><code class="language-java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>{

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> BeanOne <span class="hljs-title">beanOne</span><span class="hljs-params">()</span> </span>{
        BeanOne beanOne = <span class="hljs-keyword">new</span> BeanOne();
        beanOne.init();
        <span class="hljs-keyword">return</span> beanOne;
    }

    <span class="hljs-comment">// ...</span>
}
</code></pre>
<pre><code class="language-kotlin"><span class="hljs-meta">@Configuration</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>{

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">beanOne</span><span class="hljs-params">()</span></span> = BeanOne().apply {
        <span class="hljs-keyword">init</span>()
    }

    <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>当您直接使用Java（new对象那种）工作时，您可以使用对象执行任何您喜欢的操作，并且不必总是依赖于容器生命周期。</p>
<p><a id="beans-java-specifying-bean-scope"></a></p>
<h5><a href="#beans-java-specifying-bean-scope"></a>指定Bean范围</h5>
<p>Spring包含<code>@Scope</code>注解，以便您可以指定bean的范围。</p>
<p><a id="beans-java-available-scopes"></a></p>
<h6><a href="#beans-java-available-scopes"></a>使用 <code>@Scope</code> 注解</h6>
<p>可以使用任意标准的方式为 <code>@Bean</code>注解的bean指定一个作用域，你可以使用<a href="#beans-factory-scopes">Bean Scopes</a>中的任意标准作用域</p>
<p>默认范围是<code>singleton</code>的，但是可以使用 <code>@Scope</code>注解来覆盖。如下例所示：</p>
<pre><code class="language-java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyConfiguration</span> </span>{

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-meta">@Scope</span>(<span class="hljs-string">"prototype"</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> Encryptor <span class="hljs-title">encryptor</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// ...</span>
    }
}
</code></pre>
<pre><code class="language-kotlin"><span class="hljs-meta">@Configuration</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyConfiguration</span> </span>{

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-meta">@Scope(<span class="hljs-meta-string">"prototype"</span>)</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">encryptor</span><span class="hljs-params">()</span></span>: Encryptor {
        <span class="hljs-comment">// ...</span>
    }
}
</code></pre>
<p><a id="beans-java-scoped-proxy"></a></p>
<h6><a href="#beans-java-scoped-proxy"></a><code>@Scope</code> and <code>scoped-proxy</code></h6>
<p>Spring提供了一种通过<a href="#beans-factory-scopes-other-injection">scoped proxies</a>处理作用域依赖项的便捷方法。使用XML配置时创建此类代理的最简单方法是<code>&lt;aop:scoped-proxy/&gt;</code>元素。 使用<code>@Scope</code>注解在Java中配置bean提供了与<code>proxyMode</code>属性的等效支持。 默认值为无代理（<code>ScopedProxyMode.NO</code>），但您可以指定<code>ScopedProxyMode.TARGET_CLASS</code> 或 <code>ScopedProxyMode.INTERFACES</code>。</p>
<p>如果使用Java将XML参考文档（请参阅<a href="#beans-factory-scopes-other-injection">scoped proxies</a>）的作用域代理示例移植到我们的 <code>@Bean</code>，它类似于以下内容：</p>
<pre><code class="language-java"><span class="hljs-comment">// an HTTP Session-scoped bean exposed as a proxy</span>
<span class="hljs-meta">@Bean</span>
<span class="hljs-meta">@SessionScope</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> UserPreferences <span class="hljs-title">userPreferences</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UserPreferences();
}

<span class="hljs-meta">@Bean</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> Service <span class="hljs-title">userService</span><span class="hljs-params">()</span> </span>{
    UserService service = <span class="hljs-keyword">new</span> SimpleUserService();
    <span class="hljs-comment">// a reference to the proxied userPreferences bean</span>
    service.setUserPreferences(userPreferences());
    <span class="hljs-keyword">return</span> service;
}
</code></pre>
<pre><code class="language-kotlin"><span class="hljs-comment">// an HTTP Session-scoped bean exposed as a proxy</span>
<span class="hljs-meta">@Bean</span>
<span class="hljs-meta">@SessionScope</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">userPreferences</span><span class="hljs-params">()</span></span> = UserPreferences()

<span class="hljs-meta">@Bean</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">userService</span><span class="hljs-params">()</span></span>: Service {
    <span class="hljs-keyword">return</span> SimpleUserService().apply {
        <span class="hljs-comment">// a reference to the proxied userPreferences bean</span>
        setUserPreferences(userPreferences()
    }
}
</code></pre>
<p><a id="beans-java-customizing-bean-naming"></a></p>
<h5><a href="#beans-java-customizing-bean-naming"></a>自定义Bean命名</h5>
<p>默认情况下，配置类使用<code>@Bean</code>方法的名称作为结果bean的名称。 但是，可以使用<code>name</code>属性覆盖此功能，如以下示例所示：</p>
<pre><code class="language-java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>{

    <span class="hljs-meta">@Bean</span>(name = <span class="hljs-string">"myThing"</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> Thing <span class="hljs-title">thing</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Thing();
    }
}
</code></pre>
<pre><code class="language-kotlin"><span class="hljs-meta">@Configuration</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>{

    <span class="hljs-meta">@Bean(<span class="hljs-meta-string">"myThing"</span>)</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">thing</span><span class="hljs-params">()</span></span> = Thing()
}
</code></pre>
<p><a id="beans-java-bean-aliasing"></a></p>
<h5><a href="#beans-java-bean-aliasing"></a>bean别名</h5>
<p>正如<a href="#beans-beanname">Bean的 命名</a>中所讨论的，有时需要为单个bean提供多个名称，也称为bean别名。 <code>@Bean</code>注解的 <code>name</code>属性为此接受String数组。 以下示例显示如何为bean设置多个别名：</p>
<pre><code class="language-java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>{

    <span class="hljs-meta">@Bean</span>(name = { <span class="hljs-string">"dataSource"</span>, <span class="hljs-string">"subsystemA-dataSource"</span>, <span class="hljs-string">"subsystemB-dataSource"</span> })
    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">dataSource</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// instantiate, configure and return DataSource bean...</span>
    }
}
</code></pre>
<pre><code class="language-kotlin"><span class="hljs-meta">@Configuration</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>{

    <span class="hljs-meta">@Bean(<span class="hljs-meta-string">"dataSource"</span>, <span class="hljs-meta-string">"subsystemA-dataSource"</span>, <span class="hljs-meta-string">"subsystemB-dataSource"</span>)</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dataSource</span><span class="hljs-params">()</span></span>: DataSource {
        <span class="hljs-comment">// instantiate, configure and return DataSource bean...</span>
    }
}
</code></pre>
<p><a id="beans-java-bean-description"></a></p>
<h5><a href="#beans-java-bean-description"></a>Bean 的描述</h5>
<p>有时，提供更详细的bean文本描述会很有帮助。 当bean被暴露（可能通过JMX）用于监视目的时，这可能特别有用。</p>
<p>要向@Bean添加描述，可以使用<a href="https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/context/annotation/Description.html"><code>@Description</code></a>注解，如以下示例所示：</p>
<pre><code class="language-java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>{

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-meta">@Description</span>(<span class="hljs-string">"Provides a basic example of a bean"</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> Thing <span class="hljs-title">thing</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Thing();
    }
}
</code></pre>
<pre><code class="language-kotlin"><span class="hljs-meta">@Configuration</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>{

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-meta">@Description(<span class="hljs-meta-string">"Provides a basic example of a bean"</span>)</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">thing</span><span class="hljs-params">()</span></span> = Thing()
}
</code></pre>
<p><a id="beans-java-configuration-annotation"></a></p>
<h4><a href="#beans-java-configuration-annotation"></a>1.12.4. 使用 <code>@Configuration</code> 注解</h4>
<p><code>@Configuration</code>是一个类级别的注解,表明该类将作为bean定义的元数据配置. <code>@Configuration</code>类会将有<code>@Bean</code>注解的公开方法声明为bean, .在 <code>@Configuration</code>类上调用<code>@Bean</code>方法也可以用于定义bean间依赖关系, 有关一般介绍，请参阅 <a href="#beans-java-basic-concepts">基本概念: <code>@Bean</code> 和 <code>@Configuration</code></a></p>
<p><a id="beans-java-injecting-dependencies"></a></p>
<h5><a href="#beans-java-injecting-dependencies"></a>注入内部bean依赖</h5>
<p>当Bean彼此有依赖关系时,表示依赖关系就像调用另一个bean方法一样简单.如下例所示：</p>
<pre><code class="language-java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>{

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> BeanOne <span class="hljs-title">beanOne</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BeanOne(beanTwo());
    }

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> BeanTwo <span class="hljs-title">beanTwo</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BeanTwo();
    }
}
</code></pre>
<pre><code class="language-kotlin"><span class="hljs-meta">@Configuration</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>{

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">beanOne</span><span class="hljs-params">()</span></span> = BeanOne(beanTwo())

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">beanTwo</span><span class="hljs-params">()</span></span> = BeanTwo()
}
</code></pre>
<p>在前面的示例中，<code>beanOne</code>通过构造函数注入接收对<code>beanTwo</code>的引用。</p>
<p>这种声明bean间依赖关系的方法只有在 <code>@Configuration</code> 类中声明<code>@Bean</code>方法时才有效。 您不能使用普通的<code>@Component</code>类声明bean间依赖关系。</p>
<p><a id="beans-java-method-injection"></a></p>
<h5><a href="#beans-java-method-injection"></a>查找方法注入</h5>
<p>如前所述，<a href="#beans-factory-method-injection">查找方法注入</a>是一项很少使用的高级功能。 在单例范围的bean依赖于原型范围的bean的情况下，它很有用。 Java提供了很友好的API来实现这种模式。以下示例显示了如何使用查找方法注入：</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CommandManager</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">process</span><span class="hljs-params">(Object commandState)</span> </span>{
        <span class="hljs-comment">// grab a new instance of the appropriate Command interface</span>
        Command command = createCommand();
        <span class="hljs-comment">// set the state on the (hopefully brand new) Command instance</span>
        command.setState(commandState);
        <span class="hljs-keyword">return</span> command.execute();
    }

    <span class="hljs-comment">// okay... but where is the implementation of this method?</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> Command <span class="hljs-title">createCommand</span><span class="hljs-params">()</span></span>;
}
</code></pre>
<pre><code class="language-kotlin"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CommandManager</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">process</span><span class="hljs-params">(commandState: <span class="hljs-type">Any</span>)</span></span>: Any {
        <span class="hljs-comment">// grab a new instance of the appropriate Command interface</span>
        <span class="hljs-keyword">val</span> command = createCommand()
        <span class="hljs-comment">// set the state on the (hopefully brand new) Command instance</span>
        command.setState(commandState)
        <span class="hljs-keyword">return</span> command.execute()
    }

    <span class="hljs-comment">// okay... but where is the implementation of this method?</span>
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createCommand</span><span class="hljs-params">()</span></span>: Command
}
</code></pre>
<p>通过使用Java配置，您可以创建 <code>CommandManager</code>的子类，其中抽象的 <code>createCommand()</code> 方法被覆盖，以便查找新的（原型）对象。 以下示例显示了如何执行此操作：</p>
<pre><code class="language-java"><span class="hljs-meta">@Bean</span>
<span class="hljs-meta">@Scope</span>(<span class="hljs-string">"prototype"</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> AsyncCommand <span class="hljs-title">asyncCommand</span><span class="hljs-params">()</span> </span>{
    AsyncCommand command = <span class="hljs-keyword">new</span> AsyncCommand();
    <span class="hljs-comment">// inject dependencies here as required</span>
    <span class="hljs-keyword">return</span> command;
}

<span class="hljs-meta">@Bean</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> CommandManager <span class="hljs-title">commandManager</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// return new anonymous implementation of CommandManager with command() overridden</span>
    <span class="hljs-comment">// to return a new prototype Command object</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CommandManager() {
        <span class="hljs-function"><span class="hljs-keyword">protected</span> Command <span class="hljs-title">createCommand</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">return</span> asyncCommand();
        }
    }
}
</code></pre>
<pre><code class="language-kotlin"><span class="hljs-meta">@Bean</span>
<span class="hljs-meta">@Scope(<span class="hljs-meta-string">"prototype"</span>)</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">asyncCommand</span><span class="hljs-params">()</span></span>: AsyncCommand {
    <span class="hljs-keyword">val</span> command = AsyncCommand()
    <span class="hljs-comment">// inject dependencies here as required</span>
    <span class="hljs-keyword">return</span> command
}

<span class="hljs-meta">@Bean</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">commandManager</span><span class="hljs-params">()</span></span>: CommandManager {
    <span class="hljs-comment">// return new anonymous implementation of CommandManager with createCommand()</span>
    <span class="hljs-comment">// overridden to return a new prototype Command object</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">object</span> : CommandManager() {
        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createCommand</span><span class="hljs-params">()</span></span>: Command {
            <span class="hljs-keyword">return</span> asyncCommand()
        }
    }
}
</code></pre>
<p><a id="beans-java-further-information-java-config"></a></p>
<h5><a href="#beans-java-further-information-java-config"></a>有关基于Java的配置如何在内部工作的更多信息</h5>
<p>请考虑以下示例，该示例显示了被调用两次的<code>@Bean</code>注解方法:</p>
<pre><code class="language-java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>{

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> ClientService <span class="hljs-title">clientService1</span><span class="hljs-params">()</span> </span>{
        ClientServiceImpl clientService = <span class="hljs-keyword">new</span> ClientServiceImpl();
        clientService.setClientDao(clientDao());
        <span class="hljs-keyword">return</span> clientService;
    }

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> ClientService <span class="hljs-title">clientService2</span><span class="hljs-params">()</span> </span>{
        ClientServiceImpl clientService = <span class="hljs-keyword">new</span> ClientServiceImpl();
        clientService.setClientDao(clientDao());
        <span class="hljs-keyword">return</span> clientService;
    }

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> ClientDao <span class="hljs-title">clientDao</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ClientDaoImpl();
    }
}
</code></pre>
<pre><code class="language-kotlin"><span class="hljs-meta">@Configuration</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>{

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">clientService1</span><span class="hljs-params">()</span></span>: ClientService {
        <span class="hljs-keyword">return</span> ClientServiceImpl().apply {
            clientDao = clientDao()
        }
    }

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">clientService2</span><span class="hljs-params">()</span></span>: ClientService {
        <span class="hljs-keyword">return</span> ClientServiceImpl().apply {
            clientDao = clientDao()
        }
    }

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">clientDao</span><span class="hljs-params">()</span></span>: ClientDao {
        <span class="hljs-keyword">return</span> ClientDaoImpl()
    }
}
</code></pre>
<p><code>clientDao()</code>在<code>clientService1()</code>中调用一次，在<code>clientService2()</code>中调用一次。由于此方法创建了<code>ClientDaoImpl</code>的新实例并将其返回，因此通常希望有两个实例（每个服务一个）。 这肯定会有问题：在Spring中，实例化的bean默认具有<code>singleton</code>范围。这就是它的神奇之处:所有<code>@Configuration</code>类在启动时都使用 <code>CGLIB</code>进行子类化。 在子类中，子方法在调用父方法并创建新实例之前，首先检查容器是否有任何缓存（作用域）bean。</p>
<p>这种行为可以根据bean的作用域而变化,我们这里只是讨论单例.</p>
<p>从Spring 3.2开始，不再需要将CGLIB添加到类路径中，因为CGLIB类已经在<code>org.springframework.cglib</code>下重新打包并直接包含在spring-core JAR中。</p>
<p>由于CGLIB在启动时动态添加功能，因此存在一些限制。 特别是，配置类不能是 final的。 但是，从4.3开始，配置类允许使用任何构造函数，包括使用<code>@Autowired</code>或单个非默认构造函数声明进行默认注入。</p>
<p>如果想避免因CGLIB带来的限制,请考虑声明非<code>@Configuration</code>类的<code>@Bean</code>方法，例如在纯的<code>@Component</code>类 .这样在<code>@Bean</code>方法之间的交叉方法调用将不会被拦截,此时必须在构造函数或方法级别上进行依赖注入。</p>
<p><a id="beans-java-composing-configuration-classes"></a></p>
<h4><a href="#beans-java-composing-configuration-classes"></a>1.12.5. 编写基于Java的配置</h4>
<p>Spring的基于Java的配置功能允许您撰写注解，这可以降低配置的复杂性。</p>
<p><a id="beans-java-using-import"></a></p>
<h5><a href="#beans-java-using-import"></a>使用<code>@Import</code> 注解</h5>
<p>就像在Spring XML文件中使用<code>&lt;import/&gt;</code>元素来帮助模块化配置一样，<code>@Import</code> 注解允许从另一个配置类加载<code>@Bean</code>定义，如下例所示：</p>
<pre><code class="language-java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConfigA</span> </span>{

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> A <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> A();
    }
}

<span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@Import</span>(ConfigA<span class="hljs-class">.<span class="hljs-keyword">class</span>)
<span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">ConfigB</span> </span>{

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> B <span class="hljs-title">b</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> B();
    }
}
</code></pre>
<pre><code class="language-kotlin"><span class="hljs-meta">@Configuration</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConfigA</span> </span>{

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">a</span><span class="hljs-params">()</span></span> = A()
}

<span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@Import(ConfigA::class)</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConfigB</span> </span>{

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">b</span><span class="hljs-params">()</span></span> = B()
}
</code></pre>
<p>现在，在实例化上下文时，不需要同时指定<code>ConfigA.class</code>和 <code>ConfigB.class</code>，只需要显式提供<code>ConfigB</code>，如下例所示：</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
    ApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(ConfigB<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    <span class="hljs-comment">// now both beans A and B will be available...</span>
    A a = ctx.getBean(A<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
    B b = ctx.getBean(B<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}
</code></pre>
<pre><code class="language-kotlin"><span class="hljs-keyword">import</span> org.springframework.beans.factory.getBean

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> ctx = AnnotationConfigApplicationContext(ConfigB::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>)</span>

    <span class="hljs-comment">// now both beans A and B will be available...</span>
    <span class="hljs-keyword">val</span> a = ctx.getBean&lt;A&gt;()
    <span class="hljs-keyword">val</span> b = ctx.getBean&lt;B&gt;()
}
</code></pre>
<p>这种方法简化了容器实例化，因为只需要处理一个类，而不是要求您在构造期间记住可能大量的<code>@Configuration</code>类。</p>
<p>从Spring Framework 4.2开始，<code>@Import</code>还支持引用常规组件类，类似于<code>AnnotationConfigApplicationContext.register</code>方法。 如果要避免组件扫描，这一点特别有用，可以使用一些配置类作为明确定义所有组件的入口点。</p>
<p><a id="beans-java-injecting-imported-beans"></a></p>
<h6><a href="#beans-java-injecting-imported-beans"></a>在导入的<code>@Bean</code>定义上注入依赖项</h6>
<p>上面的例子可以运行,,但是太简单了。在大多数实际情况下，bean将在配置类之间相互依赖.在使用XML时,这本身不是问题,因为没有涉及到编译器. 可以简单地声明 <code>ref=&quot;someBean&quot;</code>,并且相信Spring将在容器初始化期间可以很好地处理它。当然，当使用<code>@Configuration</code>类时，Java编译器会有一些限制 ，即需符合Java的语法。</p>
<p>幸运的是，解决这个问题很简单。正如我们<a href="#beans-java-dependencies">已经讨论过</a>的，<code>@Bean</code>方法可以有任意数量的参数来描述bean的依赖关系。 考虑以下更多真实场景，其中包含几个 <code>@Configuration</code>类，每个类都取决于其他类中声明的bean：</p>
<pre><code class="language-java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServiceConfig</span> </span>{

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> TransferService <span class="hljs-title">transferService</span><span class="hljs-params">(AccountRepository accountRepository)</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TransferServiceImpl(accountRepository);
    }
}

<span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RepositoryConfig</span> </span>{

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> AccountRepository <span class="hljs-title">accountRepository</span><span class="hljs-params">(DataSource dataSource)</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JdbcAccountRepository(dataSource);
    }
}

<span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@Import</span>({ServiceConfig<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">RepositoryConfig</span>.<span class="hljs-title">class</span>})
<span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">SystemTestConfig</span> </span>{

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">dataSource</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// return new DataSource</span>
    }
}

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
    ApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(SystemTestConfig<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
    <span class="hljs-comment">// everything wires up across configuration classes...</span>
    TransferService transferService = ctx.getBean(TransferService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
    transferService.transfer(<span class="hljs-number">100.00</span>, <span class="hljs-string">"A123"</span>, <span class="hljs-string">"C456"</span>);
}
</code></pre>
<pre><code class="language-kotlin"><span class="hljs-keyword">import</span> org.springframework.beans.factory.getBean

<span class="hljs-meta">@Configuration</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServiceConfig</span> </span>{

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">transferService</span><span class="hljs-params">(accountRepository: <span class="hljs-type">AccountRepository</span>)</span></span>: TransferService {
        <span class="hljs-keyword">return</span> TransferServiceImpl(accountRepository)
    }
}

<span class="hljs-meta">@Configuration</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RepositoryConfig</span> </span>{

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">accountRepository</span><span class="hljs-params">(dataSource: <span class="hljs-type">DataSource</span>)</span></span>: AccountRepository {
        <span class="hljs-keyword">return</span> JdbcAccountRepository(dataSource)
    }
}

<span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@Import(ServiceConfig::class, RepositoryConfig::class)</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SystemTestConfig</span> </span>{

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dataSource</span><span class="hljs-params">()</span></span>: DataSource {
        <span class="hljs-comment">// return new DataSource</span>
    }
}


<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> ctx = AnnotationConfigApplicationContext(SystemTestConfig::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>)</span>
    <span class="hljs-comment">// everything wires up across configuration classes...</span>
    <span class="hljs-keyword">val</span> transferService = ctx.getBean&lt;TransferService&gt;()
    transferService.transfer(<span class="hljs-number">100.00</span>, <span class="hljs-string">"A123"</span>, <span class="hljs-string">"C456"</span>)
}
</code></pre>
<p>还有另一种方法可以达到相同的效果。请记住，<code>@Configuration</code>类最终只是容器中的另一个bean： 这意味着它们可以利用<code>@Autowired</code> 和 <code>@Value</code> 注入以及与任何其他bean相同的其他功能。</p>
<p>确保以这种方式注入的依赖项只是最简单的。<code>@Configuration</code>类在上下文初始化期间很早就被处理，并且强制以这种方式注入依赖项可能会导致意外的早期初始化。 尽可能采用基于参数的注入，如前面的示例所示。</p>
<p>另外，要特别注意通过<code>@Bean</code>的<code>BeanPostProcessor</code> 和 <code>BeanFactoryPostProcessor</code>定义。 这些通常应该声明为静态<code>@Bean</code>方法，而不是触发其包含配置类的实例化。否则，<code>@Autowired</code> 和 <code>@Value</code>不能在配置类本身上工作，因为它过早地被创建为bean实例。</p>
<p>以下示例显示了如何将一个bean自动连接到另一个bean:</p>
<pre><code class="language-java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServiceConfig</span> </span>{

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> AccountRepository accountRepository;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> TransferService <span class="hljs-title">transferService</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TransferServiceImpl(accountRepository);
    }
}

<span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RepositoryConfig</span> </span>{

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> DataSource dataSource;

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RepositoryConfig</span><span class="hljs-params">(DataSource dataSource)</span> </span>{
        <span class="hljs-keyword">this</span>.dataSource = dataSource;
    }

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> AccountRepository <span class="hljs-title">accountRepository</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JdbcAccountRepository(dataSource);
    }
}

<span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@Import</span>({ServiceConfig<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">RepositoryConfig</span>.<span class="hljs-title">class</span>})
<span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">SystemTestConfig</span> </span>{

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">dataSource</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// return new DataSource</span>
    }
}

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
    ApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(SystemTestConfig<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
    <span class="hljs-comment">// everything wires up across configuration classes...</span>
    TransferService transferService = ctx.getBean(TransferService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
    transferService.transfer(<span class="hljs-number">100.00</span>, <span class="hljs-string">"A123"</span>, <span class="hljs-string">"C456"</span>);
}
</code></pre>
<pre><code class="language-kotlin"><span class="hljs-keyword">import</span> org.springframework.beans.factory.getBean

<span class="hljs-meta">@Configuration</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServiceConfig</span> </span>{

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> accountRepository: AccountRepository

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">transferService</span><span class="hljs-params">()</span></span>: TransferService {
        <span class="hljs-keyword">return</span> TransferServiceImpl(accountRepository)
    }
}

<span class="hljs-meta">@Configuration</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RepositoryConfig</span></span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> dataSource: DataSource) {

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">accountRepository</span><span class="hljs-params">()</span></span>: AccountRepository {
        <span class="hljs-keyword">return</span> JdbcAccountRepository(dataSource)
    }
}

<span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@Import(ServiceConfig::class, RepositoryConfig::class)</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SystemTestConfig</span> </span>{

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dataSource</span><span class="hljs-params">()</span></span>: DataSource {
        <span class="hljs-comment">// return new DataSource</span>
    }
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> ctx = AnnotationConfigApplicationContext(SystemTestConfig::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>)</span>
    <span class="hljs-comment">// everything wires up across configuration classes...</span>
    <span class="hljs-keyword">val</span> transferService = ctx.getBean&lt;TransferService&gt;()
    transferService.transfer(<span class="hljs-number">100.00</span>, <span class="hljs-string">"A123"</span>, <span class="hljs-string">"C456"</span>)
}
</code></pre>
<p>仅在Spring Framework 4.3中支持<code>@Configuration</code>类中的构造函数注入。 另请注意，如果目标bean仅定义了一个构造函数，则无需指定<code>@Autowired</code>。 在前面的示例中，<code>RepositoryConfig</code>构造函数中不需要<code>@Autowired</code>。</p>
<p>完全导入bean便于查找</p>
<p>在上面的场景中,<code>@Autowired</code>可以很好的工作,使设计更具模块化,但是自动注入哪个bean依然有些模糊不清.例如, 作为一个开发者查看<code>ServiceConfig</code>类时,你怎么知道<code>@Autowired AccountRepository</code>在哪定义的呢?代码中并未明确指出, 还好, <a href="https://spring.io/tools/sts">Spring Tool Suite</a>提供的工具可以呈现图表，显示所有内容的连线方式，这可能就是您所需要的。 此外，您的Java IDE可以轻松找到<code>AccountRepository</code>类型的所有声明和用法，并快速显示返回该类型的<code>@Bean</code>方法的位置。</p>
<p>万一需求不允许这种模糊的装配,并且您希望从IDE中从一个<code>@Configuration</code>类直接导航到另一个<code>@Configuration</code>类，请考虑自动装配配置类本身。 以下示例显示了如何执行此操作：</p>
<pre><code class="language-java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServiceConfig</span> </span>{

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> RepositoryConfig repositoryConfig;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> TransferService <span class="hljs-title">transferService</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// navigate 'through' the config class to the @Bean method!</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TransferServiceImpl(repositoryConfig.accountRepository());
    }
}
</code></pre>
<pre><code class="language-kotlin"><span class="hljs-meta">@Configuration</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServiceConfig</span> </span>{

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> repositoryConfig: RepositoryConfig

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">transferService</span><span class="hljs-params">()</span></span>: TransferService {
        <span class="hljs-comment">// navigate 'through' the config class to the @Bean method!</span>
        <span class="hljs-keyword">return</span> TransferServiceImpl(repositoryConfig.accountRepository())
    }
}
</code></pre>
<p>在前面的情况中，定义<code>AccountRepository</code> 是完全明确的。但是，<code>ServiceConfig</code>现在与<code>RepositoryConfig</code>紧密耦合。这是一种权衡的方法。 通过使用基于接口的或基于类的抽象<code>@Configuration</code> 类，可以在某种程度上减轻这种紧密耦合。请考虑以下示例：</p>
<pre><code class="language-java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServiceConfig</span> </span>{

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> RepositoryConfig repositoryConfig;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> TransferService <span class="hljs-title">transferService</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TransferServiceImpl(repositoryConfig.accountRepository());
    }
}

<span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">RepositoryConfig</span> </span>{

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function">AccountRepository <span class="hljs-title">accountRepository</span><span class="hljs-params">()</span></span>;
}

<span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultRepositoryConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RepositoryConfig</span> </span>{

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> AccountRepository <span class="hljs-title">accountRepository</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JdbcAccountRepository(...);
    }
}

<span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@Import</span>({ServiceConfig<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">DefaultRepositoryConfig</span>.<span class="hljs-title">class</span>})  // <span class="hljs-title">import</span> <span class="hljs-title">the</span> <span class="hljs-title">concrete</span> <span class="hljs-title">config</span>!
<span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">SystemTestConfig</span> </span>{

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">dataSource</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// return DataSource</span>
    }

}

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
    ApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(SystemTestConfig<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
    TransferService transferService = ctx.getBean(TransferService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
    transferService.transfer(<span class="hljs-number">100.00</span>, <span class="hljs-string">"A123"</span>, <span class="hljs-string">"C456"</span>);
}
</code></pre>
<pre><code class="language-kotlin"><span class="hljs-keyword">import</span> org.springframework.beans.factory.getBean

<span class="hljs-meta">@Configuration</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServiceConfig</span> </span>{

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> repositoryConfig: RepositoryConfig

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">transferService</span><span class="hljs-params">()</span></span>: TransferService {
        <span class="hljs-keyword">return</span> TransferServiceImpl(repositoryConfig.accountRepository())
    }
}

<span class="hljs-meta">@Configuration</span>
<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">RepositoryConfig</span> </span>{

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">accountRepository</span><span class="hljs-params">()</span></span>: AccountRepository
}

<span class="hljs-meta">@Configuration</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultRepositoryConfig</span> : <span class="hljs-type">RepositoryConfig {</span></span>

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">accountRepository</span><span class="hljs-params">()</span></span>: AccountRepository {
        <span class="hljs-keyword">return</span> JdbcAccountRepository(...)
    }
}

<span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@Import(ServiceConfig::class, DefaultRepositoryConfig::class)</span>  <span class="hljs-comment">// import the concrete config!</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SystemTestConfig</span> </span>{

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dataSource</span><span class="hljs-params">()</span></span>: DataSource {
        <span class="hljs-comment">// return DataSource</span>
    }

}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> ctx = AnnotationConfigApplicationContext(SystemTestConfig::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>)</span>
    <span class="hljs-keyword">val</span> transferService = ctx.getBean&lt;TransferService&gt;()
    transferService.transfer(<span class="hljs-number">100.00</span>, <span class="hljs-string">"A123"</span>, <span class="hljs-string">"C456"</span>)
}
</code></pre>
<p>现在，<code>ServiceConfig</code>与具体的<code>DefaultRepositoryConfig</code>松散耦合，内置的IDE工具仍然很有用：您可以很容易获取<code>RepositoryConfig</code>实现类的继承体系。 以这种方式,操作<code>@Configuration</code>类及其依赖关系与操作基于接口的代码的过程没有什么区别</p>
<p>如果要影响某些bean的启动创建顺序，可以考虑将其中一些声明为<code>@Lazy</code> （用于在首次访问时创建而不是在启动时）或<code>@DependsOn</code>某些其他bean（确保在创建之前创建特定的其他bean（当前的bean，超出后者的直接依赖性所暗示的））。</p>
<p><a id="beans-java-conditional"></a></p>
<h5><a href="#beans-java-conditional"></a>有条件地包含<code>@Configuration</code>类或<code>@Bean</code>方法</h5>
<p>基于某些任意系统状态，有条件地启用或禁用完整的<code>@Configuration</code>类甚至单独的 <code>@Bean</code> 方法通常很有用。 一个常见的例子是， 只有在Spring环境中启用了特定的配置文件时才使用<code>@Profile</code> 注解来激活bean（有关详细信息，请参阅Bean<a href="#beans-definition-profiles">定义配置文件</a>）。</p>
<p><code>@Profile</code>注解实际上是通过使用更灵活的注解<code>@Conditional</code>实现的。<a href="https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/context/annotation/Conditional.html"><code>@Conditional</code></a>注解表示特定的<code>org.springframework.context.annotation.Condition</code>实现。 它表明<code>@Bean</code>被注册之前会先&quot;询问&quot;<code>@Conditional</code>注解。</p>
<p><code>Condition</code>接口的实现提供了一个返回<code>true</code> 或 <code>false</code>的<code>matches(…)</code>方法。例如，以下清单显示了用于 <code>@Profile</code>的实际<code>Condition</code>实现：</p>
<pre><code class="language-java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>{
    <span class="hljs-keyword">if</span> (context.getEnvironment() != <span class="hljs-keyword">null</span>) {
        <span class="hljs-comment">// Read the @Profile annotation attributes</span>
        MultiValueMap&lt;String, Object&gt; attrs = metadata.getAllAnnotationAttributes(Profile<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getName</span>())</span>;
        <span class="hljs-keyword">if</span> (attrs != <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">for</span> (Object value : attrs.get(<span class="hljs-string">"value"</span>)) {
                <span class="hljs-keyword">if</span> (context.getEnvironment().acceptsProfiles(((String[]) value))) {
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
                }
            }
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
}
</code></pre>
<pre><code class="language-kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">matches</span><span class="hljs-params">(context: <span class="hljs-type">ConditionContext</span>, metadata: <span class="hljs-type">AnnotatedTypeMetadata</span>)</span></span>: <span class="hljs-built_in">Boolean</span> {
    <span class="hljs-comment">// Read the @Profile annotation attributes</span>
    <span class="hljs-keyword">val</span> attrs = metadata.getAllAnnotationAttributes(Profile::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>.<span class="hljs-title">name</span>)</span>
    <span class="hljs-keyword">if</span> (attrs != <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">for</span> (value <span class="hljs-keyword">in</span> attrs[<span class="hljs-string">"value"</span>]!!) {
            <span class="hljs-keyword">if</span> (context.environment.acceptsProfiles(Profiles .of(*value <span class="hljs-keyword">as</span> Array&lt;String&gt;))) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
}
</code></pre>
<p>有关更多详细信息，请参阅<a href="https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/context/annotation/Conditional.html"><code>@Conditional</code></a>javadoc。</p>
<p><a id="beans-java-combining"></a></p>
<h5><a href="#beans-java-combining"></a>结合Java和XML配置</h5>
<p>Spring的<code>@Configuration</code>类支持但不一定成为Spring XML的100％完全替代品。 某些工具（如Spring XML命名空间）仍然是配置容器的理想方法。在XML方便或必要的情况下，您可以选择：通过使用例如<code>ClassPathXmlApplicationContext</code>以“以XML为中心”的方式实例化容器， 或者通过使用<code>AnnotationConfigApplicationContext</code>以“以Java为中心”的方式实例化它。<code>@ImportResource</code>注解，根据需要导入XML。</p>
<p><a id="beans-java-combining-xml-centric"></a></p>
<h6><a href="#beans-java-combining-xml-centric"></a>以XML为中心使用<code>@Configuration</code>类</h6>
<p>更受人喜爱的方法是从包含<code>@Configuration</code>类的XML启动容器.例如，在使用Spring的现有系统中,大量使用的是Spring XML配置,所以很容易根据需要创建<code>@Configuration</code>类 ,并将他们到包含XML文件中。我们将介绍在这种“以XML为中心”的情况下使用<code>@Configuration</code>类的选项。</p>
<p>将<code>@Configuration</code>类声明为普通的Spring<code>&lt;bean/&gt;</code> 元素</p>
<p>请记住,<code>@Configuration</code>类最终也只是容器中的bean定义。在本系列示例中，我们创建一个名为AppConfig的<code>@Configuration</code>类，并将其作为<code>&lt;bean/&gt;</code>定义包含在<code>system-test-config.xml</code>中。 由于 <code>&lt;context:annotation-config/&gt;</code>已打开，容器会识别<code>@Configuration</code> 注解并正确处理<code>AppConfig</code>中声明的<code>@Bean</code> 方法。</p>
<p>以下示例显示了Java中的普通配置类:</p>
<pre><code class="language-java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>{

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> DataSource dataSource;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> AccountRepository <span class="hljs-title">accountRepository</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JdbcAccountRepository(dataSource);
    }

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> TransferService <span class="hljs-title">transferService</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TransferService(accountRepository());
    }
}
</code></pre>
<pre><code class="language-kotlin"><span class="hljs-meta">@Configuration</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>{

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> dataSource: DataSource

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">accountRepository</span><span class="hljs-params">()</span></span>: AccountRepository {
        <span class="hljs-keyword">return</span> JdbcAccountRepository(dataSource)
    }

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">transferService</span><span class="hljs-params">()</span></span> = TransferService(accountRepository())
}
</code></pre>
<p>以下示例显示了示例<code>system-test-config.xml</code>文件的一部分：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- enable processing of annotations such as @Autowired and @Configuration --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">context:annotation-config</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">"classpath:/com/acme/jdbc.properties"</span>/&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.acme.AppConfig"</span>/&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"url"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"${jdbc.url}"</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"${jdbc.username}"</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"${jdbc.password}"</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span>
</code></pre>
<p>以下示例显示了可能的<code>jdbc.properties</code>文件:</p>
<pre><code class="language-properties"><span class="hljs-meta">jdbc.url</span>=<span class="hljs-string">jdbc:hsqldb:hsql://localhost/xdb</span>
<span class="hljs-meta">jdbc.username</span>=<span class="hljs-string">sa</span>
<span class="hljs-meta">jdbc.password</span>=<span class="hljs-string"></span>
</code></pre>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
    ApplicationContext ctx = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"classpath:/com/acme/system-test-config.xml"</span>);
    TransferService transferService = ctx.getBean(TransferService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<pre><code class="language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> ctx = ClassPathXmlApplicationContext(<span class="hljs-string">"classpath:/com/acme/system-test-config.xml"</span>)
    <span class="hljs-keyword">val</span> transferService = ctx.getBean&lt;TransferService&gt;()
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>在 <code>system-test-config.xml</code>文件中， <code>AppConfig</code> <code>&lt;bean/&gt;</code>不声明<code>id</code>元素。虽然这样做是可以的，但是没有必要，因为没有其他bean引用它，并且不太可能通过名称从容器中明确地获取它。 类似地，<code>DataSource</code> bean只是按类型自动装配，因此不严格要求显式的bean<code>id</code>。</p>
<p>使用<a href="context:component-scan/">context:component-scan/</a> 来获取<code>@Configuration</code> 类</p>
<p>因为<code>@Configuration</code>是<code>@Component</code>注解的元注解,所以<code>@Configuration</code>注解的类也可以被自动扫描。使用与上面相同的场景，可以重新定义<code>system-test-config.xml</code> 以使用组件扫描。 请注意，在这种情况下，我们不需要显式声明 <code>&lt;context:annotation-config/&gt;</code>,，因为<code>&lt;context:component-scan/&gt;</code> 启用相同的功能。</p>
<p>以下示例显示了已修改的<code>system-test-config.xml</code>文件:</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- picks up and registers AppConfig as a bean definition --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">"com.acme"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">"classpath:/com/acme/jdbc.properties"</span>/&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"url"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"${jdbc.url}"</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"${jdbc.username}"</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"${jdbc.password}"</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span>
</code></pre>
<p><a id="beans-java-combining-java-centric"></a></p>
<h6><a href="#beans-java-combining-java-centric"></a>基于<code>@Configuration</code>混合XML的<code>@ImportResource</code></h6>
<p>在 <code>@Configuration</code>类为配置容器的主要方式的应用程序中,也需要使用一些XML配置。在这些情况下,只需使用<code>@ImportResource</code> ,并只定义所需的XML。这样做可以实现“以Java为中心”的方法来配置容器并尽可能少的使用XML。 以下示例（包括配置类，定义bean的XML文件，属性文件和主类）显示了如何使用<code>@ImportResource</code> 注解来实现根据需要使用XML的“以Java为中心”的配置：</p>
<pre><code class="language-java">@Configuration
@ImportResource("classpath:/com/acme/properties-config.xml")
public class AppConfig {

    @Value("${jdbc.url}")
    private String url;

    @Value("${jdbc.username}")
    private String username;

    @Value("${jdbc.password}")
    private String password;

    @Bean
    public DataSource dataSource() {
        return new DriverManagerDataSource(url, username, password);
    }
}

properties-config.xml
&lt;beans&gt;
    &lt;context:property-placeholder location="classpath:/com/acme/jdbc.properties"/&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="language-kotlin"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@ImportResource(<span class="hljs-meta-string">"classpath:/com/acme/properties-config.xml"</span>)</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>{

    <span class="hljs-meta">@Value(<span class="hljs-meta-string">"\${jdbc.url}"</span>)</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> url: String

    <span class="hljs-meta">@Value(<span class="hljs-meta-string">"\${jdbc.username}"</span>)</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> username: String

    <span class="hljs-meta">@Value(<span class="hljs-meta-string">"\${jdbc.password}"</span>)</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> password: String

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dataSource</span><span class="hljs-params">()</span></span>: DataSource {
        <span class="hljs-keyword">return</span> DriverManagerDataSource(url, username, password)
    }
}
</code></pre>
<pre><code>jdbc.properties
jdbc.url=jdbc:hsqldb:hsql://localhost/xdb
jdbc.username=sa
jdbc.password=
</code></pre>
<pre><code>public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);
    TransferService transferService = ctx.getBean(TransferService.class);
    // ...
}
</code></pre>
<pre><code class="language-kotlin"><span class="hljs-keyword">import</span> org.springframework.beans.factory.getBean

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> ctx = AnnotationConfigApplicationContext(AppConfig::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>)</span>
    <span class="hljs-keyword">val</span> transferService = ctx.getBean&lt;TransferService&gt;()
    <span class="hljs-comment">// ...</span>
}
</code></pre>
</div></section><footer class="footer-container"><div class="footer-body"><img src="/img/jcohy.png"/><div class="cols-container"><div class="col col-12"><p>jia_chao23@126.com</p><p>https://www.github.com/jiachao23</p></div><div class="col col-6"><dl><dt>文档</dt><dd><a href="/zh-cn/docs/springframework/demo.html" target="_self">Spring Framework</a></dd><dd><a href="/zh-cn/docs/springboot/demo.html" target="_self">SpringBoot</a></dd><dd><a href="/zh-cn/docs/microservices/demo.html" target="_self">Microservices</a></dd></dl></div><div class="col col-6"><dl><dt>资源</dt><dd><a href="/zh-cn/blog/index.html" target="_self">博客</a></dd><dd><a href="/zh-cn/open/index.html" target="_self">开源项目</a></dd></dl></div></div><div class="copyright"><span>Copyright © 2019 www.jcohy.com</span></div></div></footer></div></div>
	<script src="https://f.alicdn.com/react/15.4.1/react-with-addons.min.js"></script>
	<script src="https://f.alicdn.com/react/15.4.1/react-dom.min.js"></script>
	<script>
		window.rootPath = '';
  </script>
	<script src="/build/documentation.js"></script>
</body>
</html>

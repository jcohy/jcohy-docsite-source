{
  "filename": "beans-java.md",
  "__html": "<h1>Spring  Framework 中文文档</h1>\n<h3><a href=\"#beans-java\"></a>1.12. 基于Java的容器配置</h3>\n<p>本节介绍如何在Java代码中使用注解来配置Spring容器。 它包括以下主题：:</p>\n<ul>\n<li>\n<p><a href=\"#beans-java-basic-concepts\">基本概念: <code>@Bean</code> 和 <code>@Configuration</code></a></p>\n</li>\n<li>\n<p><a href=\"#beans-java-instantiating-container\">使用<code>AnnotationConfigApplicationContext</code>实例化Spring容器</a></p>\n</li>\n<li>\n<p><a href=\"#beans-java-bean-annotation\">使用<code>@Bean</code>注解</a></p>\n</li>\n<li>\n<p><a href=\"#beans-java-configuration-annotation\">使用<code>@Configuration</code>注解</a></p>\n</li>\n<li>\n<p><a href=\"#beans-java-composing-configuration-classes\">编写基于Java的配置</a></p>\n</li>\n<li>\n<p><a href=\"#beans-definition-profiles\">定义Bean配置文件</a></p>\n</li>\n<li>\n<p><a href=\"#beans-property-source-abstraction\"><code>PropertySource</code> 抽象</a></p>\n</li>\n<li>\n<p><a href=\"#beans-using-propertysource\">使用 <code>@PropertySource</code></a></p>\n</li>\n<li>\n<p><a href=\"#beans-placeholder-resolution-in-statements\">声明中的占位符</a></p>\n</li>\n</ul>\n<p><a id=\"beans-java-basic-concepts\"></a></p>\n<h4><a href=\"#beans-java-basic-concepts\"></a>1.12.1. 基本概念: <code>@Bean</code> 和 <code>@Configuration</code></h4>\n<p>Spring新的基于Java配置的核心内容是<code>@Configuration</code>注解的类和<code>@Bean</code>注解的方法。</p>\n<p><code>@Bean</code>注解用于表明方法的实例化，、配置和初始化都是由Spring IoC容器管理的新对象，对于那些熟悉Spring的<code>&lt;beans/&gt;</code>XML配置的人来说， <code>@Bean</code>注解扮演的角色与<code>&lt;beans/&gt;</code>元素相同。开发者可以在任意的Spring <code>@Component</code>中使用<code>@Bean</code>注解方法 ，但大多数情况下，<code>@Bean</code>是配合<code>@Configuration</code>使用的。</p>\n<p>使用<code>@Configuration</code>注解类时，这个类的目的就是作为bean定义的地方。此外，<code>@Configuration</code>类允许通过调用同一个类中的其他<code>@Bean</code>方法来定义bean间依赖关系。 最简单的<code>@Configuration</code>类如下所示：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AppConfig</span> </span>{\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> MyService <span class=\"hljs-title\">myService</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> MyServiceImpl();\n    }\n}\n</code></pre>\n<p>kotlin:</p>\n<pre><code class=\"language-kotlin\"><span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AppConfig</span> </span>{\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">myService</span><span class=\"hljs-params\">()</span></span>: MyService {\n        <span class=\"hljs-keyword\">return</span> MyServiceImpl()\n    }\n}\n</code></pre>\n<p>前面的<code>AppConfig</code>类等效于以下Spring <code>&lt;beans/&gt;</code>XML：</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">beans</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">bean</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"myService\"</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"com.acme.services.MyServiceImpl\"</span>/&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">beans</span>&gt;</span>\n</code></pre>\n<p>完整的@Configuration模式对比“lite”模式的@Bean?</p>\n<p>当<code>@Bean</code>方法在没有用 <code>@Configuration</code>注解的类中声明时，它们将会被称为“lite”的模式处理。例如，<code>@Component</code>中声明的bean方法或者一个普通的旧类中的bean方法将被视为 “lite”的。包含类的主要目的不同，而<code>@Bean</code>方法在这里是一种额外的好处。。例如，服务组件可以通过在每个适用的组件类上使用额外的 <code>@Bean</code>方法将管理视图公开给容器。 在这种情况下，<code>@Bean</code>方法是一种通用的工厂方法机制。</p>\n<p>与完整的 <code>@Configuration</code>不同，lite的<code>@Bean</code>方法不能声明bean之间的依赖关系。 相反，它们对其包含组件的内部状态进行操作，并且可以有选择的对它们可能声明的参数进行操作。因此，这样的<code>@Bean</code>注解的方法不应该调用其他<code>@Bean</code>注解的方法。 每个这样的方法实际上只是特定bean引用的工厂方法，没有任何特殊的运行时语义。不经过CGLIB处理，所以在类设计方面没有限制（即，包含类可能是最终的）。</p>\n<p>在常见的场景中，<code>@Bean</code>方法将在<code>@Configuration</code>类中声明，确保始终使用“full”模式，这将防止相同的<code>@Bean</code>方法被意外地多次调用，这有助于减少在 “lite”模式下操作时难以跟踪的细微错误。</p>\n<p><code>@Bean</code>和<code>@Configuration</code>注解将在下面的章节深入讨论，首先，我们将介绍使用基于Java代码的配置来创建Spring容器的各种方法。</p>\n<p><a id=\"beans-java-instantiating-container\"></a></p>\n<h4><a href=\"#beans-java-instantiating-container\"></a>1.12.2. 使用<code>AnnotationConfigApplicationContext</code>初始化Spring容器</h4>\n<p>以下部分介绍了Spring的<code>AnnotationConfigApplicationContext</code>，它是在Spring 3.0中引入的。这是一个强大的(versatile)<code>ApplicationContext</code> 实现,它不仅能解析<code>@Configuration</code>注解类 ,也能解析 <code>@Component</code>注解的类和使用JSR-330注解的类.</p>\n<p>当使用<code>@Configuration</code>类作为输入时,<code>@Configuration</code>类本身被注册为一个bean定义,类中所有声明的<code>@Bean</code>方法也被注册为bean定义.</p>\n<p>当提供 <code>@Component</code>和JSR-330类时，它们被注册为bean定义，并且假定在必要时在这些类中使用DI元数据，例如<code>@Autowired</code> 或 <code>@Inject</code>。</p>\n<p><a id=\"beans-java-instantiating-container-contstructor\"></a></p>\n<h5><a href=\"#beans-java-instantiating-container-contstructor\"></a>简单结构</h5>\n<p>与实例化<code>ClassPathXmlApplicationContext</code>时Spring XML文件用作输入的方式大致相同， 在实例化<code>AnnotationConfigApplicationContext</code>时可以使用<code>@Configuration</code> 类作为输入。 这允许完全无XML使用Spring容器，如以下示例所示：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n    ApplicationContext ctx = <span class=\"hljs-keyword\">new</span> AnnotationConfigApplicationContext(AppConfig<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n    MyService myService = ctx.getBean(MyService<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n    myService.doStuff();\n}\n</code></pre>\n<p>kotlin:</p>\n<pre><code class=\"language-kotlin\"><span class=\"hljs-keyword\">import</span> org.springframework.beans.factory.getBean\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n    <span class=\"hljs-keyword\">val</span> ctx = AnnotationConfigApplicationContext(AppConfig::<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span>.<span class=\"hljs-title\">java</span>)</span>\n    <span class=\"hljs-keyword\">val</span> myService = ctx.getBean&lt;MyService&gt;()\n    myService.doStuff()\n}\n</code></pre>\n<p>如前所述，<code>AnnotationConfigApplicationContext</code>不仅限于使用<code>@Configuration</code>类。 任何<code>@Component</code>或JSR-330带注解的类都可以作为输入提供给构造函数，如以下示例所示：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n    ApplicationContext ctx = <span class=\"hljs-keyword\">new</span> AnnotationConfigApplicationContext(MyServiceImpl<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>, <span class=\"hljs-title\">Dependency1</span>.<span class=\"hljs-title\">class</span>, <span class=\"hljs-title\">Dependency2</span>.<span class=\"hljs-title\">class</span>)</span>;\n    MyService myService = ctx.getBean(MyService<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n    myService.doStuff();\n}\n</code></pre>\n<p>kotlin:</p>\n<pre><code class=\"language-kotlin\"><span class=\"hljs-keyword\">import</span> org.springframework.beans.factory.getBean\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n    <span class=\"hljs-keyword\">val</span> ctx = AnnotationConfigApplicationContext(MyServiceImpl::<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span>.<span class=\"hljs-title\">java</span>, <span class=\"hljs-type\">Dependency1::class.java</span>, <span class=\"hljs-type\">Dependency2::class.java)</span></span>\n    <span class=\"hljs-keyword\">val</span> myService = ctx.getBean&lt;MyService&gt;()\n    myService.doStuff()\n}\n</code></pre>\n<p>上面假设<code>MyServiceImpl</code>, <code>Dependency1</code>, 和 <code>Dependency2</code>使用Spring依赖注入注解，例如<code>@Autowired</code>。</p>\n<p><a id=\"beans-java-instantiating-container-register\"></a></p>\n<h5><a href=\"#beans-java-instantiating-container-register\"></a>使用<code>register(Class&lt;?&gt;…)</code>编程构建容器</h5>\n<p><code>AnnotationConfigApplicationContext</code>可以通过无参构造函数实例化，然后调用<code>register()</code> 方法进行配置。 这种方法在以编程的方式构建 <code>AnnotationConfigApplicationContext</code>时特别有用。下列示例显示了如何执行此操作</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n    AnnotationConfigApplicationContext ctx = <span class=\"hljs-keyword\">new</span> AnnotationConfigApplicationContext();\n    ctx.register(AppConfig<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>, <span class=\"hljs-title\">OtherConfig</span>.<span class=\"hljs-title\">class</span>)</span>;\n    ctx.register(AdditionalConfig<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n    ctx.refresh();\n    MyService myService = ctx.getBean(MyService<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n    myService.doStuff();\n}\n</code></pre>\n<pre><code class=\"language-kotlin\"><span class=\"hljs-keyword\">import</span> org.springframework.beans.factory.getBean\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n    <span class=\"hljs-keyword\">val</span> ctx = AnnotationConfigApplicationContext()\n    ctx.register(AppConfig::<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span>.<span class=\"hljs-title\">java</span>, <span class=\"hljs-type\">OtherConfig::class.java)</span></span>\n    ctx.register(AdditionalConfig::<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span>.<span class=\"hljs-title\">java</span>)</span>\n    ctx.refresh()\n    <span class=\"hljs-keyword\">val</span> myService = ctx.getBean&lt;MyService&gt;()\n    myService.doStuff()\n}\n</code></pre>\n<p><a id=\"beans-java-instantiating-container-scan\"></a></p>\n<h5><a href=\"#beans-java-instantiating-container-scan\"></a>3 使用<code>scan(String…)</code>扫描组件</h5>\n<p>要启用组件扫描，可以按如下方式注解<code>@Configuration</code>类:</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-meta\">@ComponentScan</span>(basePackages = <span class=\"hljs-string\">\"com.acme\"</span>) (<span class=\"hljs-number\">1</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AppConfig</span>  </span>{\n    ...\n}\n</code></pre>\n<pre><code class=\"language-kotlin\"><span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-meta\">@ComponentScan(basePackages = [<span class=\"hljs-meta-string\">\"com.acme\"</span>])</span> \n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AppConfig</span>  </span>{\n    <span class=\"hljs-comment\">// ...</span>\n}\n</code></pre>\n<p><strong>1</strong>、此注解可启用组件扫描。</p>\n<p>有经验的用户可能更熟悉使用XML的等价配置形式，如下例所示：</p>\n<pre><code>&lt;beans&gt;\n    &lt;context:component-scan base-package=&quot;com.acme&quot;/&gt;\n&lt;/beans&gt;\n</code></pre>\n<p>上面的例子中，<code>com.acme</code>包会被扫描，只要是使用了<code>@Component</code>注解的类，都会被注册进容器中。同样地，<code>AnnotationConfigApplicationContext</code>公开的<code>scan(String…)</code> 方法也允许扫描类完成同样的功能 如以下示例所示：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n    AnnotationConfigApplicationContext ctx = <span class=\"hljs-keyword\">new</span> AnnotationConfigApplicationContext();\n    ctx.scan(<span class=\"hljs-string\">\"com.acme\"</span>);\n    ctx.refresh();\n    MyService myService = ctx.getBean(MyService<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n}\n</code></pre>\n<pre><code class=\"language-kotlin\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n    <span class=\"hljs-keyword\">val</span> ctx = AnnotationConfigApplicationContext()\n    ctx.scan(<span class=\"hljs-string\">\"com.acme\"</span>)\n    ctx.refresh()\n    <span class=\"hljs-keyword\">val</span> myService = ctx.getBean&lt;MyService&gt;()\n}\n</code></pre>\n<p>请记住<code>@Configuration</code>类是使用<code>@Component</code>进行<a href=\"#beans-meta-annotations\">元注解</a>的，因此它们是组件扫描的候选者。 在前面的示例中， 假设AppConfig在com.acme包（或下面的任何包）中声明，它在<code>scan()</code>调用期间被拾取。 在<code>refresh()</code>之后，它的所有<code>@Bean</code>方法都被处理并在容器中注册为bean定义。</p>\n<p><a id=\"beans-java-instantiating-container-web\"></a></p>\n<h5><a href=\"#beans-java-instantiating-container-web\"></a>使用<code>AnnotationConfigWebApplicationContext</code>支持Web应用程序</h5>\n<p><code>WebApplicationContext</code>与<code>AnnotationConfigApplicationContext</code>的变种是 <code>AnnotationConfigWebApplicationContext</code>配置。这个实现可以用于配置Spring <code>ContextLoaderListener</code> servlet监听器 ，Spring MVC的 <code>DispatcherServlet</code>等等。以下web.xml代码段配置典型的Spring MVC Web应用程序（请注意<code>contextClass</code> context-param和init-param的使用）：</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">web-app</span>&gt;</span>\n    <span class=\"hljs-comment\">&lt;!-- Configure ContextLoaderListener to use AnnotationConfigWebApplicationContext\n        instead of the default XmlWebApplicationContext --&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">context-param</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">param-name</span>&gt;</span>contextClass<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">param-name</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">param-value</span>&gt;</span>\n            org.springframework.web.context.support.AnnotationConfigWebApplicationContext\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">param-value</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">context-param</span>&gt;</span>\n\n    <span class=\"hljs-comment\">&lt;!-- Configuration locations must consist of one or more comma- or space-delimited\n        fully-qualified @Configuration classes. Fully-qualified packages may also be\n        specified for component-scanning --&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">context-param</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">param-name</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">param-value</span>&gt;</span>com.acme.AppConfig<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">param-value</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">context-param</span>&gt;</span>\n\n    <span class=\"hljs-comment\">&lt;!-- Bootstrap the root application context as usual using ContextLoaderListener --&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">listener</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">listener-class</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">listener</span>&gt;</span>\n\n    <span class=\"hljs-comment\">&lt;!-- Declare a Spring MVC DispatcherServlet as usual --&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">servlet</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">servlet-name</span>&gt;</span>dispatcher<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">servlet-name</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">servlet-class</span>&gt;</span>\n        <span class=\"hljs-comment\">&lt;!-- Configure DispatcherServlet to use AnnotationConfigWebApplicationContext\n            instead of the default XmlWebApplicationContext --&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">init-param</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">param-name</span>&gt;</span>contextClass<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">param-name</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">param-value</span>&gt;</span>\n                org.springframework.web.context.support.AnnotationConfigWebApplicationContext\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">param-value</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">init-param</span>&gt;</span>\n        <span class=\"hljs-comment\">&lt;!-- Again, config locations must consist of one or more comma- or space-delimited\n            and fully-qualified @Configuration classes --&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">init-param</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">param-name</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">param-value</span>&gt;</span>com.acme.web.MvcConfig<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">param-value</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">init-param</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">servlet</span>&gt;</span>\n\n    <span class=\"hljs-comment\">&lt;!-- map all requests for /app/* to the dispatcher servlet --&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">servlet-mapping</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">servlet-name</span>&gt;</span>dispatcher<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">servlet-name</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">url-pattern</span>&gt;</span>/app/*<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">url-pattern</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">servlet-mapping</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">web-app</span>&gt;</span>\n</code></pre>\n<p><a id=\"beans-java-bean-annotation\"></a></p>\n<h4><a href=\"#beans-java-bean-annotation\"></a>1.12.3. 使用<code>@Bean</code> 注解</h4>\n<p><code>@Bean</code> @Bean是一个方法级别的注解，它与XML中的 <code>&lt;bean/&gt;</code>元素类似。注解支持 <code>&lt;bean/&gt;</code>提供的一些属性，例如 * <a href=\"#beans-factory-lifecycle-initializingbean\">init-method</a> * <a href=\"#beans-factory-lifecycle-disposablebean\">destroy-method</a> * <a href=\"#beans-factory-autowire\">autowiring</a> * <code>name</code></p>\n<p>开发者可以在<code>@Configuration</code>类或<code>@Component</code>类中使用<code>@Bean</code>注解。</p>\n<p><a id=\"beans-java-declaring-a-bean\"></a></p>\n<h5><a href=\"#beans-java-declaring-a-bean\"></a>声明一个Bean</h5>\n<p>要声明一个bean，只需使用<code>@Bean</code>注解方法即可。使用此方法，将会在<code>ApplicationContext</code>内注册一个bean，bean的类型是方法的返回值类型。默认情况下， bean名称将与方法名称相同。以下示例显示了<code>@Bean</code>方法声明：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AppConfig</span> </span>{\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> TransferServiceImpl <span class=\"hljs-title\">transferService</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> TransferServiceImpl();\n    }\n}\n</code></pre>\n<p>kotlin:</p>\n<pre><code class=\"language-kotlin\"><span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AppConfig</span> </span>{\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">transferService</span><span class=\"hljs-params\">()</span></span> = TransferServiceImpl()\n}\n</code></pre>\n<p>前面的配置完全等同于以下Spring XML:</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">beans</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">bean</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"transferService\"</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"com.acme.TransferServiceImpl\"</span>/&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">beans</span>&gt;</span>\n</code></pre>\n<p>这两个声明都在<code>ApplicationContext</code>中创建一个名为<code>transferService</code>的bean，并且绑定了<code>TransferServiceImpl</code>的实例。如下图所示：</p>\n<pre><code>transferService -&gt; com.acme.TransferServiceImpl\n</code></pre>\n<p>您还可以使用接口（或基类）返回类型声明<code>@Bean</code>方法，如以下示例所示：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AppConfig</span> </span>{\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> TransferService <span class=\"hljs-title\">transferService</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> TransferServiceImpl();\n    }\n}\n</code></pre>\n<pre><code class=\"language-kotlin\"><span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AppConfig</span> </span>{\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">transferService</span><span class=\"hljs-params\">()</span></span>: TransferService {\n        <span class=\"hljs-keyword\">return</span> TransferServiceImpl()\n    }\n}\n</code></pre>\n<p>但是，这会将预先类型预测的可见性限制为指定的接口类型(<code>TransferService</code>),然后在实例化受影响的单一bean时,只知道容器的完整类型(<code>TransferServiceImpl</code>）。 。非延迟的单例bean根据它们的声明顺序进行实例化，因此开发者可能会看到不同类型的匹配结果，这具体取决于另一个组件尝试按未类型匹配的时间(如<code>@Autowired TransferServiceImpl</code>， 一旦<code>transferService</code> bean已被实例化,这个问题就被解决了).</p>\n<p>如果通过声明的服务接口都是引用类型,那么<code>@Bean</code> 返回类型可以安全地加入该设计决策.但是,对于实现多个接口的组件或可能由其实现类型引用的组件, 更安全的方法是声明可能的最具体的返回类型(至少按照注入点所要求的特定你的bean）。</p>\n<p><a id=\"beans-java-dependencies\"></a></p>\n<h5><a href=\"#beans-java-dependencies\"></a>Bean之间的依赖</h5>\n<p>一个使用<code>@Bean</code>注解的方法可以具有任意数量的参数描述构建该bean所需的依赖，例如，如果我们的<code>TransferService</code>需要<code>AccountRepository</code>， 我们可以使用方法参数来实现该依赖关系，如以下示例所示：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AppConfig</span> </span>{\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> TransferService <span class=\"hljs-title\">transferService</span><span class=\"hljs-params\">(AccountRepository accountRepository)</span> </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> TransferServiceImpl(accountRepository);\n    }\n}\n</code></pre>\n<pre><code class=\"language-kotlin\"><span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AppConfig</span> </span>{\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">transferService</span><span class=\"hljs-params\">(accountRepository: <span class=\"hljs-type\">AccountRepository</span>)</span></span>: TransferService {\n        <span class=\"hljs-keyword\">return</span> TransferServiceImpl(accountRepository)\n    }\n}\n</code></pre>\n<p>这个解析机制与基于构造函数的依赖注入非常相似。有关详细信息，请参阅<a href=\"#beans-constructor-injection\">相关部分</a>。</p>\n<p><a id=\"beans-java-lifecycle-callbacks\"></a></p>\n<h5><a href=\"#beans-java-lifecycle-callbacks\"></a>接收生命周期回调</h5>\n<p>使用<code>@Bean</code>注解定义的任何类都支持常规的生命周期回调，并且可以使用JSR-的<code>@PostConstruct</code>和<code>@PreDestroy</code>注解。 有关更多详细信息，请参阅 <a href=\"#beans-postconstruct-and-predestroy-annotations\">JSR-250</a> 注解。</p>\n<p>完全支持常规的Spring<a href=\"#beans-factory-nature\">生命周期</a>回调。 如果bean实现<code>InitializingBean</code>, <code>DisposableBean</code>, 或 <code>Lifecycle</code>，则它们各自的方法由容器调用。</p>\n<p>同样地，还完全支持标准的<code>*Aware</code>，如<a href=\"#beans-beanfactory\">BeanFactoryAware</a>, <a href=\"#beans-factory-aware\">BeanNameAware</a>, <a href=\"#context-functionality-messagesource\">MessageSourceAware</a>, <a href=\"#beans-factory-aware\">ApplicationContextAware</a>。</p>\n<p><code>@Bean</code>注解支持指定任意初始化和销毁回调方法，就像<code>bean</code>元素上的Spring XML的 <code>init-method</code>和<code>destroy-method</code> 属性一样，如下例所示：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BeanOne</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">init</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-comment\">// initialization logic</span>\n    }\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BeanTwo</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">cleanup</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-comment\">// destruction logic</span>\n    }\n}\n\n<span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AppConfig</span> </span>{\n\n    <span class=\"hljs-meta\">@Bean</span>(initMethod = <span class=\"hljs-string\">\"init\"</span>)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> BeanOne <span class=\"hljs-title\">beanOne</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> BeanOne();\n    }\n\n    <span class=\"hljs-meta\">@Bean</span>(destroyMethod = <span class=\"hljs-string\">\"cleanup\"</span>)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> BeanTwo <span class=\"hljs-title\">beanTwo</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> BeanTwo();\n    }\n}\n</code></pre>\n<pre><code class=\"language-kotlin\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BeanOne</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">init</span><span class=\"hljs-params\">()</span></span> {\n        <span class=\"hljs-comment\">// initialization logic</span>\n    }\n}\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BeanTwo</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">cleanup</span><span class=\"hljs-params\">()</span></span> {\n        <span class=\"hljs-comment\">// destruction logic</span>\n    }\n}\n\n<span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AppConfig</span> </span>{\n\n    <span class=\"hljs-meta\">@Bean(initMethod = <span class=\"hljs-meta-string\">\"init\"</span>)</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">beanOne</span><span class=\"hljs-params\">()</span></span> = BeanOne()\n\n    <span class=\"hljs-meta\">@Bean(destroyMethod = <span class=\"hljs-meta-string\">\"cleanup\"</span>)</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">beanTwo</span><span class=\"hljs-params\">()</span></span> = BeanTwo()\n}\n\n</code></pre>\n<p>默认情况下，使用Java Config定义的bean中<code>close</code>方法或者<code>shutdown</code>方法，会作为销毁回调而自动调用。若bean中有<code>close</code> 或 <code>shutdown</code> 方法，并且您不希望在容器关闭时调用它，则可以将<code>@Bean(destroyMethod=&quot;&quot;)</code> 添加到bean定义中以禁用默认<code>(inferred)</code> 模式。</p>\n<p>开发者可能希望对通过JNDI获取的资源执行此操作，因为它的生命周期是在应用程序外部管理的。更进一步，使用 <code>DataSource</code>时一定要关闭它，不关闭将会出问题。</p>\n<p>以下示例说明如何防止<code>DataSource</code>的自动销毁回调：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Bean</span>(destroyMethod=<span class=\"hljs-string\">\"\"</span>)\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> DataSource <span class=\"hljs-title\">dataSource</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> NamingException </span>{\n    <span class=\"hljs-keyword\">return</span> (DataSource) jndiTemplate.lookup(<span class=\"hljs-string\">\"MyDS\"</span>);\n}\n</code></pre>\n<pre><code class=\"language-kotlin\"><span class=\"hljs-meta\">@Bean(destroyMethod = <span class=\"hljs-meta-string\">\"\"</span>)</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">dataSource</span><span class=\"hljs-params\">()</span></span>: DataSource {\n    <span class=\"hljs-keyword\">return</span> jndiTemplate.lookup(<span class=\"hljs-string\">\"MyDS\"</span>) <span class=\"hljs-keyword\">as</span> DataSource\n}\n</code></pre>\n<p>同样地，使用<code>@Bean</code>方法，通常会选择使用程序化的JNDI查找：使用Spring的<code>JndiTemplate</code> / <code>JndiLocatorDelegate</code>帮助类或直接使用JNDI的<code>InitialContext</code> ，但是不要使用<code>JndiObjectFactoryBean</code>的变体，因为它会强制开发者声明一个返回类型作为<code>FactoryBean</code>的类型用于代替实际的目标类型，这会使得交叉引用变得很困难。</p>\n<p>对于前面注解中上面示例中的<code>BeanOne</code>，在构造期间直接调用<code>init()</code>方法同样有效，如下例所示：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AppConfig</span> </span>{\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> BeanOne <span class=\"hljs-title\">beanOne</span><span class=\"hljs-params\">()</span> </span>{\n        BeanOne beanOne = <span class=\"hljs-keyword\">new</span> BeanOne();\n        beanOne.init();\n        <span class=\"hljs-keyword\">return</span> beanOne;\n    }\n\n    <span class=\"hljs-comment\">// ...</span>\n}\n</code></pre>\n<pre><code class=\"language-kotlin\"><span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AppConfig</span> </span>{\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">beanOne</span><span class=\"hljs-params\">()</span></span> = BeanOne().apply {\n        <span class=\"hljs-keyword\">init</span>()\n    }\n\n    <span class=\"hljs-comment\">// ...</span>\n}\n</code></pre>\n<p>当您直接使用Java（new对象那种）工作时，您可以使用对象执行任何您喜欢的操作，并且不必总是依赖于容器生命周期。</p>\n<p><a id=\"beans-java-specifying-bean-scope\"></a></p>\n<h5><a href=\"#beans-java-specifying-bean-scope\"></a>指定Bean范围</h5>\n<p>Spring包含<code>@Scope</code>注解，以便您可以指定bean的范围。</p>\n<p><a id=\"beans-java-available-scopes\"></a></p>\n<h6><a href=\"#beans-java-available-scopes\"></a>使用 <code>@Scope</code> 注解</h6>\n<p>可以使用任意标准的方式为 <code>@Bean</code>注解的bean指定一个作用域，你可以使用<a href=\"#beans-factory-scopes\">Bean Scopes</a>中的任意标准作用域</p>\n<p>默认范围是<code>singleton</code>的，但是可以使用 <code>@Scope</code>注解来覆盖。如下例所示：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyConfiguration</span> </span>{\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-meta\">@Scope</span>(<span class=\"hljs-string\">\"prototype\"</span>)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Encryptor <span class=\"hljs-title\">encryptor</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-comment\">// ...</span>\n    }\n}\n</code></pre>\n<pre><code class=\"language-kotlin\"><span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyConfiguration</span> </span>{\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-meta\">@Scope(<span class=\"hljs-meta-string\">\"prototype\"</span>)</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">encryptor</span><span class=\"hljs-params\">()</span></span>: Encryptor {\n        <span class=\"hljs-comment\">// ...</span>\n    }\n}\n</code></pre>\n<p><a id=\"beans-java-scoped-proxy\"></a></p>\n<h6><a href=\"#beans-java-scoped-proxy\"></a><code>@Scope</code> and <code>scoped-proxy</code></h6>\n<p>Spring提供了一种通过<a href=\"#beans-factory-scopes-other-injection\">scoped proxies</a>处理作用域依赖项的便捷方法。使用XML配置时创建此类代理的最简单方法是<code>&lt;aop:scoped-proxy/&gt;</code>元素。 使用<code>@Scope</code>注解在Java中配置bean提供了与<code>proxyMode</code>属性的等效支持。 默认值为无代理（<code>ScopedProxyMode.NO</code>），但您可以指定<code>ScopedProxyMode.TARGET_CLASS</code> 或 <code>ScopedProxyMode.INTERFACES</code>。</p>\n<p>如果使用Java将XML参考文档（请参阅<a href=\"#beans-factory-scopes-other-injection\">scoped proxies</a>）的作用域代理示例移植到我们的 <code>@Bean</code>，它类似于以下内容：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">// an HTTP Session-scoped bean exposed as a proxy</span>\n<span class=\"hljs-meta\">@Bean</span>\n<span class=\"hljs-meta\">@SessionScope</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> UserPreferences <span class=\"hljs-title\">userPreferences</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> UserPreferences();\n}\n\n<span class=\"hljs-meta\">@Bean</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Service <span class=\"hljs-title\">userService</span><span class=\"hljs-params\">()</span> </span>{\n    UserService service = <span class=\"hljs-keyword\">new</span> SimpleUserService();\n    <span class=\"hljs-comment\">// a reference to the proxied userPreferences bean</span>\n    service.setUserPreferences(userPreferences());\n    <span class=\"hljs-keyword\">return</span> service;\n}\n</code></pre>\n<pre><code class=\"language-kotlin\"><span class=\"hljs-comment\">// an HTTP Session-scoped bean exposed as a proxy</span>\n<span class=\"hljs-meta\">@Bean</span>\n<span class=\"hljs-meta\">@SessionScope</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">userPreferences</span><span class=\"hljs-params\">()</span></span> = UserPreferences()\n\n<span class=\"hljs-meta\">@Bean</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">userService</span><span class=\"hljs-params\">()</span></span>: Service {\n    <span class=\"hljs-keyword\">return</span> SimpleUserService().apply {\n        <span class=\"hljs-comment\">// a reference to the proxied userPreferences bean</span>\n        setUserPreferences(userPreferences()\n    }\n}\n</code></pre>\n<p><a id=\"beans-java-customizing-bean-naming\"></a></p>\n<h5><a href=\"#beans-java-customizing-bean-naming\"></a>自定义Bean命名</h5>\n<p>默认情况下，配置类使用<code>@Bean</code>方法的名称作为结果bean的名称。 但是，可以使用<code>name</code>属性覆盖此功能，如以下示例所示：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AppConfig</span> </span>{\n\n    <span class=\"hljs-meta\">@Bean</span>(name = <span class=\"hljs-string\">\"myThing\"</span>)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Thing <span class=\"hljs-title\">thing</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> Thing();\n    }\n}\n</code></pre>\n<pre><code class=\"language-kotlin\"><span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AppConfig</span> </span>{\n\n    <span class=\"hljs-meta\">@Bean(<span class=\"hljs-meta-string\">\"myThing\"</span>)</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">thing</span><span class=\"hljs-params\">()</span></span> = Thing()\n}\n</code></pre>\n<p><a id=\"beans-java-bean-aliasing\"></a></p>\n<h5><a href=\"#beans-java-bean-aliasing\"></a>bean别名</h5>\n<p>正如<a href=\"#beans-beanname\">Bean的 命名</a>中所讨论的，有时需要为单个bean提供多个名称，也称为bean别名。 <code>@Bean</code>注解的 <code>name</code>属性为此接受String数组。 以下示例显示如何为bean设置多个别名：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AppConfig</span> </span>{\n\n    <span class=\"hljs-meta\">@Bean</span>(name = { <span class=\"hljs-string\">\"dataSource\"</span>, <span class=\"hljs-string\">\"subsystemA-dataSource\"</span>, <span class=\"hljs-string\">\"subsystemB-dataSource\"</span> })\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> DataSource <span class=\"hljs-title\">dataSource</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-comment\">// instantiate, configure and return DataSource bean...</span>\n    }\n}\n</code></pre>\n<pre><code class=\"language-kotlin\"><span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AppConfig</span> </span>{\n\n    <span class=\"hljs-meta\">@Bean(<span class=\"hljs-meta-string\">\"dataSource\"</span>, <span class=\"hljs-meta-string\">\"subsystemA-dataSource\"</span>, <span class=\"hljs-meta-string\">\"subsystemB-dataSource\"</span>)</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">dataSource</span><span class=\"hljs-params\">()</span></span>: DataSource {\n        <span class=\"hljs-comment\">// instantiate, configure and return DataSource bean...</span>\n    }\n}\n</code></pre>\n<p><a id=\"beans-java-bean-description\"></a></p>\n<h5><a href=\"#beans-java-bean-description\"></a>Bean 的描述</h5>\n<p>有时，提供更详细的bean文本描述会很有帮助。 当bean被暴露（可能通过JMX）用于监视目的时，这可能特别有用。</p>\n<p>要向@Bean添加描述，可以使用<a href=\"https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/context/annotation/Description.html\"><code>@Description</code></a>注解，如以下示例所示：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AppConfig</span> </span>{\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-meta\">@Description</span>(<span class=\"hljs-string\">\"Provides a basic example of a bean\"</span>)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Thing <span class=\"hljs-title\">thing</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> Thing();\n    }\n}\n</code></pre>\n<pre><code class=\"language-kotlin\"><span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AppConfig</span> </span>{\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-meta\">@Description(<span class=\"hljs-meta-string\">\"Provides a basic example of a bean\"</span>)</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">thing</span><span class=\"hljs-params\">()</span></span> = Thing()\n}\n</code></pre>\n<p><a id=\"beans-java-configuration-annotation\"></a></p>\n<h4><a href=\"#beans-java-configuration-annotation\"></a>1.12.4. 使用 <code>@Configuration</code> 注解</h4>\n<p><code>@Configuration</code>是一个类级别的注解,表明该类将作为bean定义的元数据配置. <code>@Configuration</code>类会将有<code>@Bean</code>注解的公开方法声明为bean, .在 <code>@Configuration</code>类上调用<code>@Bean</code>方法也可以用于定义bean间依赖关系, 有关一般介绍，请参阅 <a href=\"#beans-java-basic-concepts\">基本概念: <code>@Bean</code> 和 <code>@Configuration</code></a></p>\n<p><a id=\"beans-java-injecting-dependencies\"></a></p>\n<h5><a href=\"#beans-java-injecting-dependencies\"></a>注入内部bean依赖</h5>\n<p>当Bean彼此有依赖关系时,表示依赖关系就像调用另一个bean方法一样简单.如下例所示：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AppConfig</span> </span>{\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> BeanOne <span class=\"hljs-title\">beanOne</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> BeanOne(beanTwo());\n    }\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> BeanTwo <span class=\"hljs-title\">beanTwo</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> BeanTwo();\n    }\n}\n</code></pre>\n<pre><code class=\"language-kotlin\"><span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AppConfig</span> </span>{\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">beanOne</span><span class=\"hljs-params\">()</span></span> = BeanOne(beanTwo())\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">beanTwo</span><span class=\"hljs-params\">()</span></span> = BeanTwo()\n}\n</code></pre>\n<p>在前面的示例中，<code>beanOne</code>通过构造函数注入接收对<code>beanTwo</code>的引用。</p>\n<p>这种声明bean间依赖关系的方法只有在 <code>@Configuration</code> 类中声明<code>@Bean</code>方法时才有效。 您不能使用普通的<code>@Component</code>类声明bean间依赖关系。</p>\n<p><a id=\"beans-java-method-injection\"></a></p>\n<h5><a href=\"#beans-java-method-injection\"></a>查找方法注入</h5>\n<p>如前所述，<a href=\"#beans-factory-method-injection\">查找方法注入</a>是一项很少使用的高级功能。 在单例范围的bean依赖于原型范围的bean的情况下，它很有用。 Java提供了很友好的API来实现这种模式。以下示例显示了如何使用查找方法注入：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">CommandManager</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Object <span class=\"hljs-title\">process</span><span class=\"hljs-params\">(Object commandState)</span> </span>{\n        <span class=\"hljs-comment\">// grab a new instance of the appropriate Command interface</span>\n        Command command = createCommand();\n        <span class=\"hljs-comment\">// set the state on the (hopefully brand new) Command instance</span>\n        command.setState(commandState);\n        <span class=\"hljs-keyword\">return</span> command.execute();\n    }\n\n    <span class=\"hljs-comment\">// okay... but where is the implementation of this method?</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">abstract</span> Command <span class=\"hljs-title\">createCommand</span><span class=\"hljs-params\">()</span></span>;\n}\n</code></pre>\n<pre><code class=\"language-kotlin\"><span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">CommandManager</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">process</span><span class=\"hljs-params\">(commandState: <span class=\"hljs-type\">Any</span>)</span></span>: Any {\n        <span class=\"hljs-comment\">// grab a new instance of the appropriate Command interface</span>\n        <span class=\"hljs-keyword\">val</span> command = createCommand()\n        <span class=\"hljs-comment\">// set the state on the (hopefully brand new) Command instance</span>\n        command.setState(commandState)\n        <span class=\"hljs-keyword\">return</span> command.execute()\n    }\n\n    <span class=\"hljs-comment\">// okay... but where is the implementation of this method?</span>\n    <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">createCommand</span><span class=\"hljs-params\">()</span></span>: Command\n}\n</code></pre>\n<p>通过使用Java配置，您可以创建 <code>CommandManager</code>的子类，其中抽象的 <code>createCommand()</code> 方法被覆盖，以便查找新的（原型）对象。 以下示例显示了如何执行此操作：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Bean</span>\n<span class=\"hljs-meta\">@Scope</span>(<span class=\"hljs-string\">\"prototype\"</span>)\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> AsyncCommand <span class=\"hljs-title\">asyncCommand</span><span class=\"hljs-params\">()</span> </span>{\n    AsyncCommand command = <span class=\"hljs-keyword\">new</span> AsyncCommand();\n    <span class=\"hljs-comment\">// inject dependencies here as required</span>\n    <span class=\"hljs-keyword\">return</span> command;\n}\n\n<span class=\"hljs-meta\">@Bean</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> CommandManager <span class=\"hljs-title\">commandManager</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-comment\">// return new anonymous implementation of CommandManager with command() overridden</span>\n    <span class=\"hljs-comment\">// to return a new prototype Command object</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> CommandManager() {\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> Command <span class=\"hljs-title\">createCommand</span><span class=\"hljs-params\">()</span> </span>{\n            <span class=\"hljs-keyword\">return</span> asyncCommand();\n        }\n    }\n}\n</code></pre>\n<pre><code class=\"language-kotlin\"><span class=\"hljs-meta\">@Bean</span>\n<span class=\"hljs-meta\">@Scope(<span class=\"hljs-meta-string\">\"prototype\"</span>)</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">asyncCommand</span><span class=\"hljs-params\">()</span></span>: AsyncCommand {\n    <span class=\"hljs-keyword\">val</span> command = AsyncCommand()\n    <span class=\"hljs-comment\">// inject dependencies here as required</span>\n    <span class=\"hljs-keyword\">return</span> command\n}\n\n<span class=\"hljs-meta\">@Bean</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">commandManager</span><span class=\"hljs-params\">()</span></span>: CommandManager {\n    <span class=\"hljs-comment\">// return new anonymous implementation of CommandManager with createCommand()</span>\n    <span class=\"hljs-comment\">// overridden to return a new prototype Command object</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">object</span> : CommandManager() {\n        <span class=\"hljs-keyword\">override</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">createCommand</span><span class=\"hljs-params\">()</span></span>: Command {\n            <span class=\"hljs-keyword\">return</span> asyncCommand()\n        }\n    }\n}\n</code></pre>\n<p><a id=\"beans-java-further-information-java-config\"></a></p>\n<h5><a href=\"#beans-java-further-information-java-config\"></a>有关基于Java的配置如何在内部工作的更多信息</h5>\n<p>请考虑以下示例，该示例显示了被调用两次的<code>@Bean</code>注解方法:</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AppConfig</span> </span>{\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> ClientService <span class=\"hljs-title\">clientService1</span><span class=\"hljs-params\">()</span> </span>{\n        ClientServiceImpl clientService = <span class=\"hljs-keyword\">new</span> ClientServiceImpl();\n        clientService.setClientDao(clientDao());\n        <span class=\"hljs-keyword\">return</span> clientService;\n    }\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> ClientService <span class=\"hljs-title\">clientService2</span><span class=\"hljs-params\">()</span> </span>{\n        ClientServiceImpl clientService = <span class=\"hljs-keyword\">new</span> ClientServiceImpl();\n        clientService.setClientDao(clientDao());\n        <span class=\"hljs-keyword\">return</span> clientService;\n    }\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> ClientDao <span class=\"hljs-title\">clientDao</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> ClientDaoImpl();\n    }\n}\n</code></pre>\n<pre><code class=\"language-kotlin\"><span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AppConfig</span> </span>{\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">clientService1</span><span class=\"hljs-params\">()</span></span>: ClientService {\n        <span class=\"hljs-keyword\">return</span> ClientServiceImpl().apply {\n            clientDao = clientDao()\n        }\n    }\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">clientService2</span><span class=\"hljs-params\">()</span></span>: ClientService {\n        <span class=\"hljs-keyword\">return</span> ClientServiceImpl().apply {\n            clientDao = clientDao()\n        }\n    }\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">clientDao</span><span class=\"hljs-params\">()</span></span>: ClientDao {\n        <span class=\"hljs-keyword\">return</span> ClientDaoImpl()\n    }\n}\n</code></pre>\n<p><code>clientDao()</code>在<code>clientService1()</code>中调用一次，在<code>clientService2()</code>中调用一次。由于此方法创建了<code>ClientDaoImpl</code>的新实例并将其返回，因此通常希望有两个实例（每个服务一个）。 这肯定会有问题：在Spring中，实例化的bean默认具有<code>singleton</code>范围。这就是它的神奇之处:所有<code>@Configuration</code>类在启动时都使用 <code>CGLIB</code>进行子类化。 在子类中，子方法在调用父方法并创建新实例之前，首先检查容器是否有任何缓存（作用域）bean。</p>\n<p>这种行为可以根据bean的作用域而变化,我们这里只是讨论单例.</p>\n<p>从Spring 3.2开始，不再需要将CGLIB添加到类路径中，因为CGLIB类已经在<code>org.springframework.cglib</code>下重新打包并直接包含在spring-core JAR中。</p>\n<p>由于CGLIB在启动时动态添加功能，因此存在一些限制。 特别是，配置类不能是 final的。 但是，从4.3开始，配置类允许使用任何构造函数，包括使用<code>@Autowired</code>或单个非默认构造函数声明进行默认注入。</p>\n<p>如果想避免因CGLIB带来的限制,请考虑声明非<code>@Configuration</code>类的<code>@Bean</code>方法，例如在纯的<code>@Component</code>类 .这样在<code>@Bean</code>方法之间的交叉方法调用将不会被拦截,此时必须在构造函数或方法级别上进行依赖注入。</p>\n<p><a id=\"beans-java-composing-configuration-classes\"></a></p>\n<h4><a href=\"#beans-java-composing-configuration-classes\"></a>1.12.5. 编写基于Java的配置</h4>\n<p>Spring的基于Java的配置功能允许您撰写注解，这可以降低配置的复杂性。</p>\n<p><a id=\"beans-java-using-import\"></a></p>\n<h5><a href=\"#beans-java-using-import\"></a>使用<code>@Import</code> 注解</h5>\n<p>就像在Spring XML文件中使用<code>&lt;import/&gt;</code>元素来帮助模块化配置一样，<code>@Import</code> 注解允许从另一个配置类加载<code>@Bean</code>定义，如下例所示：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ConfigA</span> </span>{\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> A <span class=\"hljs-title\">a</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> A();\n    }\n}\n\n<span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-meta\">@Import</span>(ConfigA<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)\n<span class=\"hljs-title\">public</span> <span class=\"hljs-title\">class</span> <span class=\"hljs-title\">ConfigB</span> </span>{\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> B <span class=\"hljs-title\">b</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> B();\n    }\n}\n</code></pre>\n<pre><code class=\"language-kotlin\"><span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ConfigA</span> </span>{\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">a</span><span class=\"hljs-params\">()</span></span> = A()\n}\n\n<span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-meta\">@Import(ConfigA::class)</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ConfigB</span> </span>{\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">b</span><span class=\"hljs-params\">()</span></span> = B()\n}\n</code></pre>\n<p>现在，在实例化上下文时，不需要同时指定<code>ConfigA.class</code>和 <code>ConfigB.class</code>，只需要显式提供<code>ConfigB</code>，如下例所示：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n    ApplicationContext ctx = <span class=\"hljs-keyword\">new</span> AnnotationConfigApplicationContext(ConfigB<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n\n    <span class=\"hljs-comment\">// now both beans A and B will be available...</span>\n    A a = ctx.getBean(A<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n    B b = ctx.getBean(B<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n}\n</code></pre>\n<pre><code class=\"language-kotlin\"><span class=\"hljs-keyword\">import</span> org.springframework.beans.factory.getBean\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n    <span class=\"hljs-keyword\">val</span> ctx = AnnotationConfigApplicationContext(ConfigB::<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span>.<span class=\"hljs-title\">java</span>)</span>\n\n    <span class=\"hljs-comment\">// now both beans A and B will be available...</span>\n    <span class=\"hljs-keyword\">val</span> a = ctx.getBean&lt;A&gt;()\n    <span class=\"hljs-keyword\">val</span> b = ctx.getBean&lt;B&gt;()\n}\n</code></pre>\n<p>这种方法简化了容器实例化，因为只需要处理一个类，而不是要求您在构造期间记住可能大量的<code>@Configuration</code>类。</p>\n<p>从Spring Framework 4.2开始，<code>@Import</code>还支持引用常规组件类，类似于<code>AnnotationConfigApplicationContext.register</code>方法。 如果要避免组件扫描，这一点特别有用，可以使用一些配置类作为明确定义所有组件的入口点。</p>\n<p><a id=\"beans-java-injecting-imported-beans\"></a></p>\n<h6><a href=\"#beans-java-injecting-imported-beans\"></a>在导入的<code>@Bean</code>定义上注入依赖项</h6>\n<p>上面的例子可以运行,,但是太简单了。在大多数实际情况下，bean将在配置类之间相互依赖.在使用XML时,这本身不是问题,因为没有涉及到编译器. 可以简单地声明 <code>ref=&quot;someBean&quot;</code>,并且相信Spring将在容器初始化期间可以很好地处理它。当然，当使用<code>@Configuration</code>类时，Java编译器会有一些限制 ，即需符合Java的语法。</p>\n<p>幸运的是，解决这个问题很简单。正如我们<a href=\"#beans-java-dependencies\">已经讨论过</a>的，<code>@Bean</code>方法可以有任意数量的参数来描述bean的依赖关系。 考虑以下更多真实场景，其中包含几个 <code>@Configuration</code>类，每个类都取决于其他类中声明的bean：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ServiceConfig</span> </span>{\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> TransferService <span class=\"hljs-title\">transferService</span><span class=\"hljs-params\">(AccountRepository accountRepository)</span> </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> TransferServiceImpl(accountRepository);\n    }\n}\n\n<span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">RepositoryConfig</span> </span>{\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> AccountRepository <span class=\"hljs-title\">accountRepository</span><span class=\"hljs-params\">(DataSource dataSource)</span> </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> JdbcAccountRepository(dataSource);\n    }\n}\n\n<span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-meta\">@Import</span>({ServiceConfig<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>, <span class=\"hljs-title\">RepositoryConfig</span>.<span class=\"hljs-title\">class</span>})\n<span class=\"hljs-title\">public</span> <span class=\"hljs-title\">class</span> <span class=\"hljs-title\">SystemTestConfig</span> </span>{\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> DataSource <span class=\"hljs-title\">dataSource</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-comment\">// return new DataSource</span>\n    }\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n    ApplicationContext ctx = <span class=\"hljs-keyword\">new</span> AnnotationConfigApplicationContext(SystemTestConfig<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n    <span class=\"hljs-comment\">// everything wires up across configuration classes...</span>\n    TransferService transferService = ctx.getBean(TransferService<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n    transferService.transfer(<span class=\"hljs-number\">100.00</span>, <span class=\"hljs-string\">\"A123\"</span>, <span class=\"hljs-string\">\"C456\"</span>);\n}\n</code></pre>\n<pre><code class=\"language-kotlin\"><span class=\"hljs-keyword\">import</span> org.springframework.beans.factory.getBean\n\n<span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ServiceConfig</span> </span>{\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">transferService</span><span class=\"hljs-params\">(accountRepository: <span class=\"hljs-type\">AccountRepository</span>)</span></span>: TransferService {\n        <span class=\"hljs-keyword\">return</span> TransferServiceImpl(accountRepository)\n    }\n}\n\n<span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">RepositoryConfig</span> </span>{\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">accountRepository</span><span class=\"hljs-params\">(dataSource: <span class=\"hljs-type\">DataSource</span>)</span></span>: AccountRepository {\n        <span class=\"hljs-keyword\">return</span> JdbcAccountRepository(dataSource)\n    }\n}\n\n<span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-meta\">@Import(ServiceConfig::class, RepositoryConfig::class)</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SystemTestConfig</span> </span>{\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">dataSource</span><span class=\"hljs-params\">()</span></span>: DataSource {\n        <span class=\"hljs-comment\">// return new DataSource</span>\n    }\n}\n\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n    <span class=\"hljs-keyword\">val</span> ctx = AnnotationConfigApplicationContext(SystemTestConfig::<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span>.<span class=\"hljs-title\">java</span>)</span>\n    <span class=\"hljs-comment\">// everything wires up across configuration classes...</span>\n    <span class=\"hljs-keyword\">val</span> transferService = ctx.getBean&lt;TransferService&gt;()\n    transferService.transfer(<span class=\"hljs-number\">100.00</span>, <span class=\"hljs-string\">\"A123\"</span>, <span class=\"hljs-string\">\"C456\"</span>)\n}\n</code></pre>\n<p>还有另一种方法可以达到相同的效果。请记住，<code>@Configuration</code>类最终只是容器中的另一个bean： 这意味着它们可以利用<code>@Autowired</code> 和 <code>@Value</code> 注入以及与任何其他bean相同的其他功能。</p>\n<p>确保以这种方式注入的依赖项只是最简单的。<code>@Configuration</code>类在上下文初始化期间很早就被处理，并且强制以这种方式注入依赖项可能会导致意外的早期初始化。 尽可能采用基于参数的注入，如前面的示例所示。</p>\n<p>另外，要特别注意通过<code>@Bean</code>的<code>BeanPostProcessor</code> 和 <code>BeanFactoryPostProcessor</code>定义。 这些通常应该声明为静态<code>@Bean</code>方法，而不是触发其包含配置类的实例化。否则，<code>@Autowired</code> 和 <code>@Value</code>不能在配置类本身上工作，因为它过早地被创建为bean实例。</p>\n<p>以下示例显示了如何将一个bean自动连接到另一个bean:</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ServiceConfig</span> </span>{\n\n    <span class=\"hljs-meta\">@Autowired</span>\n    <span class=\"hljs-keyword\">private</span> AccountRepository accountRepository;\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> TransferService <span class=\"hljs-title\">transferService</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> TransferServiceImpl(accountRepository);\n    }\n}\n\n<span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">RepositoryConfig</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> DataSource dataSource;\n\n    <span class=\"hljs-meta\">@Autowired</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">RepositoryConfig</span><span class=\"hljs-params\">(DataSource dataSource)</span> </span>{\n        <span class=\"hljs-keyword\">this</span>.dataSource = dataSource;\n    }\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> AccountRepository <span class=\"hljs-title\">accountRepository</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> JdbcAccountRepository(dataSource);\n    }\n}\n\n<span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-meta\">@Import</span>({ServiceConfig<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>, <span class=\"hljs-title\">RepositoryConfig</span>.<span class=\"hljs-title\">class</span>})\n<span class=\"hljs-title\">public</span> <span class=\"hljs-title\">class</span> <span class=\"hljs-title\">SystemTestConfig</span> </span>{\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> DataSource <span class=\"hljs-title\">dataSource</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-comment\">// return new DataSource</span>\n    }\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n    ApplicationContext ctx = <span class=\"hljs-keyword\">new</span> AnnotationConfigApplicationContext(SystemTestConfig<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n    <span class=\"hljs-comment\">// everything wires up across configuration classes...</span>\n    TransferService transferService = ctx.getBean(TransferService<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n    transferService.transfer(<span class=\"hljs-number\">100.00</span>, <span class=\"hljs-string\">\"A123\"</span>, <span class=\"hljs-string\">\"C456\"</span>);\n}\n</code></pre>\n<pre><code class=\"language-kotlin\"><span class=\"hljs-keyword\">import</span> org.springframework.beans.factory.getBean\n\n<span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ServiceConfig</span> </span>{\n\n    <span class=\"hljs-meta\">@Autowired</span>\n    <span class=\"hljs-keyword\">lateinit</span> <span class=\"hljs-keyword\">var</span> accountRepository: AccountRepository\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">transferService</span><span class=\"hljs-params\">()</span></span>: TransferService {\n        <span class=\"hljs-keyword\">return</span> TransferServiceImpl(accountRepository)\n    }\n}\n\n<span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">RepositoryConfig</span></span>(<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">val</span> dataSource: DataSource) {\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">accountRepository</span><span class=\"hljs-params\">()</span></span>: AccountRepository {\n        <span class=\"hljs-keyword\">return</span> JdbcAccountRepository(dataSource)\n    }\n}\n\n<span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-meta\">@Import(ServiceConfig::class, RepositoryConfig::class)</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SystemTestConfig</span> </span>{\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">dataSource</span><span class=\"hljs-params\">()</span></span>: DataSource {\n        <span class=\"hljs-comment\">// return new DataSource</span>\n    }\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n    <span class=\"hljs-keyword\">val</span> ctx = AnnotationConfigApplicationContext(SystemTestConfig::<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span>.<span class=\"hljs-title\">java</span>)</span>\n    <span class=\"hljs-comment\">// everything wires up across configuration classes...</span>\n    <span class=\"hljs-keyword\">val</span> transferService = ctx.getBean&lt;TransferService&gt;()\n    transferService.transfer(<span class=\"hljs-number\">100.00</span>, <span class=\"hljs-string\">\"A123\"</span>, <span class=\"hljs-string\">\"C456\"</span>)\n}\n</code></pre>\n<p>仅在Spring Framework 4.3中支持<code>@Configuration</code>类中的构造函数注入。 另请注意，如果目标bean仅定义了一个构造函数，则无需指定<code>@Autowired</code>。 在前面的示例中，<code>RepositoryConfig</code>构造函数中不需要<code>@Autowired</code>。</p>\n<p>完全导入bean便于查找</p>\n<p>在上面的场景中,<code>@Autowired</code>可以很好的工作,使设计更具模块化,但是自动注入哪个bean依然有些模糊不清.例如, 作为一个开发者查看<code>ServiceConfig</code>类时,你怎么知道<code>@Autowired AccountRepository</code>在哪定义的呢?代码中并未明确指出, 还好, <a href=\"https://spring.io/tools/sts\">Spring Tool Suite</a>提供的工具可以呈现图表，显示所有内容的连线方式，这可能就是您所需要的。 此外，您的Java IDE可以轻松找到<code>AccountRepository</code>类型的所有声明和用法，并快速显示返回该类型的<code>@Bean</code>方法的位置。</p>\n<p>万一需求不允许这种模糊的装配,并且您希望从IDE中从一个<code>@Configuration</code>类直接导航到另一个<code>@Configuration</code>类，请考虑自动装配配置类本身。 以下示例显示了如何执行此操作：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ServiceConfig</span> </span>{\n\n    <span class=\"hljs-meta\">@Autowired</span>\n    <span class=\"hljs-keyword\">private</span> RepositoryConfig repositoryConfig;\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> TransferService <span class=\"hljs-title\">transferService</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-comment\">// navigate 'through' the config class to the @Bean method!</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> TransferServiceImpl(repositoryConfig.accountRepository());\n    }\n}\n</code></pre>\n<pre><code class=\"language-kotlin\"><span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ServiceConfig</span> </span>{\n\n    <span class=\"hljs-meta\">@Autowired</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">lateinit</span> <span class=\"hljs-keyword\">var</span> repositoryConfig: RepositoryConfig\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">transferService</span><span class=\"hljs-params\">()</span></span>: TransferService {\n        <span class=\"hljs-comment\">// navigate 'through' the config class to the @Bean method!</span>\n        <span class=\"hljs-keyword\">return</span> TransferServiceImpl(repositoryConfig.accountRepository())\n    }\n}\n</code></pre>\n<p>在前面的情况中，定义<code>AccountRepository</code> 是完全明确的。但是，<code>ServiceConfig</code>现在与<code>RepositoryConfig</code>紧密耦合。这是一种权衡的方法。 通过使用基于接口的或基于类的抽象<code>@Configuration</code> 类，可以在某种程度上减轻这种紧密耦合。请考虑以下示例：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ServiceConfig</span> </span>{\n\n    <span class=\"hljs-meta\">@Autowired</span>\n    <span class=\"hljs-keyword\">private</span> RepositoryConfig repositoryConfig;\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> TransferService <span class=\"hljs-title\">transferService</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> TransferServiceImpl(repositoryConfig.accountRepository());\n    }\n}\n\n<span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">RepositoryConfig</span> </span>{\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\">AccountRepository <span class=\"hljs-title\">accountRepository</span><span class=\"hljs-params\">()</span></span>;\n}\n\n<span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DefaultRepositoryConfig</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">RepositoryConfig</span> </span>{\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> AccountRepository <span class=\"hljs-title\">accountRepository</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> JdbcAccountRepository(...);\n    }\n}\n\n<span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-meta\">@Import</span>({ServiceConfig<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>, <span class=\"hljs-title\">DefaultRepositoryConfig</span>.<span class=\"hljs-title\">class</span>})  // <span class=\"hljs-title\">import</span> <span class=\"hljs-title\">the</span> <span class=\"hljs-title\">concrete</span> <span class=\"hljs-title\">config</span>!\n<span class=\"hljs-title\">public</span> <span class=\"hljs-title\">class</span> <span class=\"hljs-title\">SystemTestConfig</span> </span>{\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> DataSource <span class=\"hljs-title\">dataSource</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-comment\">// return DataSource</span>\n    }\n\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n    ApplicationContext ctx = <span class=\"hljs-keyword\">new</span> AnnotationConfigApplicationContext(SystemTestConfig<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n    TransferService transferService = ctx.getBean(TransferService<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n    transferService.transfer(<span class=\"hljs-number\">100.00</span>, <span class=\"hljs-string\">\"A123\"</span>, <span class=\"hljs-string\">\"C456\"</span>);\n}\n</code></pre>\n<pre><code class=\"language-kotlin\"><span class=\"hljs-keyword\">import</span> org.springframework.beans.factory.getBean\n\n<span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ServiceConfig</span> </span>{\n\n    <span class=\"hljs-meta\">@Autowired</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">lateinit</span> <span class=\"hljs-keyword\">var</span> repositoryConfig: RepositoryConfig\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">transferService</span><span class=\"hljs-params\">()</span></span>: TransferService {\n        <span class=\"hljs-keyword\">return</span> TransferServiceImpl(repositoryConfig.accountRepository())\n    }\n}\n\n<span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">RepositoryConfig</span> </span>{\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">accountRepository</span><span class=\"hljs-params\">()</span></span>: AccountRepository\n}\n\n<span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DefaultRepositoryConfig</span> : <span class=\"hljs-type\">RepositoryConfig {</span></span>\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">accountRepository</span><span class=\"hljs-params\">()</span></span>: AccountRepository {\n        <span class=\"hljs-keyword\">return</span> JdbcAccountRepository(...)\n    }\n}\n\n<span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-meta\">@Import(ServiceConfig::class, DefaultRepositoryConfig::class)</span>  <span class=\"hljs-comment\">// import the concrete config!</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SystemTestConfig</span> </span>{\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">dataSource</span><span class=\"hljs-params\">()</span></span>: DataSource {\n        <span class=\"hljs-comment\">// return DataSource</span>\n    }\n\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n    <span class=\"hljs-keyword\">val</span> ctx = AnnotationConfigApplicationContext(SystemTestConfig::<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span>.<span class=\"hljs-title\">java</span>)</span>\n    <span class=\"hljs-keyword\">val</span> transferService = ctx.getBean&lt;TransferService&gt;()\n    transferService.transfer(<span class=\"hljs-number\">100.00</span>, <span class=\"hljs-string\">\"A123\"</span>, <span class=\"hljs-string\">\"C456\"</span>)\n}\n</code></pre>\n<p>现在，<code>ServiceConfig</code>与具体的<code>DefaultRepositoryConfig</code>松散耦合，内置的IDE工具仍然很有用：您可以很容易获取<code>RepositoryConfig</code>实现类的继承体系。 以这种方式,操作<code>@Configuration</code>类及其依赖关系与操作基于接口的代码的过程没有什么区别</p>\n<p>如果要影响某些bean的启动创建顺序，可以考虑将其中一些声明为<code>@Lazy</code> （用于在首次访问时创建而不是在启动时）或<code>@DependsOn</code>某些其他bean（确保在创建之前创建特定的其他bean（当前的bean，超出后者的直接依赖性所暗示的））。</p>\n<p><a id=\"beans-java-conditional\"></a></p>\n<h5><a href=\"#beans-java-conditional\"></a>有条件地包含<code>@Configuration</code>类或<code>@Bean</code>方法</h5>\n<p>基于某些任意系统状态，有条件地启用或禁用完整的<code>@Configuration</code>类甚至单独的 <code>@Bean</code> 方法通常很有用。 一个常见的例子是， 只有在Spring环境中启用了特定的配置文件时才使用<code>@Profile</code> 注解来激活bean（有关详细信息，请参阅Bean<a href=\"#beans-definition-profiles\">定义配置文件</a>）。</p>\n<p><code>@Profile</code>注解实际上是通过使用更灵活的注解<code>@Conditional</code>实现的。<a href=\"https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/context/annotation/Conditional.html\"><code>@Conditional</code></a>注解表示特定的<code>org.springframework.context.annotation.Condition</code>实现。 它表明<code>@Bean</code>被注册之前会先&quot;询问&quot;<code>@Conditional</code>注解。</p>\n<p><code>Condition</code>接口的实现提供了一个返回<code>true</code> 或 <code>false</code>的<code>matches(…)</code>方法。例如，以下清单显示了用于 <code>@Profile</code>的实际<code>Condition</code>实现：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Override</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">matches</span><span class=\"hljs-params\">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>{\n    <span class=\"hljs-keyword\">if</span> (context.getEnvironment() != <span class=\"hljs-keyword\">null</span>) {\n        <span class=\"hljs-comment\">// Read the @Profile annotation attributes</span>\n        MultiValueMap&lt;String, Object&gt; attrs = metadata.getAllAnnotationAttributes(Profile<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>.<span class=\"hljs-title\">getName</span>())</span>;\n        <span class=\"hljs-keyword\">if</span> (attrs != <span class=\"hljs-keyword\">null</span>) {\n            <span class=\"hljs-keyword\">for</span> (Object value : attrs.get(<span class=\"hljs-string\">\"value\"</span>)) {\n                <span class=\"hljs-keyword\">if</span> (context.getEnvironment().acceptsProfiles(((String[]) value))) {\n                    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\n                }\n            }\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n        }\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\n}\n</code></pre>\n<pre><code class=\"language-kotlin\"><span class=\"hljs-keyword\">override</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">matches</span><span class=\"hljs-params\">(context: <span class=\"hljs-type\">ConditionContext</span>, metadata: <span class=\"hljs-type\">AnnotatedTypeMetadata</span>)</span></span>: <span class=\"hljs-built_in\">Boolean</span> {\n    <span class=\"hljs-comment\">// Read the @Profile annotation attributes</span>\n    <span class=\"hljs-keyword\">val</span> attrs = metadata.getAllAnnotationAttributes(Profile::<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span>.<span class=\"hljs-title\">java</span>.<span class=\"hljs-title\">name</span>)</span>\n    <span class=\"hljs-keyword\">if</span> (attrs != <span class=\"hljs-literal\">null</span>) {\n        <span class=\"hljs-keyword\">for</span> (value <span class=\"hljs-keyword\">in</span> attrs[<span class=\"hljs-string\">\"value\"</span>]!!) {\n            <span class=\"hljs-keyword\">if</span> (context.environment.acceptsProfiles(Profiles .of(*value <span class=\"hljs-keyword\">as</span> Array&lt;String&gt;))) {\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>\n            }\n        }\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>\n}\n</code></pre>\n<p>有关更多详细信息，请参阅<a href=\"https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/context/annotation/Conditional.html\"><code>@Conditional</code></a>javadoc。</p>\n<p><a id=\"beans-java-combining\"></a></p>\n<h5><a href=\"#beans-java-combining\"></a>结合Java和XML配置</h5>\n<p>Spring的<code>@Configuration</code>类支持但不一定成为Spring XML的100％完全替代品。 某些工具（如Spring XML命名空间）仍然是配置容器的理想方法。在XML方便或必要的情况下，您可以选择：通过使用例如<code>ClassPathXmlApplicationContext</code>以“以XML为中心”的方式实例化容器， 或者通过使用<code>AnnotationConfigApplicationContext</code>以“以Java为中心”的方式实例化它。<code>@ImportResource</code>注解，根据需要导入XML。</p>\n<p><a id=\"beans-java-combining-xml-centric\"></a></p>\n<h6><a href=\"#beans-java-combining-xml-centric\"></a>以XML为中心使用<code>@Configuration</code>类</h6>\n<p>更受人喜爱的方法是从包含<code>@Configuration</code>类的XML启动容器.例如，在使用Spring的现有系统中,大量使用的是Spring XML配置,所以很容易根据需要创建<code>@Configuration</code>类 ,并将他们到包含XML文件中。我们将介绍在这种“以XML为中心”的情况下使用<code>@Configuration</code>类的选项。</p>\n<p>将<code>@Configuration</code>类声明为普通的Spring<code>&lt;bean/&gt;</code> 元素</p>\n<p>请记住,<code>@Configuration</code>类最终也只是容器中的bean定义。在本系列示例中，我们创建一个名为AppConfig的<code>@Configuration</code>类，并将其作为<code>&lt;bean/&gt;</code>定义包含在<code>system-test-config.xml</code>中。 由于 <code>&lt;context:annotation-config/&gt;</code>已打开，容器会识别<code>@Configuration</code> 注解并正确处理<code>AppConfig</code>中声明的<code>@Bean</code> 方法。</p>\n<p>以下示例显示了Java中的普通配置类:</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AppConfig</span> </span>{\n\n    <span class=\"hljs-meta\">@Autowired</span>\n    <span class=\"hljs-keyword\">private</span> DataSource dataSource;\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> AccountRepository <span class=\"hljs-title\">accountRepository</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> JdbcAccountRepository(dataSource);\n    }\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> TransferService <span class=\"hljs-title\">transferService</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> TransferService(accountRepository());\n    }\n}\n</code></pre>\n<pre><code class=\"language-kotlin\"><span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AppConfig</span> </span>{\n\n    <span class=\"hljs-meta\">@Autowired</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">lateinit</span> <span class=\"hljs-keyword\">var</span> dataSource: DataSource\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">accountRepository</span><span class=\"hljs-params\">()</span></span>: AccountRepository {\n        <span class=\"hljs-keyword\">return</span> JdbcAccountRepository(dataSource)\n    }\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">transferService</span><span class=\"hljs-params\">()</span></span> = TransferService(accountRepository())\n}\n</code></pre>\n<p>以下示例显示了示例<code>system-test-config.xml</code>文件的一部分：</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">beans</span>&gt;</span>\n    <span class=\"hljs-comment\">&lt;!-- enable processing of annotations such as @Autowired and @Configuration --&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">context:annotation-config</span>/&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">context:property-placeholder</span> <span class=\"hljs-attr\">location</span>=<span class=\"hljs-string\">\"classpath:/com/acme/jdbc.properties\"</span>/&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">bean</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"com.acme.AppConfig\"</span>/&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">bean</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"org.springframework.jdbc.datasource.DriverManagerDataSource\"</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">property</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"url\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"${jdbc.url}\"</span>/&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">property</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"username\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"${jdbc.username}\"</span>/&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">property</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"password\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"${jdbc.password}\"</span>/&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">bean</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">beans</span>&gt;</span>\n</code></pre>\n<p>以下示例显示了可能的<code>jdbc.properties</code>文件:</p>\n<pre><code class=\"language-properties\"><span class=\"hljs-meta\">jdbc.url</span>=<span class=\"hljs-string\">jdbc:hsqldb:hsql://localhost/xdb</span>\n<span class=\"hljs-meta\">jdbc.username</span>=<span class=\"hljs-string\">sa</span>\n<span class=\"hljs-meta\">jdbc.password</span>=<span class=\"hljs-string\"></span>\n</code></pre>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n    ApplicationContext ctx = <span class=\"hljs-keyword\">new</span> ClassPathXmlApplicationContext(<span class=\"hljs-string\">\"classpath:/com/acme/system-test-config.xml\"</span>);\n    TransferService transferService = ctx.getBean(TransferService<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n    <span class=\"hljs-comment\">// ...</span>\n}\n</code></pre>\n<pre><code class=\"language-kotlin\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n    <span class=\"hljs-keyword\">val</span> ctx = ClassPathXmlApplicationContext(<span class=\"hljs-string\">\"classpath:/com/acme/system-test-config.xml\"</span>)\n    <span class=\"hljs-keyword\">val</span> transferService = ctx.getBean&lt;TransferService&gt;()\n    <span class=\"hljs-comment\">// ...</span>\n}\n</code></pre>\n<p>在 <code>system-test-config.xml</code>文件中， <code>AppConfig</code> <code>&lt;bean/&gt;</code>不声明<code>id</code>元素。虽然这样做是可以的，但是没有必要，因为没有其他bean引用它，并且不太可能通过名称从容器中明确地获取它。 类似地，<code>DataSource</code> bean只是按类型自动装配，因此不严格要求显式的bean<code>id</code>。</p>\n<p>使用<a href=\"context:component-scan/\">context:component-scan/</a> 来获取<code>@Configuration</code> 类</p>\n<p>因为<code>@Configuration</code>是<code>@Component</code>注解的元注解,所以<code>@Configuration</code>注解的类也可以被自动扫描。使用与上面相同的场景，可以重新定义<code>system-test-config.xml</code> 以使用组件扫描。 请注意，在这种情况下，我们不需要显式声明 <code>&lt;context:annotation-config/&gt;</code>,，因为<code>&lt;context:component-scan/&gt;</code> 启用相同的功能。</p>\n<p>以下示例显示了已修改的<code>system-test-config.xml</code>文件:</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">beans</span>&gt;</span>\n    <span class=\"hljs-comment\">&lt;!-- picks up and registers AppConfig as a bean definition --&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">context:component-scan</span> <span class=\"hljs-attr\">base-package</span>=<span class=\"hljs-string\">\"com.acme\"</span>/&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">context:property-placeholder</span> <span class=\"hljs-attr\">location</span>=<span class=\"hljs-string\">\"classpath:/com/acme/jdbc.properties\"</span>/&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">bean</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"org.springframework.jdbc.datasource.DriverManagerDataSource\"</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">property</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"url\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"${jdbc.url}\"</span>/&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">property</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"username\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"${jdbc.username}\"</span>/&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">property</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"password\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"${jdbc.password}\"</span>/&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">bean</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">beans</span>&gt;</span>\n</code></pre>\n<p><a id=\"beans-java-combining-java-centric\"></a></p>\n<h6><a href=\"#beans-java-combining-java-centric\"></a>基于<code>@Configuration</code>混合XML的<code>@ImportResource</code></h6>\n<p>在 <code>@Configuration</code>类为配置容器的主要方式的应用程序中,也需要使用一些XML配置。在这些情况下,只需使用<code>@ImportResource</code> ,并只定义所需的XML。这样做可以实现“以Java为中心”的方法来配置容器并尽可能少的使用XML。 以下示例（包括配置类，定义bean的XML文件，属性文件和主类）显示了如何使用<code>@ImportResource</code> 注解来实现根据需要使用XML的“以Java为中心”的配置：</p>\n<pre><code class=\"language-java\">@Configuration\n@ImportResource(\"classpath:/com/acme/properties-config.xml\")\npublic class AppConfig {\n\n    @Value(\"${jdbc.url}\")\n    private String url;\n\n    @Value(\"${jdbc.username}\")\n    private String username;\n\n    @Value(\"${jdbc.password}\")\n    private String password;\n\n    @Bean\n    public DataSource dataSource() {\n        return new DriverManagerDataSource(url, username, password);\n    }\n}\n\nproperties-config.xml\n&lt;beans&gt;\n    &lt;context:property-placeholder location=\"classpath:/com/acme/jdbc.properties\"/&gt;\n&lt;/beans&gt;\n</code></pre>\n<pre><code class=\"language-kotlin\"><span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-meta\">@ImportResource(<span class=\"hljs-meta-string\">\"classpath:/com/acme/properties-config.xml\"</span>)</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AppConfig</span> </span>{\n\n    <span class=\"hljs-meta\">@Value(<span class=\"hljs-meta-string\">\"\\${jdbc.url}\"</span>)</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">lateinit</span> <span class=\"hljs-keyword\">var</span> url: String\n\n    <span class=\"hljs-meta\">@Value(<span class=\"hljs-meta-string\">\"\\${jdbc.username}\"</span>)</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">lateinit</span> <span class=\"hljs-keyword\">var</span> username: String\n\n    <span class=\"hljs-meta\">@Value(<span class=\"hljs-meta-string\">\"\\${jdbc.password}\"</span>)</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">lateinit</span> <span class=\"hljs-keyword\">var</span> password: String\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">dataSource</span><span class=\"hljs-params\">()</span></span>: DataSource {\n        <span class=\"hljs-keyword\">return</span> DriverManagerDataSource(url, username, password)\n    }\n}\n</code></pre>\n<pre><code>jdbc.properties\njdbc.url=jdbc:hsqldb:hsql://localhost/xdb\njdbc.username=sa\njdbc.password=\n</code></pre>\n<pre><code>public static void main(String[] args) {\n    ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);\n    TransferService transferService = ctx.getBean(TransferService.class);\n    // ...\n}\n</code></pre>\n<pre><code class=\"language-kotlin\"><span class=\"hljs-keyword\">import</span> org.springframework.beans.factory.getBean\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n    <span class=\"hljs-keyword\">val</span> ctx = AnnotationConfigApplicationContext(AppConfig::<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span>.<span class=\"hljs-title\">java</span>)</span>\n    <span class=\"hljs-keyword\">val</span> transferService = ctx.getBean&lt;TransferService&gt;()\n    <span class=\"hljs-comment\">// ...</span>\n}\n</code></pre>\n",
  "link": "\\zh-cn\\docs\\springframework\\core\\container\\beans-java.html",
  "meta": {
    "title": "基于Java的容器配置",
    "keywords": "keywords: docs，jcohy-docs，spring,基于Java的容器配置",
    "description": "Spring  Framework 中文文档 》 基于Java的容器配置"
  }
}
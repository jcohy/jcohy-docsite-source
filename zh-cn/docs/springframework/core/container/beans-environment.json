{
  "filename": "beans-environment.md",
  "__html": "<h1>Spring  Framework 中文文档</h1>\n<h3><a href=\"#beans-environment\"></a>1.13. 抽象环境</h3>\n<p><a href=\"https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/core/env/Environment.html\"><code>Environment</code></a>接口是集成在容器中的抽象，它模拟了应用程序环境的两个关键方面：<a href=\"#beans-definition-profiles\">profiles</a> 和 <a href=\"#beans-property-source-abstraction\">properties</a>。</p>\n<p>profile配置是一个被命名的,bean定义的逻辑组,这些bean只有在给定的profile配置激活时才会注册到容器.无论是以XML还是通过注解定义,Bean都可以分配给配置文件 。<code>Environment</code>对象在profile中的角色是判断哪一个profile应该在当前激活和哪一个profile应该在默认情况下激活。</p>\n<p>属性在几乎所有应用程序中都发挥着重要作用，可能源自各种源：属性文件，JVM系统属性，系统环境变量，JNDI，servlet上下文参数，ad-hoc属性对象，Map对象等。 与属性相关的<code>Environment</code>对象的作用是为用户提供方便的服务接口，用于配置属性源和从中解析属性。</p>\n<p><a id=\"beans-definition-profiles\"></a></p>\n<h4><a href=\"#beans-definition-profiles\"></a>1.13.1. Bean定义Profiles</h4>\n<p>bean定义profiles是核心容器内的一种机制，该机制能在不同环境中注册不同的bean。“环境”这个词对不同的用户来说意味着不同的东西，这个功能可以帮助解决许多用例，包括：</p>\n<ul>\n<li>\n<p>在QA或生产环境中，针对开发中的内存数据源而不是从JNDI查找相同的数据源。</p>\n</li>\n<li>\n<p>开发期使用监控组件，当部署以后则关闭监控组件，使应用更高效</p>\n</li>\n<li>\n<p>为用户各自注册自定义bean实现</p>\n</li>\n</ul>\n<p>考虑<code>DataSource</code>的实际应用程序中的第一个用例。 在测试环境中，配置可能类似于以下内容：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Bean</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> DataSource <span class=\"hljs-title\">dataSource</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> EmbeddedDatabaseBuilder()\n        .setType(EmbeddedDatabaseType.HSQL)\n        .addScript(<span class=\"hljs-string\">\"my-schema.sql\"</span>)\n        .addScript(<span class=\"hljs-string\">\"my-test-data.sql\"</span>)\n        .build();\n}\n</code></pre>\n<pre><code class=\"language-kotlin\"><span class=\"hljs-meta\">@Bean</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">dataSource</span><span class=\"hljs-params\">()</span></span>: DataSource {\n    <span class=\"hljs-keyword\">return</span> EmbeddedDatabaseBuilder()\n            .setType(EmbeddedDatabaseType.HSQL)\n            .addScript(<span class=\"hljs-string\">\"my-schema.sql\"</span>)\n            .addScript(<span class=\"hljs-string\">\"my-test-data.sql\"</span>)\n            .build()\n}\n</code></pre>\n<p>现在考虑如何将此应用程序部署到QA或生产环境中，假设应用程序的数据源已注册到生产应用程序服务器的JNDI目录。 我们的<code>dataSource</code> bean现在看起来如下：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Bean</span>(destroyMethod=<span class=\"hljs-string\">\"\"</span>)\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> DataSource <span class=\"hljs-title\">dataSource</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\n    Context ctx = <span class=\"hljs-keyword\">new</span> InitialContext();\n    <span class=\"hljs-keyword\">return</span> (DataSource) ctx.lookup(<span class=\"hljs-string\">\"java:comp/env/jdbc/datasource\"</span>);\n}\n</code></pre>\n<pre><code class=\"language-kotlin\"><span class=\"hljs-meta\">@Bean(destroyMethod = <span class=\"hljs-meta-string\">\"\"</span>)</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">dataSource</span><span class=\"hljs-params\">()</span></span>: DataSource {\n    <span class=\"hljs-keyword\">val</span> ctx = InitialContext()\n    <span class=\"hljs-keyword\">return</span> ctx.lookup(<span class=\"hljs-string\">\"java:comp/env/jdbc/datasource\"</span>) <span class=\"hljs-keyword\">as</span> DataSource\n}\n</code></pre>\n<p>问题是如何根据当前环境在使用这两种变体之间切换。随着时间的推移，Spring用户已经设计了许多方法来完成这项工作，通常依赖于系统环境变量和包含<code>${placeholder}</code>标记的XML<code>&lt;import/&gt;</code>语句的组合， 这些标记根据值解析为正确的配置文件路径一个环境变量。 Bean定义profiles是核心容器功能，可为此问题提供解决方案。</p>\n<p>概括一下上面的场景，环境决定bean定义,最后发现,我们需要在某些上下文环境中使用某些bean,在其他环境中则不用这些bean.或者说, 在场景A中注册一组bean定义,而在场景B中注册另外一组。先看看如何通过修改配置来完成此需求：</p>\n<p><a id=\"beans-definition-profiles-java\"></a></p>\n<h5><a href=\"#beans-definition-profiles-java\"></a>使用 <code>@Profile</code></h5>\n<p><a href=\"https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/context/annotation/Profile.html\"><code>@Profile</code></a>注解用于当一个或多个配置文件激活的时候,用来指定组件是否有资格注册。使用前面的示例，我们可以重写<code>dataSource</code>配置，如下所示：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-meta\">@Profile</span>(<span class=\"hljs-string\">\"development\"</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">StandaloneDataConfig</span> </span>{\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> DataSource <span class=\"hljs-title\">dataSource</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> EmbeddedDatabaseBuilder()\n            .setType(EmbeddedDatabaseType.HSQL)\n            .addScript(<span class=\"hljs-string\">\"classpath:com/bank/config/sql/schema.sql\"</span>)\n            .addScript(<span class=\"hljs-string\">\"classpath:com/bank/config/sql/test-data.sql\"</span>)\n            .build();\n    }\n}\n\n<span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-meta\">@Profile</span>(<span class=\"hljs-string\">\"production\"</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">JndiDataConfig</span> </span>{\n\n    <span class=\"hljs-meta\">@Bean</span>(destroyMethod=<span class=\"hljs-string\">\"\"</span>)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> DataSource <span class=\"hljs-title\">dataSource</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\n        Context ctx = <span class=\"hljs-keyword\">new</span> InitialContext();\n        <span class=\"hljs-keyword\">return</span> (DataSource) ctx.lookup(<span class=\"hljs-string\">\"java:comp/env/jdbc/datasource\"</span>);\n    }\n}\n</code></pre>\n<pre><code class=\"language-kotlin\"><span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-meta\">@Profile(<span class=\"hljs-meta-string\">\"development\"</span>)</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">StandaloneDataConfig</span> </span>{\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">dataSource</span><span class=\"hljs-params\">()</span></span>: DataSource {\n        <span class=\"hljs-keyword\">return</span> EmbeddedDatabaseBuilder()\n                .setType(EmbeddedDatabaseType.HSQL)\n                .addScript(<span class=\"hljs-string\">\"classpath:com/bank/config/sql/schema.sql\"</span>)\n                .addScript(<span class=\"hljs-string\">\"classpath:com/bank/config/sql/test-data.sql\"</span>)\n                .build()\n    }\n}\n\n<span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-meta\">@Profile(<span class=\"hljs-meta-string\">\"production\"</span>)</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">JndiDataConfig</span> </span>{\n\n    <span class=\"hljs-meta\">@Bean(destroyMethod = <span class=\"hljs-meta-string\">\"\"</span>)</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">dataSource</span><span class=\"hljs-params\">()</span></span>: DataSource {\n        <span class=\"hljs-keyword\">val</span> ctx = InitialContext()\n        <span class=\"hljs-keyword\">return</span> ctx.lookup(<span class=\"hljs-string\">\"java:comp/env/jdbc/datasource\"</span>) <span class=\"hljs-keyword\">as</span> DataSource\n    }\n}\n</code></pre>\n<p>如前所述，使用<code>@Bean</code>方法，您通常选择使用Spring的<code>JndiTemplate</code>/<code>JndiLocatorDelegate</code>帮助程序或前面显示的 直接JNDI <code>InitialContext</code>用法但不使用<code>JndiObjectFactoryBean</code>变量来使用编程JNDI查找，这会强制您将返回类型声明为 <code>FactoryBean</code>类型。 As mentioned earlier, with <code>@Bean</code> methods, you typically choose to use programmatic JNDI lookups, by using either Spring’s <code>JndiTemplate</code>/<code>JndiLocatorDelegate</code> helpers or the straight JNDI <code>InitialContext</code> usage shown earlier but not the <code>JndiObjectFactoryBean</code> variant, which would force you to declare the return type as the <code>FactoryBean</code> type.</p>\n<p>profile字符串可以包含简单的profile名称（例如，<code>production</code>）或profile表达式。 profile表达式允许表达更复杂的概要逻辑（例如，<code>production &amp; us-east</code>）。 profile表达式支持以下运算符：</p>\n<ul>\n<li>\n<p><code>!</code>: A logical “not” of the profile</p>\n</li>\n<li>\n<p><code>&amp;</code>: A logical “and” of the profiles</p>\n</li>\n<li>\n<p><code>|</code>: A logical “or” of the profiles</p>\n</li>\n</ul>\n<p>你不能不使用括号而混合 <code>&amp;</code> 和 <code>|</code> 。 例如，<code>production &amp; us-east | eu-central</code>不是一个有效的表达。 它必须表示为 <code>production &amp; (us-east | eu-central)</code>.。</p>\n<p>您可以将<code>@Profile</code>用作<a href=\"#beans-meta-annotations\">元注解</a>，以创建自定义组合注解。 以下示例定义了一个自定义<code>@Production</code>注解，您可以将其用作<code>@Profile(&quot;production&quot;)</code>的替代品：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Target</span>(ElementType.TYPE)\n<span class=\"hljs-meta\">@Retention</span>(RetentionPolicy.RUNTIME)\n<span class=\"hljs-meta\">@Profile</span>(<span class=\"hljs-string\">\"production\"</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-meta\">@interface</span> Production {\n}\n</code></pre>\n<pre><code class=\"language-kotlin\"><span class=\"hljs-meta\">@Target(AnnotationTarget.TYPE)</span>\n<span class=\"hljs-meta\">@Retention(AnnotationRetention.RUNTIME)</span>\n<span class=\"hljs-meta\">@Profile(<span class=\"hljs-meta-string\">\"production\"</span>)</span>\n<span class=\"hljs-keyword\">annotation</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Production</span></span>\n</code></pre>\n<p>如果<code>@Configuration</code>类标有 <code>@Profile</code>,类中所有<code>@Bean</code>和<code>@Import</code>注解相关的类都将被忽略,除非该profile被激活。 如果一个<code>@Component</code>或<code>@Configuration</code>类被标记为<code>@Profile({&quot;p1&quot;, &quot;p2&quot;})</code>。那么除非profile 'p1' or 'p2' 已被激活。 否则该类将不会注册/处理。如果给定的配置文件以NOT运算符(<code>!</code>)为前缀，如果配置文件为not active，则注册的元素将被注册。 例如，给定<code>@Profile({&quot;p1&quot;, &quot;!p2&quot;})</code>，如果配置文件“p1”处于活动状态或配置文件“p2”未激活，则会进行注册。</p>\n<p><code>@Profile</code>也能注解方法，用于配置一个配置类中的指定bean。如以下示例所示：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AppConfig</span> </span>{\n\n    <span class=\"hljs-meta\">@Bean</span>(<span class=\"hljs-string\">\"dataSource\"</span>)\n    <span class=\"hljs-meta\">@Profile</span>(<span class=\"hljs-string\">\"development\"</span>) (<span class=\"hljs-number\">1</span>)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> DataSource <span class=\"hljs-title\">standaloneDataSource</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> EmbeddedDatabaseBuilder()\n            .setType(EmbeddedDatabaseType.HSQL)\n            .addScript(<span class=\"hljs-string\">\"classpath:com/bank/config/sql/schema.sql\"</span>)\n            .addScript(<span class=\"hljs-string\">\"classpath:com/bank/config/sql/test-data.sql\"</span>)\n            .build();\n    }\n\n    <span class=\"hljs-meta\">@Bean</span>(<span class=\"hljs-string\">\"dataSource\"</span>)\n    <span class=\"hljs-meta\">@Profile</span>(<span class=\"hljs-string\">\"production\"</span>) (<span class=\"hljs-number\">2</span>)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> DataSource <span class=\"hljs-title\">jndiDataSource</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\n        Context ctx = <span class=\"hljs-keyword\">new</span> InitialContext();\n        <span class=\"hljs-keyword\">return</span> (DataSource) ctx.lookup(<span class=\"hljs-string\">\"java:comp/env/jdbc/datasource\"</span>);\n    }\n}\n</code></pre>\n<pre><code class=\"language-kotlin\"><span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AppConfig</span> </span>{\n\n    <span class=\"hljs-meta\">@Bean(<span class=\"hljs-meta-string\">\"dataSource\"</span>)</span>\n    <span class=\"hljs-meta\">@Profile(<span class=\"hljs-meta-string\">\"development\"</span>)</span> \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">standaloneDataSource</span><span class=\"hljs-params\">()</span></span>: DataSource {\n        <span class=\"hljs-keyword\">return</span> EmbeddedDatabaseBuilder()\n                .setType(EmbeddedDatabaseType.HSQL)\n                .addScript(<span class=\"hljs-string\">\"classpath:com/bank/config/sql/schema.sql\"</span>)\n                .addScript(<span class=\"hljs-string\">\"classpath:com/bank/config/sql/test-data.sql\"</span>)\n                .build()\n    }\n\n    <span class=\"hljs-meta\">@Bean(<span class=\"hljs-meta-string\">\"dataSource\"</span>)</span>\n    <span class=\"hljs-meta\">@Profile(<span class=\"hljs-meta-string\">\"production\"</span>)</span> \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">jndiDataSource</span><span class=\"hljs-params\">()</span></span> =\n        InitialContext().lookup(<span class=\"hljs-string\">\"java:comp/env/jdbc/datasource\"</span>) <span class=\"hljs-keyword\">as</span> DataSource\n}\n</code></pre>\n<p><strong>1</strong>、<code>standaloneDataSource</code> 方法仅在 <code>development</code> 环境可用.</p>\n<p><strong>2</strong>、<code>jndiDataSource</code>方法仅在 <code>production</code> 环境可用.</p>\n<p>在<code>@Bean</code> 方法上还添加有<code>@Profile</code>注解,可能会应用在特殊情况。在相同Java方法名称的重载<code>@Bean</code>方法(类似于构造函数重载）的情况下， 需要在所有重载方法上一致声明<code>@Profile</code>条件，如果条件不一致，则只有重载方法中第一个声明的条件才重要。因此，<code>@Profile</code>不能用于选择具有特定参数签名的重载方法， 所有工厂方法对相同的bean在Spring构造器中的解析算法在创建时是相同的。</p>\n<p>如果想定义具有不同配置文件条件的备用bean，请使用不同的Java方法名称，通过<code>@Bean</code>名称属性指向相同的bean名称。如上例所示。 如果参数签名都是相同的（例如，所有的变体都是无参的工厂方法），这是安排有效Java类放在首要位置的唯一方法（因为只有一个 特定名称和参数签名的方法）。</p>\n<p><a id=\"beans-definition-profiles-xml\"></a></p>\n<h5><a href=\"#beans-definition-profiles-xml\"></a>XML bean定义profiles</h5>\n<p>XML中的<code>&lt;beans&gt;</code> 元素有一个<code>profile</code> 属性,我们之前的示例配置可以在两个XML文件中重写，如下所示：</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">beans</span> <span class=\"hljs-attr\">profile</span>=<span class=\"hljs-string\">\"development\"</span>\n    <span class=\"hljs-attr\">xmlns</span>=<span class=\"hljs-string\">\"http://www.springframework.org/schema/beans\"</span>\n    <span class=\"hljs-attr\">xmlns:xsi</span>=<span class=\"hljs-string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span>\n    <span class=\"hljs-attr\">xmlns:jdbc</span>=<span class=\"hljs-string\">\"http://www.springframework.org/schema/jdbc\"</span>\n    <span class=\"hljs-attr\">xsi:schemaLocation</span>=<span class=\"hljs-string\">\"...\"</span>&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">jdbc:embedded-database</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"dataSource\"</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">jdbc:script</span> <span class=\"hljs-attr\">location</span>=<span class=\"hljs-string\">\"classpath:com/bank/config/sql/schema.sql\"</span>/&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">jdbc:script</span> <span class=\"hljs-attr\">location</span>=<span class=\"hljs-string\">\"classpath:com/bank/config/sql/test-data.sql\"</span>/&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">jdbc:embedded-database</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">beans</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">beans</span> <span class=\"hljs-attr\">profile</span>=<span class=\"hljs-string\">\"production\"</span>\n    <span class=\"hljs-attr\">xmlns</span>=<span class=\"hljs-string\">\"http://www.springframework.org/schema/beans\"</span>\n    <span class=\"hljs-attr\">xmlns:xsi</span>=<span class=\"hljs-string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span>\n    <span class=\"hljs-attr\">xmlns:jee</span>=<span class=\"hljs-string\">\"http://www.springframework.org/schema/jee\"</span>\n    <span class=\"hljs-attr\">xsi:schemaLocation</span>=<span class=\"hljs-string\">\"...\"</span>&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">jee:jndi-lookup</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"dataSource\"</span> <span class=\"hljs-attr\">jndi-name</span>=<span class=\"hljs-string\">\"java:comp/env/jdbc/datasource\"</span>/&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">beans</span>&gt;</span>\n</code></pre>\n<p>也可以不用分开2个文件，在同一个XML中配置2个<code>&lt;beans/&gt;</code>，<code>&lt;beans/&gt;</code>元素也有profile属性。如以下示例所示：</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">beans</span> <span class=\"hljs-attr\">xmlns</span>=<span class=\"hljs-string\">\"http://www.springframework.org/schema/beans\"</span>\n    <span class=\"hljs-attr\">xmlns:xsi</span>=<span class=\"hljs-string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span>\n    <span class=\"hljs-attr\">xmlns:jdbc</span>=<span class=\"hljs-string\">\"http://www.springframework.org/schema/jdbc\"</span>\n    <span class=\"hljs-attr\">xmlns:jee</span>=<span class=\"hljs-string\">\"http://www.springframework.org/schema/jee\"</span>\n    <span class=\"hljs-attr\">xsi:schemaLocation</span>=<span class=\"hljs-string\">\"...\"</span>&gt;</span>\n\n    <span class=\"hljs-comment\">&lt;!-- other bean definitions --&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">beans</span> <span class=\"hljs-attr\">profile</span>=<span class=\"hljs-string\">\"development\"</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">jdbc:embedded-database</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"dataSource\"</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">jdbc:script</span> <span class=\"hljs-attr\">location</span>=<span class=\"hljs-string\">\"classpath:com/bank/config/sql/schema.sql\"</span>/&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">jdbc:script</span> <span class=\"hljs-attr\">location</span>=<span class=\"hljs-string\">\"classpath:com/bank/config/sql/test-data.sql\"</span>/&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">jdbc:embedded-database</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">beans</span>&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">beans</span> <span class=\"hljs-attr\">profile</span>=<span class=\"hljs-string\">\"production\"</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">jee:jndi-lookup</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"dataSource\"</span> <span class=\"hljs-attr\">jndi-name</span>=<span class=\"hljs-string\">\"java:comp/env/jdbc/datasource\"</span>/&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">beans</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">beans</span>&gt;</span>\n</code></pre>\n<p><code>spring-bean.xsd</code> 强制允许将profile元素定义在文件的最后面，这有助于在XML文件中提供灵活的方式而又不引起混乱。</p>\n<p>对应XML不支持前面描述的profile表达式。 但是，有可能通过使用<code>!</code> 来否定一个profile表达式。 也可以通过嵌套profiles来应用“and”，如以下示例所示：</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">beans</span> <span class=\"hljs-attr\">xmlns</span>=<span class=\"hljs-string\">\"http://www.springframework.org/schema/beans\"</span>\n    <span class=\"hljs-attr\">xmlns:xsi</span>=<span class=\"hljs-string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span>\n    <span class=\"hljs-attr\">xmlns:jdbc</span>=<span class=\"hljs-string\">\"http://www.springframework.org/schema/jdbc\"</span>\n    <span class=\"hljs-attr\">xmlns:jee</span>=<span class=\"hljs-string\">\"http://www.springframework.org/schema/jee\"</span>\n    <span class=\"hljs-attr\">xsi:schemaLocation</span>=<span class=\"hljs-string\">\"...\"</span>&gt;</span>\n\n    <span class=\"hljs-comment\">&lt;!-- other bean definitions --&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">beans</span> <span class=\"hljs-attr\">profile</span>=<span class=\"hljs-string\">\"production\"</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">beans</span> <span class=\"hljs-attr\">profile</span>=<span class=\"hljs-string\">\"us-east\"</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">jee:jndi-lookup</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"dataSource\"</span> <span class=\"hljs-attr\">jndi-name</span>=<span class=\"hljs-string\">\"java:comp/env/jdbc/datasource\"</span>/&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">beans</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">beans</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">beans</span>&gt;</span>\n</code></pre>\n<p>在前面的示例中，如果<code>production</code> 和<code>us-east</code> profiles都处于活动状态，则会暴露<code>dataSource</code> bean。</p>\n<p><a id=\"beans-definition-profiles-enable\"></a></p>\n<h5><a href=\"#beans-definition-profiles-enable\"></a>启用profile</h5>\n<p>现在已经更新了配置,但仍然需要指定要激活哪个配置文件, 如果我们现在开始我们的示例应用程序， 我们会看到抛出<code>NoSuchBeanDefinitionException</code>，因为容器找不到名为<code>dataSource</code>的Spring bean。</p>\n<p>激活配置文件可以通过多种方式完成，但最直接的方法是以编程方式对可通过<code>ApplicationContext</code>提供的<code>Environment</code> API进行操作。 以下示例显示了如何执行此操作：</p>\n<pre><code class=\"language-java\">AnnotationConfigApplicationContext ctx = <span class=\"hljs-keyword\">new</span> AnnotationConfigApplicationContext();\nctx.getEnvironment().setActiveProfiles(<span class=\"hljs-string\">\"development\"</span>);\nctx.register(SomeConfig<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>, <span class=\"hljs-title\">StandaloneDataConfig</span>.<span class=\"hljs-title\">class</span>, <span class=\"hljs-title\">JndiDataConfig</span>.<span class=\"hljs-title\">class</span>)</span>;\nctx.refresh();\n</code></pre>\n<pre><code class=\"language-kotlin\"><span class=\"hljs-keyword\">val</span> ctx = AnnotationConfigApplicationContext().apply {\n    environment.setActiveProfiles(<span class=\"hljs-string\">\"development\"</span>)\n    register(SomeConfig::<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span>.<span class=\"hljs-title\">java</span>, <span class=\"hljs-type\">StandaloneDataConfig::class.java</span>, <span class=\"hljs-type\">JndiDataConfig::class.java)</span></span>\n    refresh()\n}\n</code></pre>\n<p>此外,配置文件也可以通过<code>spring.profiles.active</code>属性声明式性地激活,可以通过系统环境变量，JVM系统属性，<code>web.xml</code>中的Servlet上下文参数指定， 甚至作为JNDI中的一个条目设置（<a href=\"#beans-property-source-abstraction\"><code>PropertySource</code> 抽象</a>）。在集成测试中，可以通过 <code>spring-test</code>模块中的<code>@ActiveProfiles</code>注解来声明活动配置文件(参见使用<a href=\"https://github.com/DocsHome/spring-docs/blob/master/pages/test/testing.mdl#testcontext-ctx-management-env-profiles\">环境配置文件的上下文配置</a>)</p>\n<p>配置文件不是“二选一”的。开发者可以一次激活多个配置文件。使用编程方式，您可以为<code>setActiveProfiles()</code>方法提供多个配置文件名称，该方法接受 <code>String…</code>varargs。 以下示例激活多个配置文件：</p>\n<pre><code class=\"language-java\">ctx.getEnvironment().setActiveProfiles(<span class=\"hljs-string\">\"profile1\"</span>, <span class=\"hljs-string\">\"profile2\"</span>);\n</code></pre>\n<pre><code class=\"language-kotlin\">ctx.getEnvironment().setActiveProfiles(<span class=\"hljs-string\">\"profile1\"</span>, <span class=\"hljs-string\">\"profile2\"</span>)\n</code></pre>\n<p>声明性地，<code>spring.profiles.active</code>可以接受以逗号分隔的profile名列表，如以下示例所示：</p>\n<pre><code class=\"language-java\">-Dspring.profiles.active=<span class=\"hljs-string\">\"profile1,profile2\"</span>\n</code></pre>\n<p><a id=\"beans-definition-profiles-default\"></a></p>\n<h5><a href=\"#beans-definition-profiles-default\"></a>默认 Profile</h5>\n<p>default配置文件表示默认开启的profile配置。考虑以下配置:</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-meta\">@Profile</span>(<span class=\"hljs-string\">\"default\"</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DefaultDataConfig</span> </span>{\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> DataSource <span class=\"hljs-title\">dataSource</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> EmbeddedDatabaseBuilder()\n            .setType(EmbeddedDatabaseType.HSQL)\n            .addScript(<span class=\"hljs-string\">\"classpath:com/bank/config/sql/schema.sql\"</span>)\n            .build();\n    }\n}\n</code></pre>\n<pre><code class=\"language-kotlin\"><span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-meta\">@Profile(<span class=\"hljs-meta-string\">\"default\"</span>)</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DefaultDataConfig</span> </span>{\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">dataSource</span><span class=\"hljs-params\">()</span></span>: DataSource {\n        <span class=\"hljs-keyword\">return</span> EmbeddedDatabaseBuilder()\n                .setType(EmbeddedDatabaseType.HSQL)\n                .addScript(<span class=\"hljs-string\">\"classpath:com/bank/config/sql/schema.sql\"</span>)\n                .build()\n    }\n}\n</code></pre>\n<p>如果没有配置文件激活，上面的<code>dataSource</code>就会被创建。这提供了一种默认的方式，如果有任何一个配置文件启用，default配置就不会生效。</p>\n<p>默认配置文件的名字(default）可以通过<code>Environment</code>的<code>setDefaultProfiles()</code>方法或者<code>spring.profiles.default</code>属性修改。</p>\n<p><a id=\"beans-property-source-abstraction\"></a></p>\n<h4><a href=\"#beans-property-source-abstraction\"></a>1.13.2. <code>PropertySource</code> 抽象</h4>\n<p>Spring的<code>Environment</code>抽象提供用于一系列的propertysources属性配置文件的搜索操作.请考虑以下列表：</p>\n<pre><code class=\"language-java\">ApplicationContext ctx = <span class=\"hljs-keyword\">new</span> GenericApplicationContext();\nEnvironment env = ctx.getEnvironment();\n<span class=\"hljs-keyword\">boolean</span> containsMyProperty = env.containsProperty(<span class=\"hljs-string\">\"my-property\"</span>);\nSystem.out.println(<span class=\"hljs-string\">\"Does my environment contain the 'my-property' property? \"</span> + containsMyProperty);\n</code></pre>\n<pre><code class=\"language-kotlin\"><span class=\"hljs-keyword\">val</span> ctx = GenericApplicationContext()\n<span class=\"hljs-keyword\">val</span> env = ctx.environment\n<span class=\"hljs-keyword\">val</span> containsMyProperty = env.containsProperty(<span class=\"hljs-string\">\"my-property\"</span>)\nprintln(<span class=\"hljs-string\">\"Does my environment contain the 'my-property' property? <span class=\"hljs-variable\">$containsMyProperty</span>\"</span>)\n</code></pre>\n<p>在上面的代码段中,一个高级别的方法用于访问Spring是否为当前环境定义了<code>my-property</code> 属性。为了回答这个问题，<code>Environment</code>对象对一组PropertySource对象进行搜索。 <a href=\"https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/core/env/PropertySource.html\"><code>PropertySource</code></a>是对任何键值对的简单抽象，Spring的<a href=\"https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/core/env/StandardEnvironment.html\"><code>StandardEnvironment</code></a>配置有两个<code>PropertySource</code>对象 ，一个表示JVM系统属性(<code>System.getProperties()</code>),一个表示系统环境变量(<code>System.getenv()</code>)。</p>\n<p>这些默认property源位于<code>StandardEnvironment</code>中,用于独立应用程序。<a href=\"https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/web/context/support/StandardServletEnvironment.html\"><code>StandardServletEnvironment</code></a>用默认的property配置源填充。 默认配置源包括Servlet配置和Servlet上下文参数，它可以选择启用<a href=\"https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/jndi/JndiPropertySource.html\"><code>JndiPropertySource</code></a>。有关详细信息，请参阅它的javadocs</p>\n<p>具体地说，当您使用<code>StandardEnvironment</code>时，如果在运行时存在<code>my-property</code>系统属性或<code>my-propertyi</code>环境变量，则对 <code>env.containsProperty(&quot;my-property&quot;)</code>的调用将返回true。</p>\n<p>执行的搜索是分层的。默认情况下，系统属性优先于环境变量，因此如果在调用<code>env.getProperty(&quot;my-property&quot;)</code>期间碰巧在两个位置都设置了<code>my-property</code>属性， 系统属性值返回优先于环境变量。 请注意，属性值未合并，而是由前面的条目完全覆盖。</p>\n<p>对于常见的 <code>StandardServletEnvironment</code>，完整层次结构如下，最高优先级条目位于顶部：</p>\n<ol>\n<li>\n<p>ServletConfig参数（如果适用 - 例如，在DispatcherServlet上下文的情况下）</p>\n</li>\n<li>\n<p>ServletContext参数（web.xml context-param条目）</p>\n</li>\n<li>\n<p>JNDI环境变量（<code>java:comp/env/</code>entries）</p>\n</li>\n<li>\n<p>JVM系统属性（<code>-D</code>命令行参数）</p>\n</li>\n<li>\n<p>JVM系统环境（操作系统环境变量）</p>\n</li>\n</ol>\n<p>最重要的是,整个机制都是可配置的。也许开发者需要一个自定义的properties源，并将该源整合到这个检索层级中。为此，请实现并实例化您自己的<code>PropertySource</code>，并将其添加到当前<code>Environment</code>的<code>PropertySource</code>集合中。 以下示例显示了如何执行此操作：</p>\n<pre><code class=\"language-java\">ConfigurableApplicationContext ctx = <span class=\"hljs-keyword\">new</span> GenericApplicationContext();\nMutablePropertySources sources = ctx.getEnvironment().getPropertySources();\nsources.addFirst(<span class=\"hljs-keyword\">new</span> MyPropertySource());\n</code></pre>\n<pre><code class=\"language-kotlin\"><span class=\"hljs-keyword\">val</span> ctx = GenericApplicationContext()\n<span class=\"hljs-keyword\">val</span> sources = ctx.environment.propertySources\nsources.addFirst(MyPropertySource())\n</code></pre>\n<p>在上面的代码中， <code>MyPropertySource</code>在搜索中添加了最高优先级。如果它包含<code>my-property</code>属性，则会检测并返回该属性， 优先于其他 <code>PropertySource</code>中的任何<code>my-property</code>属性。 <a href=\"https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/core/env/MutablePropertySources.html\"><code>MutablePropertySources</code></a> API公开了许多方法，允许你显式操作property属性源。</p>\n<p><a id=\"beans-using-propertysource\"></a></p>\n<h4><a href=\"#beans-using-propertysource\"></a>1.13.3. 使用 <code>@PropertySource</code></h4>\n<p><a href=\"https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/context/annotation/PropertySource.html\"><code>@PropertySource</code></a> 注解提供了便捷的方式，用于增加<code>PropertySource</code>到Spring的 <code>Environment</code>中。</p>\n<p>给定一个名为<code>app.properties</code>的文件，其中包含键值对<code>testbean.name=myTestBean</code>， 以下<code>@Configuration</code>类使用<code>@PropertySource</code>，以便调用<code>testBean.getName()</code> 返回<code>myTestBean</code>：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-meta\">@PropertySource</span>(<span class=\"hljs-string\">\"classpath:/com/myco/app.properties\"</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AppConfig</span> </span>{\n\n    <span class=\"hljs-meta\">@Autowired</span>\n    Environment env;\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> TestBean <span class=\"hljs-title\">testBean</span><span class=\"hljs-params\">()</span> </span>{\n        TestBean testBean = <span class=\"hljs-keyword\">new</span> TestBean();\n        testBean.setName(env.getProperty(<span class=\"hljs-string\">\"testbean.name\"</span>));\n        <span class=\"hljs-keyword\">return</span> testBean;\n    }\n}\n</code></pre>\n<pre><code class=\"language-kotlin\"><span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-meta\">@PropertySource(<span class=\"hljs-meta-string\">\"classpath:/com/myco/app.properties\"</span>)</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AppConfig</span> </span>{\n\n    <span class=\"hljs-meta\">@Autowired</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">lateinit</span> <span class=\"hljs-keyword\">var</span> env: Environment\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">testBean</span><span class=\"hljs-params\">()</span></span> = TestBean().apply {\n        name = env.getProperty(<span class=\"hljs-string\">\"testbean.name\"</span>)!!\n    }\n}\n</code></pre>\n<p>任何的存在于<code>@PropertySource</code>中的<code>${…}</code>占位符，将会被解析为定义在环境中的属性配置文件中的属性值。 如以下示例所示：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-meta\">@PropertySource</span>(<span class=\"hljs-string\">\"classpath:/com/${my.placeholder:default/path}/app.properties\"</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AppConfig</span> </span>{\n\n    <span class=\"hljs-meta\">@Autowired</span>\n    Environment env;\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> TestBean <span class=\"hljs-title\">testBean</span><span class=\"hljs-params\">()</span> </span>{\n        TestBean testBean = <span class=\"hljs-keyword\">new</span> TestBean();\n        testBean.setName(env.getProperty(<span class=\"hljs-string\">\"testbean.name\"</span>));\n        <span class=\"hljs-keyword\">return</span> testBean;\n    }\n}\n</code></pre>\n<pre><code class=\"language-kotlin\"><span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-meta\">@PropertySource(<span class=\"hljs-meta-string\">\"classpath:/com/\\${my.placeholder:default/path}/app.properties\"</span>)</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AppConfig</span> </span>{\n\n    <span class=\"hljs-meta\">@Autowired</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">lateinit</span> <span class=\"hljs-keyword\">var</span> env: Environment\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">testBean</span><span class=\"hljs-params\">()</span></span> = TestBean().apply {\n        name = env.getProperty(<span class=\"hljs-string\">\"testbean.name\"</span>)!!\n    }\n}\n</code></pre>\n<p>假设<code>my.placeholder</code>存在于已注册的其中一个属性源中（例如，系统属性或环境变量），则占位符将解析为相应的值。 如果不是，则<code>default/path</code>用作默认值。 如果未指定默认值且无法解析属性，则抛出<code>IllegalArgumentException</code>。</p>\n<p>根据Java 8惯例，<code>@PropertySource</code>注解是可重复的。 但是，所有这些<code>@PropertySource</code>注解都需要在同一级别声明，可以直接在配置类上声明， 也可以在同一自定义注解中作为元注解声明。 不建议混合直接注解和元注解，因为直接注解有效地覆盖了元注解。</p>\n<p><a id=\"beans-placeholder-resolution-in-statements\"></a></p>\n<h4><a href=\"#beans-placeholder-resolution-in-statements\"></a>1.13.4. 在声明中的占位符</h4>\n<p>之前，元素中占位符的值只能针对JVM系统属性或环境变量进行解析。现在已经打破了这种情况。因为环境抽象集成在整个容器中，所以很容易通过它来对占位符进行解析. 这意味着开发者可以以任何喜欢的方式来配置这个解析过程，可以改变是优先查找系统properties或者是有限查找环境变量，或者删除它们；增加自定义property源，使之成为更合适的配置</p>\n<p>具体而言，只要在<code>Environment</code>中可用，无论<code>customer</code>属性在何处定义，以下语句都可以工作：</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">beans</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">import</span> <span class=\"hljs-attr\">resource</span>=<span class=\"hljs-string\">\"com/bank/service/${customer}-config.xml\"</span>/&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">beans</span>&gt;</span>\n</code></pre>\n",
  "link": "\\zh-cn\\docs\\springframework\\core\\container\\beans-environment.html",
  "meta": {
    "title": "抽象环境",
    "keywords": "keywords: docs，jcohy-docs，spring,抽象环境",
    "description": "Spring  Framework 中文文档 》 抽象环境"
  }
}
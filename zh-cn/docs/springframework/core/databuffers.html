<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<meta name="keywords" content="databuffers" />
	<meta name="description" content="databuffers" />
	<!-- 网页标签标题 -->
	<title>databuffers</title>
	<link rel="shortcut icon" href="/img/jcohy.ico"/>
	<link rel="stylesheet" href="/build/documentation.css" />
</head>
<body>
	<div id="root"><div class="documentation-page" data-reactroot=""><header class="header-container header-container-normal"><div class="header-body"><a href="/zh-cn/index.html"><img class="logo" src="/img/jcohy_colorful.png"/></a><div class="search search-normal"><span class="icon-search"></span></div><span class="language-switch language-switch-normal">En</span><div class="header-menu"><img class="header-menu-toggle" src="/img/system/menu_gray.png"/><ul><li class="menu-item menu-item-normal"><a href="/zh-cn/index.html" target="_self">首页</a></li><li class="menu-item menu-item-normal menu-item-normal-active"><a href="/zh-cn/docs/Overview.html" target="_self">文档</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/blog/index.html" target="_self">博客</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/open/index.html" target="_self">开源项目</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/resource/index.html" target="_self">资源</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/community/index.html" target="_self">社区</a></li></ul></div></div></header><div class="bar"><div class="bar-body"><img src="/img/system/docs.png" class="front-img"/><span>文档</span><img src="/img/system/docs.png" class="back-img"/></div></div><section class="content-section"><div class="sidemenu"><div class="sidemenu-toggle"><img src="https://img.alicdn.com/tfs/TB1E6apXHGYBuNjy0FoXXciBFXa-200-200.png"/></div><ul><li class="menu-item menu-item-level-1"><span>概述</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/Overview.html" target="_self">概述</a></li></ul></li><li class="menu-item menu-item-level-1"><span>Spring Framework</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/springframework/README.html" target="_self">说明</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/springframework/SUMMARY.html" target="_self">摘要</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/springframework/overview/overview.html" target="_self">概述</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>核心组件<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/system/arrow_down.png"/></span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-3"><a href="/zh-cn/docs/springframework/core/overview.html" target="_self">全部章节一览</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-3"><a href="/zh-cn/docs/springframework/core/IoC-container.html" target="_self">IOC容器</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-3"><a href="/zh-cn/docs/springframework/core/resources.html" target="_self">资源</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-3"><a href="/zh-cn/docs/springframework/core/validator.html" target="_self">验证, 数据绑定, 和类型转换</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-3"><a href="/zh-cn/docs/springframework/core/SpEL.html" target="_self">Spring 表达式语言 (SpEL)</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-3"><a href="/zh-cn/docs/springframework/core/aop.html" target="_self">使用Spring中面向切面编程</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-3"><a href="/zh-cn/docs/springframework/core/aop-api.html" target="_self">Spring AOP APIs</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-3"><a href="/zh-cn/docs/springframework/core/null-safety.html" target="_self">null 安全</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-3"><a href="/zh-cn/docs/springframework/core/databuffers.html" target="_self">数据缓冲区和编解码器</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-3"><a href="/zh-cn/docs/springframework/core/appendix.html" target="_self">附录</a></li>)}</ul></li></ul></li></ul></div><div class="doc-content markdown-body"><p><a id="databuffers"></a></p>
<h2><a href="#databuffers"></a>8. 数据缓冲区和编解码器</h2>
<p>Java NIO虽然提供了<code>ByteBuffer</code>，但许多库在顶层构建自己的字节缓冲区API，尤其是对于重用缓冲区和/或使用直接缓冲区有利于性能的网络操作。 例如， Netty具有<code>ByteBuf</code>层次结构，Undertow使用XNIO，Jetty使用带有回调的池化字节缓冲区，等等。 <code>spring-core</code> 模块提供了一组抽象来处理各种字节缓冲API，如下所示：</p>
<ul>
<li>
<p><a href="#databuffers-factory"><code>DataBufferFactory</code></a>创建抽象数据缓冲区。.</p>
</li>
<li>
<p><a href="#databuffers-buffer"><code>DataBuffer</code></a> DataBuffer表示可以<a href="#databuffers-buffer-pooled">pooled</a>的字节缓冲区。 .</p>
</li>
<li>
<p><a href="#databuffers-utils"><code>DataBufferUtils</code></a>为数据缓冲区提供实用程序方法。</p>
</li>
<li>
<p><a href="#codecs">Codecs</a> 将数据缓冲流解码或编码为更高级别的对象。</p>
</li>
</ul>
<p><a id="databuffers-factory"></a></p>
<h3><a href="#databuffers-factory"></a>8.1. <code>DataBufferFactory</code></h3>
<p><code>DataBufferFactory</code> 以两种方式之一创建数据缓冲区:</p>
<ol>
<li>
<p>分配新的数据缓冲区，可选择预先指定容量（如果已知），即使<code>DataBuffer</code> 的实现可以按需增长和缩小，这也更有效。</p>
</li>
<li>
<p>包装现有的 <code>byte[]</code> 或<code>java.nio.ByteBuffer</code>，并使用<code>DataBuffer</code>实现来修饰给定的数据，且不涉及分配。</p>
</li>
</ol>
<p>请注意，WebFlux应用程序不直接创建<code>DataBufferFactory</code>，而是通过<code>ServerHttpResponse</code>或客户端的<code>ClientHttpRequest</code>访问它。 工厂类型取决于底层客户端或服务器，例如 Reactor Netty的<code>NettyDataBufferFactory</code> ，其他的<code>DefaultDataBufferFactory</code>。</p>
<p><a id="databuffers-buffer"></a></p>
<h3><a href="#databuffers-buffer"></a>8.2. <code>DataBuffer</code></h3>
<p><code>DataBuffer</code> 接口提供与<code>java.nio.ByteBuffer</code>类似的操作，但也带来了一些额外的好处，其中一些受Netty <code>ByteBuf</code>的启发。 以下是部分好处清单:</p>
<ul>
<li>
<p>可以独立的读写，即不需要调用<code>flip()</code> 来在读写之间交替。</p>
</li>
<li>
<p>与<code>java.lang.StringBuilder</code>一样，按需扩展容量。.</p>
</li>
<li>
<p>通过 <a href="#databuffers-buffer-pooled"><code>PooledDataBuffer</code></a>Pooled 缓冲区和引用计数。</p>
</li>
<li>
<p>以<code>java.nio.ByteBuffer</code>， <code>InputStream</code>或<code>OutputStream</code>的形式查看缓冲区。</p>
</li>
<li>
<p>确定给定字节的索引或最后一个索引。</p>
</li>
</ul>
<p><a id="databuffers-buffer-pooled"></a></p>
<h3><a href="#databuffers-buffer-pooled"></a>8.3. <code>PooledDataBuffer</code></h3>
<p>正如Javadoc for <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/ByteBuffer.html">ByteBuffer</a>中所解释的，字节缓冲区可以是直接缓冲区，也可以是非直接缓冲区。 直接缓冲区可以驻留在Java堆之外，这样就无需复制本机I/O操作。 这使得直接缓冲区对于通过套接字接收和发送数据特别有用，但是创建和释放它们也更加昂贵，这导致了池化缓冲区的想法。</p>
<p><code>PooledDataBuffer</code>是<code>DataBuffer</code>的扩展，它有助于引用计数，这对于字节缓冲池是必不可少的。它是如何工作的？ 当分配<code>PooledDataBuffer</code> 时，引用计数为1. 调用 <code>retain()</code>递增计数，而对<code>release()</code>的调用则递减计数。只要计数大于0，就保证缓冲区不被释放。 当计数减少到0时，可以释放池化缓冲区，这实际上可能意味着缓冲区的保留内存返回到内存池。</p>
<p>请注意，不是直接对<code>PooledDataBuffer</code>进行操作，在大多数情况下，最好使用<code>DataBufferUtils</code>中的方法， 只有当它是<code>PooledDataBuffer</code>的实例时才应用release或retain到<code>DataBuffer</code>。</p>
<p><a id="databuffers-utils"></a></p>
<h3><a href="#databuffers-utils"></a>8.4. <code>DataBufferUtils</code></h3>
<p><code>DataBufferUtils</code> 提供了许多用于操作数据缓冲区的实用方法:</p>
<ul>
<li>
<p>将数据缓冲区流加入单个缓冲区中，可能只有零拷贝，例如 通过复合缓冲区，如果底层字节缓冲区API支持。 Join a stream of data buffers into a single buffer possibly with zero copy, e.g. via composite buffers, if that’s supported by the underlying byte buffer API.</p>
</li>
<li>
<p>将 <code>InputStream</code> or NIO <code>Channel</code> 转化为 <code>Flux&lt;DataBuffer&gt;</code>, 反之亦然， 将<code>Publisher&lt;DataBuffer&gt;</code> 转化为 <code>OutputStream</code> 或 NIO <code>Channel</code>.</p>
</li>
<li>
<p>如果缓冲区是<code>PooledDataBuffer</code>的实例，则释放或保留<code>DataBuffer</code> 的方法。</p>
</li>
<li>
<p>从字节流中跳过或取出，直到特定的字节数。</p>
</li>
</ul>
<p><a id="codecs"></a></p>
<h3><a href="#codecs"></a>8.5. Codecs</h3>
<p><code>org.springframework.core.codec</code> 包提供以下策略接口:</p>
<ul>
<li>
<p><code>Encoder</code> 将<code>Publisher&lt;T&gt;</code> 编码为数据缓冲区流。</p>
</li>
<li>
<p><code>Decoder</code> 将 <code>Publisher&lt;DataBuffer&gt;</code>为更高级别的对象流。</p>
</li>
</ul>
<p><code>spring-core</code>模块提供<code>byte[]</code>, <code>ByteBuffer</code>, <code>DataBuffer</code>, <code>Resource</code>, 和 <code>String</code>编码器和解码器实现。 The <code>spring-web</code>模块增加了 Jackson JSON, Jackson Smile, JAXB2, Protocol Buffers 和其他编码器和解码器。请参阅WebFlux部分中的<a href="web-reactive.html#webflux-codecs">Codecs</a> 。</p>
<p><a id="databuffers-using"></a></p>
<h3><a href="#databuffers-using"></a>8.6. 使用 <code>DataBuffer</code></h3>
<p>使用数据缓冲区时，必须特别注意确保缓冲区被释放，因为它们可能被<a href="#databuffers-buffer-pooled">pooled</a>。我们将使用编解码器来说明它是如何工作的，但概念更普遍适用。 让我们看看内部编解码器必须在内部管理数据缓冲区。</p>
<p>A <code>Decoder</code> 是在创建更高级别对象之前读取输入数据缓冲区的最后一个，因此必须按如下方式释放它们：:</p>
<ol>
<li>
<p>如果<code>Decoder</code>只是读取每个输入缓冲区并准备立即释放它，它可以通过 <code>DataBufferUtils.release(dataBuffer)</code>来实现。</p>
</li>
<li>
<p>如果<code>Decoder</code>使用<code>Flux</code> 或<code>Mono</code> 运算符（如<code>flatMap</code>，<code>reduce</code>等）在内部预取和缓存数据项，或者正在使用诸如<code>filter</code>, <code>skip</code>和其他省略项的运算符， 则 <code>doOnDiscard(PooledDataBuffer.class, DataBufferUtils::release)</code> 必须将:: release）添加到组合链中，以确保在丢弃之前释放这些缓冲区，可能还会导致错误或取消信号。</p>
</li>
<li>
<p>如果 <code>Decoder</code> 以任何其他方式保持一个或多个数据缓冲区，则必须确保在完全读取时释放它们，或者在读取和释放高速缓存数据缓冲区之前发生错误或取消信号。</p>
</li>
</ol>
<p>请注意， <code>DataBufferUtils#join</code>提供了一种安全有效的方法，可将数据缓冲区流聚合到单个数据缓冲区中。 同样，<code>skipUntilByteCount</code>和 <code>takeUntilByteCount</code>是解码器使用的其他安全方法。</p>
<p><code>Encoder</code>分配其他人必须读取（和释放）的数据缓冲区。 所以<code>Encoder</code>没什么可做的。 但是，如果在使用数据填充缓冲区时发生序列化错误，则<code>Encoder</code>必须注意释放数据缓冲区。 例如：</p>
<pre><code>DataBuffer buffer = factory.allocateBuffer();
boolean release = true;
try {
    // serialize and populate buffer..
    release = false;
}
finally {
    if (release) {
        DataBufferUtils.release(buffer);
    }
}
return buffer;
</code></pre>
<p><code>Encoder</code> 的使用者负责释放它接收的数据缓冲区。 在WebFlux应用程序中，Encoder的输出用于写入HTTP服务器响应或客户端HTTP请求， 在这种情况下，释放数据缓冲区是代码写入服务器响应或客户端的责任。 请求。</p>
<p>请注意，在Netty上运行时，可以使用调试选项来 <a href="https://github.com/netty/netty/wiki/Reference-counted-objects#troubleshooting-buffer-leaks">排除缓冲区泄漏</a>。</p>
</div></section><footer class="footer-container"><div class="footer-body"><img src="/img/jcohy.png"/><div class="cols-container"><div class="col col-12"><p>jia_chao23@126.com</p><p>https://www.github.com/jiachao23</p></div><div class="col col-6"><dl><dt>文档</dt><dd><a href="/zh-cn/docs/springframework/demo.html" target="_self">Spring Framework</a></dd><dd><a href="/zh-cn/docs/springboot/demo.html" target="_self">SpringBoot</a></dd><dd><a href="/zh-cn/docs/microservices/demo.html" target="_self">Microservices</a></dd></dl></div><div class="col col-6"><dl><dt>资源</dt><dd><a href="/zh-cn/blog/index.html" target="_self">博客</a></dd><dd><a href="/zh-cn/open/index.html" target="_self">开源项目</a></dd></dl></div></div><div class="copyright"><span>Copyright © 2019 www.jcohy.com</span></div></div></footer></div></div>
	<script src="https://f.alicdn.com/react/15.4.1/react-with-addons.min.js"></script>
	<script src="https://f.alicdn.com/react/15.4.1/react-dom.min.js"></script>
	<script>
		window.rootPath = '';
  </script>
	<script src="/build/documentation.js"></script>
</body>
</html>

{
  "filename": "socket.md",
  "__html": "<h2>重新实现旧版套接字API</h2>\n<h3>现有问题</h3>\n<p>重新实现了古老的 Socket 接口。现在已有的 java.net.Socket 和 java.net.ServerSocket 以及它们的实现类，都可以回溯到 JDK 1.0 时代了。</p>\n<ul>\n<li>它们的实现是混合了 Java 和 C 的代码的，维护和调试都很痛苦。</li>\n<li>实现类还使用了线程栈作为 I/O 的缓冲，导致在某些情况下还需要增加线程栈的大小。</li>\n<li>支持异步关闭，此操作是通过使用一个本地的数据结构来实现的，这种方式这些年也带来了潜在的不稳定性和跨平台移植问题。该实现还存在几个并发问题，需要彻底解决。\n在未来的网络世界，要快速响应，不能阻塞本地方法线程，当前的实现不适合使用了。</li>\n</ul>\n<h3>新的实现类</h3>\n<blockquote>\n<p>全新实现的 NioSocketImpl 来替换JDK1.0的PlainSocketImpl。</p>\n<ul>\n<li>它便于维护和调试，与 NewI/O (NIO) 使用相同的 JDK 内部结构，因此不需要使用系统本地代码。</li>\n<li>它与现有的缓冲区缓存机制集成在一起，这样就不需要为 I/O 使用线程栈。</li>\n<li>它使用 java.util.concurrent 锁，而不是 synchronized 同步方法，增强了并发能力。</li>\n<li>新的实现是Java 13中的默认实现，但是旧的实现还没有删除，可以通过设置系统属性jdk.net.usePlainSocketImpl来切换到旧版本。</li>\n</ul>\n</blockquote>\n<h3>使用</h3>\n<p>运行一个实例化Socket和ServerSocket的类将显示这个调试输出。这是默认的(新的)。</p>\n<pre><code class=\"language-java\">Module java.base\n    Package java.net\n    Class SocketImpl\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SocketImpl</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">SocketOptions</span> </span>{\n        <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">boolean</span> USE_PLAINSOCKETIMPL = usePlainSocketImpl();\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">usePlainSocketImpl</span><span class=\"hljs-params\">()</span> </span>{\n            PrivilegedAction&lt;String&gt; pa = () -&gt;\n                NetProperties.get(<span class=\"hljs-string\">\"jdk.net.usePlainSocketImpl\"</span>);\n            String s = AccessController.doPrivileged(pa);\n            <span class=\"hljs-keyword\">return</span> (s != <span class=\"hljs-keyword\">null</span>) &amp;&amp; !s.equalsIgnoreCase(<span class=\"hljs-string\">\"false\"</span>);\n        }\n        <span class=\"hljs-comment\">/**\n* Creates an instance of platform's SocketImpl\n*/</span>\n        <span class=\"hljs-meta\">@SuppressWarnings</span>(<span class=\"hljs-string\">\"unchecked\"</span>)\n        <span class=\"hljs-keyword\">static</span> &lt;S extends SocketImpl &amp; PlatformSocketImpl&gt; <span class=\"hljs-function\">S\n            <span class=\"hljs-title\">createPlatformSocketImpl</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">boolean</span> server)</span> </span>{\n            <span class=\"hljs-keyword\">if</span> (USE_PLAINSOCKETIMPL) {\n                <span class=\"hljs-keyword\">return</span> (S) <span class=\"hljs-keyword\">new</span> PlainSocketImpl(server);\n            } <span class=\"hljs-keyword\">else</span> {\n                <span class=\"hljs-keyword\">return</span> (S) <span class=\"hljs-keyword\">new</span> NioSocketImpl(server);\n            }\n        }\n    }\n</code></pre>\n<p>SocketImpl的USE_PLAINSOCKETIMPL取决于usePlainSocketImpl方法，而它会从NetProperties读取dk.net.usePlainSocketImpl配置，如果不为null且不为false，则usePlainSocketImpl方法返回true；createPlatformSocketImpl会根据USE_PLAINSOCKETIMPL来创建PlainSocketImpl或者NioSocketImpl。</p>\n",
  "link": "\\zh-cn\\docs\\java\\java13\\socket.html",
  "meta": {
    "title": "重新实现旧版套接字API",
    "keywords": "docs,jcohy-docs,重新实现旧版套接字API,java13",
    "description": "重新实现旧版套接字API"
  }
}
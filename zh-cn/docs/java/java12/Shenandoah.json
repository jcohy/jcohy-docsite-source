{
  "filename": "Shenandoah.md",
  "__html": "<h2>Shenandoah：一个低停顿垃圾收集器（实验阶段）</h2>\n<p>Java 12 中引入一个新的垃圾收集器：Shenandoah，它是作为一中低停顿时间的垃圾收集器而引入到 Java 12 中的，其工作原理是通过与 Java 应用程序中的执行线程同时运行，用以执行其垃圾收集、内存回收任务，通过这种运行方式，给虚拟机带来短暂的停顿时间。</p>\n<p>Shenandoah 垃圾回收器是 Red Hat 在 2014 年宣布进行的一项垃圾收集器研究项目，旨在针对 JVM 上的内存收回实现低停顿的需求。该设计将与应用程序线程并发，通过交换 CPU 并发周期和空间以改善停顿时间，使得垃圾回收器执行线程能够在 Java 线程运行时进行堆压缩，并且标记和整理能够同时进行，因此避免了在大多数 JVM 垃圾收集器中所遇到的问题。</p>\n<p>据 Red Hat 研发 Shenandoah 团队对外宣称，Shenandoah 垃圾回收器的暂停时间与堆大小无关，这意味着无论将堆设置为 200 MB 还是 200 GB，都将拥有一致的系统暂停时间，不过实际使用性能将取决于实际工作堆的大小和工作负载。</p>\n<h4>补充：SWT</h4>\n<p>Stop-the-World ，简称STW ，指的是GC 事件发生过程中，停止所有的应用程序线程的执行。就像警察办案，需要清场一样。</p>\n<p>垃圾回收器的任务是识别和回收垃圾对象进行内存清理。为了让垃圾回收器可以正常且高效地执行，大部分情况下会要求系统进入一个停顿的状态。停顿的目的是终止所有应用程序的执行，只有这样，系统中才不会有新的垃圾产生，同时停顿保证了系统状态在某一个瞬间的一致性，也有益于垃圾回收器更好地标记垃圾对象。因此，在垃圾回收时，都会产生应用程序的停顿。停顿产生时整个应用程序会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为STW 。\n如果Stop-the- World 出现在新生代的Minor GC 中时， 由于新生代的内存空间通常都比较小， 所以暂停时间也在可接受的合理范围之内，不过一旦出现在老年代的Full GC 中时，程序的工作线程被暂停的时间将会更久。简单来说，内存空间越大，执行Full GC 的时间就会越久， 相对的工作线程被暂停的时间也就会更长。</p>\n<p>到目前为止，哪怕是G1 也不能完全避免Stop-the-world 情况发生，只能说垃圾回收器越来越优秀，回收效率越来越高， 尽可能地缩短了暂停时间。</p>\n<h4>补充：垃圾收集器的分类</h4>\n<p>由于JDK 的版本处于高速迭代过程中，因此Java 发展至今已经衍生了众多的GC 版本。\n从不同角度分析垃圾收集器，可以将GC 分为不同的类型。</p>\n<ul>\n<li>\n<p>按线程数分，可以分为串行垃圾回收器和并行垃圾回收器。</p>\n<p><img src=\"https://github.com/jiachao23/jcohy-study-sample/blob/master/jcohy-study-java/images/java12-2.png\" alt=\"image-20191031183117417\"></p>\n<ul>\n<li>串行回收指的是在同一时间段内只允许一件事情发生，简单来说，当多个CPU 可用时，也只能有一个CPU\n用于执行垃圾回收操作，井且在执行垃圾回收时，程序中的工作线程将会被暂停，当垃圾收集工作完成后\n才会恢复之前被暂停的工作线程，这就是串行回收。</li>\n<li>和串行回收相反，并行收集可以运用多个CPU 同时执行垃圾回收，因此提升了应用的吞吐量，不过并行回\n收仍然与串行回收一样，采用独占式，使用了“ Stop-the-world ”机制和复制算法。</li>\n</ul>\n</li>\n<li>\n<p>按照工作模式分，可以分为并发式回收器和独占式垃圾回收器。</p>\n<ul>\n<li>并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间。</li>\n<li>独占式垃圾回收器（ Stop the world)一旦运行，就停止应用程序中的其他所有线程，直到垃圾回收过程完全结束。</li>\n</ul>\n</li>\n<li>\n<p>按碎片处理方式可分为压缩式垃圾回收器和非压缩式垃圾回收器。</p>\n<ul>\n<li>压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片。</li>\n<li>非压缩式的垃圾回收器不进行这步操作。</li>\n</ul>\n</li>\n<li>\n<p>按工作的内存区间，又可分为年轻代垃圾回收器和老年代垃圾回收器。</p>\n</li>\n</ul>\n<h4>补充：如何评估一款GC的性能</h4>\n<ul>\n<li>\n<p>吞吐量：程序的运行时间（程序的运行时间＋内存回收的时间）。</p>\n</li>\n<li>\n<p>垃圾收集开销：吞吐量的补数，垃圾收集器所占时间与总时间的比例。</p>\n</li>\n<li>\n<p>暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间。</p>\n</li>\n<li>\n<p>收集频率：相对于应用程序的执行，收集操作发生的频率。</p>\n</li>\n<li>\n<p>堆空间： Java 堆区所占的内存大小。</p>\n</li>\n<li>\n<p>快速： 一个对象从诞生到被回收所经历的时间。</p>\n</li>\n</ul>\n<p>需要注意的是， 垃圾收集器中吞吐量和低延迟这两个目标本身是相互矛盾的，因为如果选择以吞吐量优先，那么必然需要降低内存回收的执行频率，但是这样会导致GC 需要更长的暂停时间来执行内存回收。相反的，如果选择以低延迟优先为原则，那么为了降低每次执行内存回收时的暂停时间，也只能频繁地执行内存回收，但这又引起了年轻代内存的缩减和导致程序吞吐量的下降。</p>\n<h4>Shenandoah GC 工作周期如下所示:</h4>\n<p><img src=\"https://www.ibm.com/developerworks/cn/java/the-new-features-of-Java-12/image001.png\" alt=\"Shenandoah GC 工作周期如下\"></p>\n<p>上图对应工作周期如下：</p>\n<blockquote>\n<ol>\n<li>Init Mark 启动并发标记 阶段</li>\n<li>并发标记遍历堆阶段</li>\n<li>并发标记完成阶段</li>\n<li>并发整理回收无活动区域阶段</li>\n<li>并发 Evacuation 整理内存区域阶段</li>\n<li>Init Update Refs 更新引用初始化 阶段</li>\n<li>并发更新引用阶段</li>\n<li>Final Update Refs 完成引用更新阶段</li>\n<li>并发回收无引用区域阶段</li>\n</ol>\n</blockquote>\n<p>需要了解不是唯有 GC 停顿可能导致常规应用程序响应时间比较长。具有较长的 GC 停顿时间会导致系统响应慢的问题，但响应时间慢并非一定是 GC 停顿时间长导致的，队列延迟、网络延迟、其他依赖服务延迟和操作提供调度程序抖动等都可能导致响应变慢。使用 Shenandoah 时需要全面了解系统运行情况，综合分析系统响应时间。各种 GC 工作负载对比如下所示：</p>\n<h4>各种 GC 工作负载对比</h4>\n<p><img src=\"https://www.ibm.com/developerworks/cn/java/the-new-features-of-Java-12/image002.png\" alt=\"\">\n下面推荐几个配置或调试 Shenandoah 的 JVM 参数:</p>\n<ul>\n<li><code>-XX:+AlwaysPreTouch</code>：使用所有可用的内存分页，减少系统运行停顿，为避免运行时性能损失。</li>\n<li><code>-Xmx == -Xmsv</code>：设置初始堆大小与最大值一致，可以减轻伸缩堆大小带来的压力，与 <code>AlwaysPreTouch</code> 参数配合使用，在启动时提交所有内存，避免在最终使用中出现系统停顿。</li>\n<li><code>-XX:+ UseTransparentHugePages</code>：能够大大提高大堆的性能，同时建议在 Linux 上使用时将<code>/sys/kernel/mm/transparent_hugepage/enabled</code> 和 <code>/sys/kernel/mm/transparent_hugepage/defragv</code> 设置为：<code>madvise</code>，同时与 <code>AlwaysPreTouch</code> 一起使用时，<code>init</code> 和 <code>shutdownv</code> 速度会更快，因为它将使用更大的页面进行预处理。</li>\n<li><code>-XX:+UseNUMA</code>：虽然 <code>Shenandoah</code> 尚未明确支持 NUMA（Non-Uniform Memory Access），但最好启用此功能以在多插槽主机上启用 NUMA 交错。与 <code>AlwaysPreTouch</code> 相结合，它提供了比默认配置更好的性能。</li>\n<li><code>-XX:+DisableExplicitGC</code>：忽略代码中的 <code>System.gc()</code> 调用。当用户在代码中调用 <code>System.gc()</code> 时会强制 Shenandoah 执行 STW Full GC ，应禁用它以防止执行此操作，另外还可以使用 <code>-XX:+ExplicitGCInvokesConcurrent</code>，在 调用 <code>System.gc()</code> 时执行 CMS GC 而不是 Full GC，建议在有 <code>System.gc()</code> 调用的情况下使用。</li>\n</ul>\n<p>不过目前 Shenandoah 垃圾回收器还被标记为实验项目，需要使用参数：<code>- XX:+UnlockExperimentalVMOptions</code> 启用。更多有关如何配置、调试 Shenandoah 的信息，请参阅 <a href=\"https://wiki.openjdk.java.net/display/shenandoah\">henandoah wiki</a>。</p>\n",
  "link": "\\zh-cn\\docs\\java\\java12\\Shenandoah.html",
  "meta": {
    "title": "Shenandoah：一个低停顿垃圾收集器（实验阶段）",
    "keywords": "docs,jcohy-docs,Shenandoah，java12",
    "description": "Shenandoah：一个低停顿垃圾收集器（实验阶段）"
  }
}
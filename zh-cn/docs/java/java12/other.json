{
  "filename": "other.md",
  "__html": "<h2>其他特性</h2>\n<h3>支持unicode 11</h3>\n<blockquote>\n<p>JDK 12版本包括对Unicode 11.0.0的支持。在发布支持Unicode 10.0.0的JDK 11之后，Unicode 11.0.0引\n入了以下JDK 12中包含的新功能：\n684 new characters\n11 new blocks\n7 new scripts.\n其中：\n684个新字符，包含以下重要内容：\n66个表情符号字符（66 emoji characters）\nCopyleft符号（Copyleft symbol）\n评级系统的半星（Half stars for rating systems）\n额外的占星符号（Additional astrological symbols）\n象棋中国象棋符号（Xiangqi Chinese chess symbols）\n7个新脚本：\nHanifi Rohingya\nOld Sogdian\nSogdian\nDogra\nGunjala Gondi\nMakasar\nMedefaidrin\n11个新块，包括上面列出的新脚本的7个块和以下现有脚本的4个块：\n格鲁吉亚扩展（Georgian Extended）\n玛雅数字（Mayan Numerals）\n印度Siyaq数字（Indic Siyaq Numbers）\n国际象棋符号（Chess Symbols）</p>\n</blockquote>\n<h3>支持压缩数字格式化</h3>\n<p>NumberFormat 添加了对以紧凑形式格式化数字的支持。紧凑数字格式是指以简短或人类可读形式表示的数字。例如，在en_US语言环境中，1000可以格式化为“1K”，1000000可以格式化为“1M”，具体取决于指定的样式NumberFormat.Style。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Test</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">testCompactNumberFormat</span><span class=\"hljs-params\">()</span></span>{\n    <span class=\"hljs-keyword\">var</span> cnf = NumberFormat.getCompactNumberInstance(Locale.CHINA,\n                                                    NumberFormat.Style.SHORT);\n    System.out.println(cnf.format(<span class=\"hljs-number\">1_0000</span>));\n    System.out.println(cnf.format(<span class=\"hljs-number\">1_9200</span>));\n    System.out.println(cnf.format(<span class=\"hljs-number\">1_000_000</span>));\n    System.out.println(cnf.format(<span class=\"hljs-number\">1L</span> &lt;&lt; <span class=\"hljs-number\">30</span>));\n    System.out.println(cnf.format(<span class=\"hljs-number\">1L</span> &lt;&lt; <span class=\"hljs-number\">40</span>));\n    System.out.println(cnf.format(<span class=\"hljs-number\">1L</span> &lt;&lt; <span class=\"hljs-number\">50</span>));\n}\n</code></pre>\n<p>输出</p>\n<pre><code class=\"language-java\"><span class=\"hljs-number\">1</span>万\n<span class=\"hljs-number\">2</span>万\n<span class=\"hljs-number\">100</span>万\n<span class=\"hljs-number\">11</span>亿\n<span class=\"hljs-number\">1</span>兆\n<span class=\"hljs-number\">1126</span>兆\n</code></pre>\n<h3>String新增方法</h3>\n<h4>String#transform(Function)</h4>\n<p>JDK-8203442引入的一个小方法，它提供的函数作为输入提供给特定的String实例，并返回该函数返回的输出。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">var</span> result = <span class=\"hljs-string\">\"foo\"</span>.transform(input -&gt; input + <span class=\"hljs-string\">\" bar\"</span>);\nSystem.out.println(result); <span class=\"hljs-comment\">// foo bar</span>\n</code></pre>\n<p>或者</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">var</span> result = <span class=\"hljs-string\">\"foo\"</span>\n    .transform(input -&gt; input + <span class=\"hljs-string\">\" bar\"</span>)\n    .transform(String::toUpperCase)\n    System.out.println(result); <span class=\"hljs-comment\">// FOO BAR</span>\n</code></pre>\n<p>对应源码</p>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">/**\n* This method allows the application of a function to {<span class=\"hljs-doctag\">@code</span> this}\n* string. The function should expect a single String argument\n* and produce an {<span class=\"hljs-doctag\">@code</span> R} result.\n* &lt;p&gt;\n* Any exception thrown by {<span class=\"hljs-doctag\">@code</span> f()} will be propagated to the\n* caller.\n*\n* <span class=\"hljs-doctag\">@param</span> f functional interface to a apply\n*\n* <span class=\"hljs-doctag\">@param</span> &lt;R&gt; class of the result\n*\n* <span class=\"hljs-doctag\">@return</span> the result of applying the function to this string\n*\n* <span class=\"hljs-doctag\">@see</span> java.util.function.Function\n*\n* <span class=\"hljs-doctag\">@since</span> 12\n*/</span>\n<span class=\"hljs-keyword\">public</span> &lt;R&gt; <span class=\"hljs-function\">R <span class=\"hljs-title\">transform</span><span class=\"hljs-params\">(Function&lt;? <span class=\"hljs-keyword\">super</span> String, ? extends R&gt; f)</span> </span>{\n    <span class=\"hljs-keyword\">return</span> f.apply(<span class=\"hljs-keyword\">this</span>);\n}\n</code></pre>\n<p>传入一个函数式接口 Function，接受一个值，返回一个值，参考：Java 8 新特性之函数式接口。\n在某种情况下，该方法应该被称为map()。\n举例：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">testTransform</span><span class=\"hljs-params\">()</span> </span>{\n    System.out.println(<span class=\"hljs-string\">\"======test java 12 transform======\"</span>);\n    List&lt;String&gt; list1 = List.of(<span class=\"hljs-string\">\"Java\"</span>, <span class=\"hljs-string\">\" Python\"</span>, <span class=\"hljs-string\">\" C++ \"</span>);\n    List&lt;String&gt; list2 = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();\n    list1.forEach(element -&gt; list2.add(element.transform(String::strip)\n                                       .transform(String::toUpperCase)\n                                       .transform((e) -&gt; <span class=\"hljs-string\">\"Hi,\"</span> + e))\n                 );\n    list2.forEach(System.out::println);\n}\n</code></pre>\n<p>结果输出</p>\n<pre><code class=\"language-java\">======test java <span class=\"hljs-number\">12</span> transform======\n    Hi,JAVA\n    Hi,PYTHON\n    Hi,C++\n</code></pre>\n<p>示例是对一个字符串连续转换了三遍，代码很简单。如果使用Java 8的Stream特性，可以如下实现：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">testTransform1</span><span class=\"hljs-params\">()</span> </span>{\n    System.out.println(<span class=\"hljs-string\">\"======test before java 12 ======\"</span>);\n    List&lt;String&gt; list1 = List.of(<span class=\"hljs-string\">\"Java \"</span>, <span class=\"hljs-string\">\" Python\"</span>, <span class=\"hljs-string\">\" C++ \"</span>);\n    Stream&lt;String&gt; stringStream = list1.stream().map(element -&gt;\n                                                     element.strip()).map(String::toUpperCase).map(element -&gt; <span class=\"hljs-string\">\"Hello,\"</span> + element);\n    List&lt;String&gt; list2 = stringStream.collect(Collectors.toList());\n    list2.forEach(System.out::println);\n}\n</code></pre>\n<h4>String#indent</h4>\n<p>该方法允许我们调整String实例的缩进。\n举例：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">testIndent</span><span class=\"hljs-params\">()</span> </span>{\n    System.out.println(<span class=\"hljs-string\">\"======test java 12 indent======\"</span>);\n    String result = <span class=\"hljs-string\">\"Java\\n Python\\nC++\"</span>.indent(<span class=\"hljs-number\">3</span>);\n    System.out.println(result);\n}\n</code></pre>\n<p>结果输出：</p>\n<pre><code class=\"language-java\">======test java <span class=\"hljs-number\">12</span> indent======\nJava\n\tPython\nC++\n</code></pre>\n<p>换行符 \\n 后向前缩进 n 个空格，为 0 或负数不缩进。\n以下是 indent 的核心源码：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">/**\n* Adjusts the indentation of each line of this string based on the value of\n* {<span class=\"hljs-doctag\">@code</span> n}, and normalizes line termination characters.\n* &lt;p&gt;\n* This string is conceptually separated into lines using\n* {<span class=\"hljs-doctag\">@link</span> String#lines()}. Each line is then adjusted as described below\n* and then suffixed with a line feed {<span class=\"hljs-doctag\">@code</span> \"\\n\"} (U+000A). The resulting\n* lines are then concatenated and returned.\n* ...略...\n*\n* <span class=\"hljs-doctag\">@since</span> 12\n*/</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">indent</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> n)</span> </span>{\n    <span class=\"hljs-keyword\">if</span> (isEmpty()) {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"\"</span>;\n    }\n    Stream&lt;String&gt; stream = lines();\n    <span class=\"hljs-keyword\">if</span> (n &gt; <span class=\"hljs-number\">0</span>) {\n        <span class=\"hljs-keyword\">final</span> String spaces = <span class=\"hljs-string\">\" \"</span>.repeat(n);\n        stream = stream.map(s -&gt; spaces + s);\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (n == Integer.MIN_VALUE) {\n        stream = stream.map(s -&gt; s.stripLeading());\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (n &lt; <span class=\"hljs-number\">0</span>) {\n        stream = stream.map(s -&gt; s.substring(Math.min(-n,\n                                                      s.indexOfNonWhitespace())));\n    }\n    <span class=\"hljs-keyword\">return</span> stream.collect(Collectors.joining(<span class=\"hljs-string\">\"\\n\"</span>, <span class=\"hljs-string\">\"\"</span>, <span class=\"hljs-string\">\"\\n\"</span>));\n}\n</code></pre>\n<p>其实就是调用了 lines() 方法来创建一个 Stream，然后再往前拼接指定数量的空格。</p>\n<h4>Files新增mismatch方法</h4>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Test</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">testFilesMismatch</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> IOException </span>{\n    FileWriter fileWriter = <span class=\"hljs-keyword\">new</span> FileWriter(<span class=\"hljs-string\">\"tmp\\\\a.txt\"</span>);\n    fileWriter.write(<span class=\"hljs-string\">\"a\"</span>);\n    fileWriter.write(<span class=\"hljs-string\">\"b\"</span>);\n    fileWriter.write(<span class=\"hljs-string\">\"c\"</span>);\n    fileWriter.close();\n    FileWriter fileWriterB = <span class=\"hljs-keyword\">new</span> FileWriter(<span class=\"hljs-string\">\"tmp\\\\b.txt\"</span>);\n    fileWriterB.write(<span class=\"hljs-string\">\"a\"</span>);\n    fileWriterB.write(<span class=\"hljs-string\">\"1\"</span>);\n    fileWriterB.write(<span class=\"hljs-string\">\"c\"</span>);\n    fileWriterB.close();\n    System.out.println(Files.mismatch(Path.of(<span class=\"hljs-string\">\"tmp/a.txt\"</span>),Path.of(<span class=\"hljs-string\">\"tmp/b.txt\"</span>)));\n}\n</code></pre>\n<h4>其他</h4>\n<ul>\n<li>Collectors新增teeing方法用于聚合两个downstream的结果</li>\n<li>CompletionStage新增exceptionallyAsync、exceptionallyComposeAsync方法，允许方法体在异步线程执行，同时新增了exceptionallyCompose方法支持在exceptionally的时候构建新的CompletionStage。</li>\n<li>ZGC: Concurrent Class Unloading\n<ul>\n<li>ZGC在JDK11的时候还不支持class unloading，JDK12对ZGC支持了Concurrent Class Unloading，默认是开启，使用-XX:-ClassUnloading可以禁用</li>\n</ul>\n</li>\n<li>新增-XX:+ExtensiveErrorReports\n<ul>\n<li>-XX:+ExtensiveErrorReports可以用于在jvm crash的时候收集更多的报告信息到hs_err.log文件中，product builds中默认是关闭的，要开启的话，需要自己添加-XX:+ExtensiveErrorReports参数</li>\n</ul>\n</li>\n<li>新增安全相关的改进\n<ul>\n<li>支持java.security.manager系统属性，当设置为disallow的时候，则不使用SecurityManager以提升性能，如果此时调用System.setSecurityManager则会抛出UnsupportedOperationExceptionkeytool新增-groupname选项允许在生成key pair的时候指定一个named group新增PKCS12 KeyStore配置属性用于自定义PKCS12 keystores的生成Java Flight Recorder新增了security-related的event支持ChaCha20 and Poly1305 TLS Cipher Suites</li>\n</ul>\n</li>\n</ul>\n<h4>移除项</h4>\n<ul>\n<li>移除com.sun.awt.SecurityWarnin；</li>\n<li>移除FileInputStream、FileOutputStream、- Java.util.ZipFile/Inflator/Deflator的finalize方法；</li>\n<li>移除GTE CyberTrust Global Root；</li>\n<li>移除javac的-source, -target对6及1.6的支持，同时移除--release选项；</li>\n</ul>\n<h4>废弃项</h4>\n<ul>\n<li>废弃的API列表见deprecated-list</li>\n<li>废弃-XX:+/-MonitorInUseLists选项</li>\n<li>废弃Default Keytool的-keyalg值</li>\n</ul>\n",
  "link": "\\zh-cn\\docs\\java\\java12\\other.html",
  "meta": {
    "title": "其他特性",
    "keywords": "docs,jcohy-docs,其他特性，java12",
    "description": "其他特性"
  }
}
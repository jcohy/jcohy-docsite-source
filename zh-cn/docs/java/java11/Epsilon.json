{
  "filename": "Epsilon.md",
  "__html": "<h2>Epsilon：低开销垃圾回收器</h2>\n<p>Epsilon 垃圾回收器的目标是开发一个控制内存分配，但是不执行任何实际的垃圾回收工作。它提供一个完全消极的 GC 实现，分配有限的内存资源，最大限度的降低内存占用和内存吞吐延迟时间。</p>\n<p>Java 版本中已经包含了一系列的高度可配置化的 GC 实现。各种不同的垃圾回收器可以面对各种情况。但是有些时候使用一种独特的实现，而不是将其堆积在其他 GC 实现上将会是事情变得更加简单。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Garbage</span> </span>{\n\t<span class=\"hljs-keyword\">int</span> n = (<span class=\"hljs-keyword\">int</span>)(Math.random() * <span class=\"hljs-number\">100</span>);\n\t<span class=\"hljs-meta\">@Override</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">finalize</span><span class=\"hljs-params\">()</span> </span>{\n\t\tSystem.out.println(<span class=\"hljs-keyword\">this</span> + <span class=\"hljs-string\">\" : \"</span> + n + <span class=\"hljs-string\">\" is dying\"</span>);\n\t}\n}\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">EpsilonTest</span> </span>{\n\t\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n\t\t<span class=\"hljs-keyword\">boolean</span> flag = <span class=\"hljs-keyword\">true</span>;\n\t\tList&lt;Garbage&gt; list = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();\n\t\t<span class=\"hljs-keyword\">long</span> count = <span class=\"hljs-number\">0</span>;\n\t\t<span class=\"hljs-keyword\">while</span> (flag) {\n\t\t\tlist.add(<span class=\"hljs-keyword\">new</span> Garbage());\n\t\t\t<span class=\"hljs-keyword\">if</span> (list.size() == <span class=\"hljs-number\">1000000</span> &amp;&amp; count == <span class=\"hljs-number\">0</span>) {\n\t\t\t\tlist.clear();\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(<span class=\"hljs-string\">\"程序结束\"</span>);\n\t}\n}\n\n</code></pre>\n<p>如果使用选项-XX:+UseEpsilonGC, 程序很快就因为堆空间不足而退出</p>\n<p>下面是 no-op GC 的几个使用场景：</p>\n<ul>\n<li>性能测试：什么都不执行的 GC 非常适合用于 GC 的差异性分析。no-op （无操作）GC 可以用于过滤掉 GC 诱发的性能损耗，比如 GC 线程的调度，GC 屏障的消耗，GC 周期的不合适触发，内存位置变化等。此外有些延迟者不是由于 GC 引起的，比如 scheduling hiccups, compiler transition hiccups，所以去除 GC 引发的延迟有助于统计这些延迟。</li>\n<li>内存压力测试：在测试 Java 代码时，确定分配内存的阈值有助于设置内存压力常量值。这时 no-op 就很有用，它可以简单地接受一个分配的内存分配上限，当内存超限时就失败。例如：测试需要分配小于 1G 的内存，就使用-Xmx1g 参数来配置 no-op GC，然后当内存耗尽的时候就直接 crash。</li>\n<li>VM 接口测试：以 VM 开发视角，有一个简单的 GC 实现，有助于理解 VM-GC 的最小接口实现。它也用于证明 VM-GC 接口的健全性。</li>\n<li>极度短暂 job 任务：一个短声明周期的 job 任务可能会依赖快速退出来释放资源，这个时候接收 GC 周期来清理 heap 其实是在浪费时间，因为 heap 会在退出时清理。并且 GC 周期可能会占用一会时间，因为它依赖 heap 上的数据量。</li>\n<li>延迟改进：对那些极端延迟敏感的应用，开发者十分清楚内存占用，或者是几乎没有垃圾回收的应用，此时耗时较长的 GC 周期将会是一件坏事。</li>\n<li>吞吐改进：即便对那些无需内存分配的工作，选择一个 GC 意味着选择了一系列的 GC 屏障，所有的 OpenJDK GC 都是分代的，所以他们至少会有一个写屏障。避免这些屏障可以带来一点点的吞吐量提升。\nEpsilon 垃圾回收器和其他 OpenJDK 的垃圾回收器一样，可以通过参数 -XX:+UseEpsilonGC 开启。</li>\n</ul>\n<p>Epsilon 线性分配单个连续内存块。可复用现存 VM 代码中的 TLAB 部分的分配功能。非 TLAB 分配也是同一段代码，因为在此方案中，分配 TLAB 和分配大对象只有一点点的不同。Epsilon 用到的 barrier 是空的(或者说是无操作的)。因为该 GC</p>\n<p>执行任何的 GC 周期，不用关系对象图，对象标记，对象复制等。引进一种新的 barrier-set 实现可能是该 GC 对 JVM 最大的变化。</p>\n",
  "link": "\\zh-cn\\docs\\java\\java11\\Epsilon.html",
  "meta": {
    "title": "Epsilon：低开销垃圾回收器",
    "keywords": "docs,jcohy-docs,Epsilon,java11",
    "description": "Epsilon：低开销垃圾回收器"
  }
}
<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<meta name="keywords" content="mvc" />
	<meta name="description" content="mvc" />
	<!-- 网页标签标题 -->
	<title>mvc</title>
	<link rel="shortcut icon" href="/img/jcohy.ico"/>
	<link rel="stylesheet" href="/build/documentation.css" />
</head>
<body>
	<div id="root"><div class="documentation-page" data-reactroot=""><header class="header-container header-container-normal"><div class="header-body"><a href="/en-us/index.html"><img class="logo" src="/img/jcohy_colorful.png"/></a><div class="search search-normal"><span class="icon-search"></span></div><span class="language-switch language-switch-normal">中</span><div class="header-menu"><img class="header-menu-toggle" src="/img/system/menu_gray.png"/><ul><li class="menu-item menu-item-normal"><a href="/en-us/index.html" target="_self">HOME</a></li><li class="menu-item menu-item-normal menu-item-normal-active"><a href="/en-us/docs/Overview.html" target="_self">DOCS</a></li><li class="menu-item menu-item-normal"><a href="/en-us/blog/index.html" target="_self">BLOG</a></li><li class="menu-item menu-item-normal"><a href="/en-us/open/index.html" target="_self">OPEN RESOURCE</a></li><li class="menu-item menu-item-normal"><a href="/en-us/resource/index.html" target="_self">RESOURCE</a></li><li class="menu-item menu-item-normal"><a href="/en-us/community/index.html" target="_self">COMMUNITY</a></li></ul></div></div></header><div class="bar"><div class="bar-body"><img src="/img/system/docs.png" class="front-img"/><span>Documentation</span><img src="/img/system/docs.png" class="back-img"/></div></div><section class="content-section"><div class="sidemenu"><div class="sidemenu-toggle"><img src="https://img.alicdn.com/tfs/TB1E6apXHGYBuNjy0FoXXciBFXa-200-200.png"/></div><ul><li class="menu-item menu-item-level-1"><span>Overview</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/en-us/docs/Overview.html" target="_self">Overview</a></li></ul></li><li class="menu-item menu-item-level-1"><span>Spring Framework</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/en-us/docs/springframework/demo.html" target="_self">Spring Framework</a></li></ul></li><li class="menu-item menu-item-level-1"><span>SpringBoot</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/en-us/docs/springboot/demo.html" target="_self">SpringBoot</a></li></ul></li><li class="menu-item menu-item-level-1"><span>nginx</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/en-us/docs/nginx/demo.html" target="_self">nginx</a></li></ul></li><li class="menu-item menu-item-level-1"><span>Microservices</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/en-us/docs/microservices/demo.html" target="_self">Microservices</a></li></ul></li></ul></div><div class="doc-content markdown-body"><p><a id="mvc"></a></p>
<h2><a href="#mvc"></a>1. Spring Web MVC</h2>
<p>Spring Web MVC是构建在Servlet API上的原始Web框架，从一开始就包含在Spring Framework中。 正式名称 “Spring Web MVC,” 来自其源模块(<a href="https://github.com/spring-projects/spring-framework/tree/master/spring-webmvc"><code>spring-webmvc</code></a>)的名称，但它通常被称为“Spring MVC”。</p>
<p>与Spring Web MVC并行，Spring Framework 5.0引入了一个反应堆栈Web框架，其名称“Spring WebFlux,”也基于其源模块(<a href="https://github.com/spring-projects/spring-framework/tree/master/spring-webflux"><code>spring-webflux</code></a>)。 本节介绍Spring Web MVC。 <a href="web-reactive.html#spring-web-reactive">下一节</a>将介绍Spring WebFlux。.</p>
<p>有关基本信息以及与Servlet容器和Java EE版本范围的兼容性，请参阅Spring Framework <a href="https://github.com/spring-projects/spring-framework/wiki/Spring-Framework-Versions">Wiki</a>。</p>
<p><a id="mvc-servlet"></a></p>
<h3><a href="#mvc-servlet"></a>1.1. DispatcherServlet</h3>
<p><a href="web-reactive.html#webflux-dispatcher-handler">与Spring WebFlux相同</a></p>
<p>Spring MVC和许多其他Web框架一样，围绕前端控制器模式设计，其中核心 <code>Servlet``DispatcherServlet</code>为请求处理提供共享算法，而实际工作由可配置委托组件执行。 该模型非常灵活，支持多种工作流程。</p>
<p><code>DispatcherServlet</code>与任何 <code>Servlet</code>一样，需要使用Java配置或 <code>web.xml</code>根据Servlet规范进行声明和映射。 反过来，<code>DispatcherServlet</code>使用Spring配置来发现请求映射，视图解析，异常处理 <a href="#mvc-servlet-special-bean-types">等等</a>所需的委托组件。</p>
<p>下面的Java配置示例注册并初始化<code>DispatcherServlet</code>，它由Servlet容器自动检测（请参阅<a href="#mvc-container-config">Servlet Config</a>）：</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyWebApplicationInitializer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebApplicationInitializer</span> </span>{

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStartup</span><span class="hljs-params">(ServletContext servletCxt)</span> </span>{

        <span class="hljs-comment">// Load Spring web application configuration</span>
        AnnotationConfigWebApplicationContext ac = <span class="hljs-keyword">new</span> AnnotationConfigWebApplicationContext();
        ac.register(AppConfig<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
        ac.refresh();

        <span class="hljs-comment">// Create and register the DispatcherServlet</span>
        DispatcherServlet servlet = <span class="hljs-keyword">new</span> DispatcherServlet(ac);
        ServletRegistration.Dynamic registration = servletCxt.addServlet(<span class="hljs-string">"app"</span>, servlet);
        registration.setLoadOnStartup(<span class="hljs-number">1</span>);
        registration.addMapping(<span class="hljs-string">"/app/*"</span>);
    }
}
</code></pre>
<p>除了直接使用ServletContext API之外，您还可以扩展<code>AbstractAnnotationConfigDispatcherServletInitializer</code> 并覆盖特定方法（请参阅<a href="#mvc-servlet-context-hierarchy">Context Hierarchy</a>下的示例）。</p>
<p>以下<code>web.xml</code>配置示例注册并初始化<code>DispatcherServlet</code>:</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>/WEB-INF/app-context.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>app<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>app<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/app/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span>
</code></pre>
<p>Spring Boot遵循不同的初始化顺序。 Spring Boot使用Spring配置来引导自身和嵌入式Servlet容器，而不是挂钩到Servlet容器的生命周期。 在Spring配置中检测<code>Filter</code> 和<code>Servlet</code>声明，并在Servlet容器中注册。 有关更多详细信息，请参阅[Spring Boot</p>
<p>documentation](<a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-embedded-container">https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-embedded-container</a>)文档。</p>
<p><a id="mvc-servlet-context-hierarchy"></a></p>
<h4><a href="#mvc-servlet-context-hierarchy"></a>1.1.1. 上下文层次结构</h4>
<p><code>DispatcherServlet</code>需要一个 <code>WebApplicationContext</code>（ApplicationContext的扩展）来配置自己。 <code>WebApplicationContext</code>有一个指向<code>ServletContext</code>的链接以及与之关联的 <code>Servlet</code>。 它还绑定到<code>ServletContext</code>，当需要访问它时，应用程序可以使用<code>RequestContextUtils</code>上的静态方法来查找<code>WebApplicationContext</code>。</p>
<p>对于许多应用程序，拥有一个简单的 <code>WebApplicationContext</code>已经足够了。它也有一个上下文层次结构，其中根<code>WebApplicationContext</code>在多个 <code>DispatcherServlet</code>（或其他 <code>Servlet</code>）实例之间共享， 每个实例都有自己的子<code>WebApplicationContext</code>配置。 有关上下文层次结构功能的更多信息，请参阅<a href="core.html#context-introduction"><code>ApplicationContext</code>的其他功能</a>。</p>
<p>根WebApplicationContext通常包含bean基础结构，例如需要跨多个Servlet实例共享的数据存储库和业务服务。 这些bean被有效继承，可以在特定于 <code>Servlet</code>的子<code>WebApplicationContext</code>中重写（即重新声明），它通常包含给定<code>Servlet</code>本地的bean。 下图显示了这种关系：</p>
<p><img src="https://github.com/DocsHome/spring-docs/blob/master/pages/images/mvc-context-hierarchy.png" alt="mvc context hierarchy"></p>
<p>以下示例配置<code>WebApplicationContext</code>层次结构:</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyWebAppInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractAnnotationConfigDispatcherServletInitializer</span> </span>{

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Class&lt;?&gt;[] { RootConfig<span class="hljs-class">.<span class="hljs-keyword">class</span> }</span>;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Class&lt;?&gt;[] { App1Config<span class="hljs-class">.<span class="hljs-keyword">class</span> }</span>;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">protected</span> String[] getServletMappings() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String[] { <span class="hljs-string">"/app1/*"</span> };
    }
}
</code></pre>
<p>如果不需要应用程序上下文层次结构，则应用程序可以通过<code>getRootConfigClasses()</code> 返回所有配置，并从<code>getServletConfigClasses()</code>返回<code>null</code>。</p>
<p>以下示例显示了<code>web.xml</code>配置（和上面效果一样）:</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>/WEB-INF/root-context.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>app1<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>/WEB-INF/app1-context.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>app1<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/app1/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span>
</code></pre>
<p>如果不需要应用程序上下文层次结构，则应用程序可以仅配置“root”上下文，并将 <code>contextConfigLocation</code> Servlet参数保留为空。</p>
<p><a id="mvc-servlet-special-bean-types"></a></p>
<h4><a href="#mvc-servlet-special-bean-types"></a>1.1.2. 特殊的Bean类型</h4>
<p><a href="web-reactive.html#webflux-special-bean-types">Same as in Spring WebFlux</a></p>
<p><code>DispatcherServlet</code> 委托特殊bean处理请求并渲染视图。 “特殊bean”是指实现WebFlux框架的Spring管理的<code>Object</code>实例。 这些通常带有内置联系，但您可以自定义其属性并扩展或替换它们。</p>
<p>下表列出了<code>DispatcherHandler</code>检测到的特殊bean:</p>
<table>
<thead>
<tr>
<th>Bean 类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>HandlerMapping</code></td>
<td>将请求映射到处理程序以及用于预处理和后处理的<a href="#mvc-handlermapping-interceptor">拦截器</a>列表。 其映射规则基于某些标准，其细节因<code>HandlerMapping</code>实现而异。两个主要的<code>HandlerMapping</code>实现是<code>RequestMappingHandlerMapping</code>（它支持<code>@RequestMapping</code>带注解的方法） 和<code>SimpleUrlHandlerMapping</code> （它维护对处理程序的URI路径模式的显式注册）。</td>
</tr>
<tr>
<td><code>HandlerAdapter</code></td>
<td>无论实际调用处理程序如何，都可以帮助<code>DispatcherServlet</code> 调用映射到请求的处理程序。 例如，调用带有注解的控制器，需要从注解中解析一些信息。 <code>HandlerAdapter</code>的主要目的是保护<code>DispatcherServlet</code>不受此类细节的影响。</td>
</tr>
<tr>
<td><a href="#mvc-exceptionhandlers"><code>HandlerExceptionResolver</code></a></td>
<td>解决异常的策略，他可以将捕获到的异常映射到处理程序，HTML错误视图或其他目标。 请参阅<a href="#mvc-exceptionhandlers">Exceptions</a>。</td>
</tr>
<tr>
<td><a href="#mvc-viewresolver"><code>ViewResolver</code></a></td>
<td>将从处理程序返回的逻辑基于<code>String</code>的视图名称解析为用于呈现给响应的实际<code>View</code>。 请参阅 <a href="#mvc-viewresolver">View Resolution</a> and <a href="#mvc-view">View Technologies</a>。</td>
</tr>
<tr>
<td><a href="#mvc-localeresolver"><code>LocaleResolver</code></a>, <a href="#mvc-timezone">LocaleContextResolver</a></td>
<td>解析客户端正在使用的 <code>Locale</code>以及可能的时区，以便能够提供国际化视图。 请参阅<a href="#mvc-localeresolver">Locale</a>。</td>
</tr>
<tr>
<td><a href="#mvc-themeresolver"><code>ThemeResolver</code></a></td>
<td>解决Web应用程序可以使用的主题 - 例如，提供个性化布局。 见<a href="#mvc-themeresolver">Themes</a>。</td>
</tr>
<tr>
<td><a href="#mvc-multipart"><code>MultipartResolver</code></a></td>
<td>解析multi-part的请求（例如：浏览器表单文件上载）。请参阅<a href="#mvc-multipart">Multipart Resolver</a>。</td>
</tr>
<tr>
<td><a href="#mvc-flash-attributes"><code>FlashMapManager</code></a></td>
<td>存储和检索“input” 和“output”<code>FlashMap</code>，可用于将属性从一个请求传递到另一个请求，通常是通过重定向。 请参阅<a href="#mvc-flash-attributes">Flash Attributes</a>。</td>
</tr>
</tbody>
</table>
<p><a id="mvc-servlet-config"></a></p>
<h4><a href="#mvc-servlet-config"></a>1.1.3. Web MVC 配置</h4>
<p><a href="web-reactive.html#webflux-framework-config">Same as in Spring WebFlux</a></p>
<p>对于每种类型的<a href="#mvc-servlet-special-bean-types">特殊bean</a>， <code>DispatcherServlet</code>首先会检查<code>WebApplicationContext</code>。如果没有匹配的bean类型，则会退回检查<a href="https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/resources/org/springframework/web/servlet/DispatcherServlet.properties"><code>DispatcherServlet.properties</code></a>。</p>
<p>在大多数情况下，<a href="#mvc-config">MVC Config</a>是最佳起点。 它以Java或XML声明所需的bean，并提供更高级别的配置回调API来自定义它。</p>
<p>Spring Boot依赖于MVC Java配置来配置Spring MVC并提供许多额外的便捷选项。</p>
<p><a id="mvc-container-config"></a></p>
<h4><a href="#mvc-container-config"></a>1.1.4. Servlet 配置</h4>
<p>在Servlet 3.0+环境中，您可以选择以编程方式配置Servlet容器作为替代方法，也可以与<code>web.xml</code>文件结合使用。 以下示例注册<code>DispatcherServlet</code>:</p>
<pre><code class="language-java"><span class="hljs-keyword">import</span> org.springframework.web.WebApplicationInitializer;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyWebApplicationInitializer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebApplicationInitializer</span> </span>{

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStartup</span><span class="hljs-params">(ServletContext container)</span> </span>{
        XmlWebApplicationContext appContext = <span class="hljs-keyword">new</span> XmlWebApplicationContext();
        appContext.setConfigLocation(<span class="hljs-string">"/WEB-INF/spring/dispatcher-config.xml"</span>);

        ServletRegistration.Dynamic registration = container.addServlet(<span class="hljs-string">"dispatcher"</span>, <span class="hljs-keyword">new</span> DispatcherServlet(appContext));
        registration.setLoadOnStartup(<span class="hljs-number">1</span>);
        registration.addMapping(<span class="hljs-string">"/"</span>);
    }
}
</code></pre>
<p><code>WebApplicationInitializer</code>是Spring MVC提供的一个接口，实现此接口的任何Servlet 3容器都可被检测到并自动初始化。 <code>AbstractDispatcherServletInitializer</code>抽象类实现了<code>WebApplicationInitializer</code>接口，通过重写方法来指定servlet映射和<code>DispatcherServlet</code> 配置的地址， 从而更方便的注册<code>DispatcherServlet</code>。</p>
<p>对于使用基于Java的Spring配置的应用程序，建议使用此方法，如以下示例所示:</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyWebAppInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractAnnotationConfigDispatcherServletInitializer</span> </span>{

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Class&lt;?&gt;[] { MyWebConfig<span class="hljs-class">.<span class="hljs-keyword">class</span> }</span>;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">protected</span> String[] getServletMappings() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String[] { <span class="hljs-string">"/"</span> };
    }
}
</code></pre>
<p>如果使用基于XML的Spring配置，则应直接从<code>AbstractDispatcherServletInitializer</code>扩展，如以下示例所示:</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyWebAppInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractDispatcherServletInitializer</span> </span>{

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> WebApplicationContext <span class="hljs-title">createRootApplicationContext</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> WebApplicationContext <span class="hljs-title">createServletApplicationContext</span><span class="hljs-params">()</span> </span>{
        XmlWebApplicationContext cxt = <span class="hljs-keyword">new</span> XmlWebApplicationContext();
        cxt.setConfigLocation(<span class="hljs-string">"/WEB-INF/spring/dispatcher-config.xml"</span>);
        <span class="hljs-keyword">return</span> cxt;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">protected</span> String[] getServletMappings() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String[] { <span class="hljs-string">"/"</span> };
    }
}
</code></pre>
<p><code>AbstractDispatcherServletInitializer</code>还提供了一种便捷的方法来添加<code>Filter</code>实例并将它们自动映射到DispatcherServlet，如以下示例所示：</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyWebAppInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractDispatcherServletInitializer</span> </span>{

    <span class="hljs-comment">// ...</span>

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">protected</span> Filter[] getServletFilters() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Filter[] {
            <span class="hljs-keyword">new</span> HiddenHttpMethodFilter(), <span class="hljs-keyword">new</span> CharacterEncodingFilter() };
    }
}
</code></pre>
<p>每个过滤器都根据其具体类型添加默认名称，并自动映射到<code>DispatcherServlet</code>。</p>
<p><code>AbstractDispatcherServletInitializer</code>的protected方法<code>isAsyncSupported</code>提供了一个单独的地址来启用<code>DispatcherServlet</code> 上的异步支持以及映射到它的所有过滤器。 默认情况下，此标志设置为<code>true</code>。</p>
<p>最后，如果您需要进一步自定义<code>DispatcherServlet</code>本身，则可以覆盖<code>createDispatcherServlet</code>方法。</p>
<p><a id="mvc-servlet-sequence"></a></p>
<h4><a href="#mvc-servlet-sequence"></a>1.1.5. 处理流程</h4>
<p><a href="web-reactive.html#webflux-dispatcher-handler-sequence">Same as in Spring WebFlux</a></p>
<p><code>DispatcherServlet</code>按如下方式处理请求：</p>
<ul>
<li>
<p>首先，搜索应用的上下文对象<code>WebApplicationContext</code>，并把它作为一个属性（attribute)绑定到该请求上。以便让控制器和其他组件能使用它。 属性的键名默认为<code>DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE</code>。</p>
</li>
<li>
<p>将locale resolver绑定到请求上，并允许其他组件解析处理请求时使用的语言环境（渲染视图，准备数据等）。 如果您不需要区域解析，则不需要locale resolver。</p>
</li>
<li>
<p>将theme resolver 绑定到请求，以允许视图等组件确定要使用的themes。 如果您不使用themes，则可以忽略它。</p>
</li>
<li>
<p>如果指定multipart 文件处理器，则会检查请求的文件是不是multiparts的， 如果是，请求将包装在<code>MultipartHttpServletRequest</code>中， 以便其他组件进一步处理。 有关<a href="#mvc-multipart">Multipart Resolver</a>的更多信息，请参见<a href="#mvc-multipart">Multipart Resolver</a>。</p>
</li>
<li>
<p>为该请求查找一个合适的处理器。 如果找到处理程序，则与该处理器关联的整条执行链（前处理器、后处理器、控制器等）都会被执行，以完成相应模型的准备或视图的渲染。 或者，对于带注解的控制器，可以显示响应（在 <code>HandlerAdapter</code>中）而不是返回视图。</p>
</li>
<li>
<p>如果处理器返回模型，则渲染视图。 如果没有返回模型（可能是由于前处理器或后处理器拦截请求，可能是出于安全原因），则不会渲染任何视图，因为该请求可能已经完成。</p>
</li>
</ul>
<p>在 <code>WebApplicationContext</code> 中声明的<code>HandlerExceptionResolver</code>用于解决请求处理过程中引发的异常。这些异常解析程序允许使用自定义的逻辑来解决，有关详细信息，请参阅<a href="#mvc-exceptionhandlers">Exceptions</a> 。</p>
<p>Spring的 <code>DispatcherServlet</code>也允许处理器返回Servlet API规范中定义的最后修改时间戳（<code>last-modification-date</code>）值。确定请求最后修改时间的方式是直截了当的： <code>DispatcherServlet</code>会先查找合适的处理映射来找到请求对应的处理器，然后检测它是否实现了 <code>LastModified</code> 接口。如果是的话，则调用接口的<code>long getLastModified(request)</code>方法，并将返回的值传回给客户端。</p>
<p>您可以自定义通过<code>DispatcherServlet</code>的配置。可以在<code>web.xml</code>文件中，声明元素Servlet的上添加Servlet的初始化参数（<code>init-param</code>元素）。 下表列出了支持的参数：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>contextClass</code></td>
<td>实现<code>ConfigurableWebApplicationContext</code>的类，由此类通过本地配置来初始化 Servlet实例。 默认情况下，使用<code>XmlWebApplicationContext</code>。</td>
</tr>
<tr>
<td><code>contextConfigLocation</code></td>
<td>一个指定了上下文配置文件路径的字符串，并传递给上下文实例（由<code>contextClass</code>指定） 。该字符串可能包含多个字符串（使用逗号作为分隔符）以支持多个上下文。 对于具有两次定义的bean的多个上下文位置，最新位置优先（即最后加载的为准）。</td>
</tr>
<tr>
<td><code>namespace</code></td>
<td><code>WebApplicationContext</code>的命名空间。 默认为<code>[servlet-name]-servlet</code>。</td>
</tr>
<tr>
<td><code>throwExceptionIfNoHandlerFound</code></td>
<td>当没有找到请求的处理程序时是否抛出 <code>NoHandlerFoundException</code>。 然后可以使用 <code>HandlerExceptionResolver</code>捕获异常（例如，使用<code>@ExceptionHandler</code>控制器方法）并像处理其他任何方法一样处理异常。默认情况下，此参数设置为 <code>false</code>，在这种情况下，<code>DispatcherServlet</code>将响应状态设置为404（NOT_FOUND），而不会引发异常。请注意，如果配置了 <a href="#mvc-default-servlet-handler">默认servlet处理</a> ，则始终将未解析的请求转发到默认servlet，并且永远不会引发404。</td>
</tr>
</tbody>
</table>
<p><a id="mvc-handlermapping-interceptor"></a></p>
<h4><a href="#mvc-handlermapping-interceptor"></a>1.1.6. Interception</h4>
<p>Spring的处理器映射机制包含了处理器拦截器，，可以实现 <code>HandlerMapping</code>，所有 <code>HandlerMapping</code>实现都支持处理拦截器，这些拦截器在需要为特定类型的请求应用一些功能时可能很有用非常有用， 例如，检查用户身份等，<code>org.springframework.web.servlet</code>包中的 <code>HandlerInterceptor</code>实现了三种方法，提供足够的灵活性来执行各种预处理和后处理：</p>
<ul>
<li>
<p><code>preHandle(..)</code>: 在执行实际处理程序之前</p>
</li>
<li>
<p><code>postHandle(..)</code>: 在执行实际处理程序之后</p>
</li>
<li>
<p><code>afterCompletion(..)</code>: 完成请求后</p>
</li>
</ul>
<p><code>preHandle(..)</code> 方法返回一个布尔值。 您可以使用此方法来中断或继续执行链的处理。 当此方法返回 <code>true</code>时，处理程序执行链继续。 当它返回false时，<code>DispatcherServlet</code>假定拦截器本身已处理请求（例如，呈现适当的视图）并且不继续执行执行链中的其他拦截器和实际处理程序。</p>
<p>有关如何配置<a href="#mvc-config-interceptors">Interceptors</a> 的示例，请参阅MVC配置一节中的拦截器。 您还可以使用各个 <code>HandlerMapping</code>实现上的setter方法直接注册它们。</p>
<p>请注意，在HandlerAdapter和postHandle之前，响应被写入并提交。 <code>postHandle</code>对于<code>@ResponseBody</code>和ResponseEntity方法不太有用， 这意味着对响应进行任何更改都为时已晚，例如添加额外的header。 对于此类方案，您可以实现 <code>ResponseBodyAdvice</code>并将其声明为<a href="#mvc-ann-controller-advice">Controller Advice</a>bean或直接在<code>RequestMappingHandlerAdapter</code>上进行配置。</p>
<p><a id="mvc-exceptionhandlers"></a></p>
<h4><a href="#mvc-exceptionhandlers"></a>1.1.7. 异常</h4>
<p><a href="web-reactive.html#webflux-dispatcher-exceptions">Same as in Spring WebFlux</a></p>
<p>如果在请求映射期间发生异常或从请求处理程序（例如 <code>@Controller</code>）抛出异常， 则<code>DispatcherServlet</code>委托给 <code>HandlerExceptionResolver</code> bean来处理并解决异常，这通常是错误响应。</p>
<p>下表列出了可用的 <code>HandlerExceptionResolver</code> 实现：:</p>
<p>Table 2. HandlerExceptionResolver 实现 ：</p>
<table>
<thead>
<tr>
<th><code>HandlerExceptionResolver</code></th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>SimpleMappingExceptionResolver</code></td>
<td>异常类名称和错误视图名称之间的映射。 用于在浏览器应用程序中呈现错误页面。</td>
</tr>
<tr>
<td><a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/servlet/mvc/support/DefaultHandlerExceptionResolver.html"><code>DefaultHandlerExceptionResolver</code></a></td>
<td>解决Spring MVC引发的异常并将它们映射到HTTP状态代码。 另请参阅备用<code>ResponseEntityExceptionHandler</code>和<a href="#mvc-ann-rest-exceptions">REST API exceptions</a>异常。</td>
</tr>
<tr>
<td><code>ResponseStatusExceptionResolver</code></td>
<td>使用<code>@ResponseStatus</code>注解解析异常，并根据注解中的值将它们映射到HTTP状态代码。</td>
</tr>
<tr>
<td><code>ExceptionHandlerExceptionResolver</code></td>
<td>通过在<code>@Controller</code>或 <code>@ControllerAdvice</code>类中调用 <code>@ExceptionHandler</code>方法来解决异常。 请参阅<a href="#mvc-ann-exceptionhandler">@ExceptionHandler methods</a>方法。</td>
</tr>
</tbody>
</table>
<p><a id="mvc-excetionhandlers-handling"></a></p>
<h5><a href="#mvc-excetionhandlers-handling"></a>解析链</h5>
<p>您可以通过在Spring配置中声明多个 <code>HandlerExceptionResolver</code> bean并根据需要设置其顺序属性来形成异常解析链。 <code>order</code>属性越高，异常解析器定位的越晚。</p>
<p><code>HandlerExceptionResolver</code>的约定指定它可以返回:</p>
<ul>
<li>
<p>一个指向错误视图的 <code>ModelAndView</code>。</p>
</li>
<li>
<p>如果在解析程序中处理异常，则为空的<code>ModelAndView</code>。</p>
</li>
<li>
<p>如果异常仍未解析，则为 <code>null</code>，以供后续解析器尝试，如果异常保留在最后，则允许冒泡到Servlet容器。.</p>
</li>
</ul>
<p><a href="#mvc-config">MVC Config</a>自动声明内置的解析器，用于默认的Spring MVC异常，<code>@ResponseStatus</code> 带注解的异常，以及对<code>@ExceptionHandler</code>方法的支持。 您可以自定义该列表或替换它。</p>
<p><a id="mvc-ann-customer-servlet-container-error-page"></a></p>
<h5><a href="#mvc-ann-customer-servlet-container-error-page"></a>容器错误页面</h5>
<p>如果任何<code>HandlerExceptionResolver</code>仍未解析异常，并且因此将其传播给servlet容器或者如果响应状态设置为错误状态（即4xx，5xx） ，则Servlet容器可以呈现HTML中的默认错误页面。 要自定义容器的默认错误页面，可以在 <code>web.xml</code>.中声明错误页面映射。 以下示例显示了如何执行此操作：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">error-page</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">location</span>&gt;</span>/error<span class="hljs-tag">&lt;/<span class="hljs-name">location</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">error-page</span>&gt;</span>
</code></pre>
<p>根据前面的示例，当异常冒泡或响应具有错误状态时，Servlet容器会在容器内对配置的URL进行ERROR调度（例如，<code>/error</code>）。 然后由<code>DispatcherServlet</code>处理，可能将其映射到 <code>@Controller</code>，可以实现该控件以返回带有模型的错误视图名称或呈现JSON响应，如以下示例所示：</p>
<pre><code class="language-java"><span class="hljs-meta">@RestController</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ErrorController</span> </span>{

    <span class="hljs-meta">@RequestMapping</span>(path = <span class="hljs-string">"/error"</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title">handle</span><span class="hljs-params">(HttpServletRequest request)</span> </span>{
        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;String, Object&gt;();
        map.put(<span class="hljs-string">"status"</span>, request.getAttribute(<span class="hljs-string">"javax.servlet.error.status_code"</span>));
        map.put(<span class="hljs-string">"reason"</span>, request.getAttribute(<span class="hljs-string">"javax.servlet.error.message"</span>));
        <span class="hljs-keyword">return</span> map;
    }
}
</code></pre>
<p>Servlet API没有提供在Java中创建错误页面映射的方法。 但是，您可以同时使用<code>WebApplicationInitializer</code>和最小的 <code>web.xml</code>。</p>
<p><a id="mvc-viewresolver"></a></p>
<h4><a href="#mvc-viewresolver"></a>1.1.8. 视图解析</h4>
<p><a href="web-reactive.html#webflux-viewresolution">Same as in Spring WebFlux</a></p>
<p>Spring MVC定义了 <code>ViewResolver</code>和 <code>View</code>接口，使您可以在浏览器中呈现模型，而无需将您与特定的视图技术联系起来。 <code>ViewResolver</code>提供视图名称和实际视图之间的映射。 <code>View</code>接口负责准备请求，并将请求的渲染交给某种具体的视图技术实现。</p>
<p>下表提供了有关<code>ViewResolver</code>层次结构的更多详细信息：:</p>
<p>Table 3. ViewResolver 实现</p>
<table>
<thead>
<tr>
<th>ViewResolver</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>AbstractCachingViewResolver</code></td>
<td><code>AbstractCachingViewResolver</code> 的子类缓存它们解析的视图实例。 缓存可提高某些视图技术的性能。 您可以通过将<code>cache</code>属性设置为 <code>false</code>.来关闭缓存。 此外，如果必须在运行时刷新某个视图（例如，修改FreeMarker模板时），则可以使用<code>removeFromCache(String viewName, Locale loc)</code> 方法。</td>
</tr>
<tr>
<td><code>XmlViewResolver</code></td>
<td>实现<code>ViewResolver</code>，它必须和Spring的XML bean工厂有相同的DTD以。 默认配置文件是<code>/WEB-INF/views.xml</code>。</td>
</tr>
<tr>
<td><code>ResourceBundleViewResolver</code></td>
<td><code>ViewResolver</code>的实现，它使用由bundle根路径指定的<code>ResourceBundle</code>中的bean定义作为配置。 对于它应该解析的每个视图，它使用属性<code>[viewname].(class)</code>的值作为视图类， 并使用属性 <code>[viewname].url</code> 的值作为视图URL。 您可以在 <a href="#mvc-view">视图技术</a>一章中找到示例。</td>
</tr>
<tr>
<td><code>UrlBasedViewResolver</code></td>
<td><code>ViewResolver</code>接口的简单实现，它不需要其他任何显式的映射说明，而直接使用URL来解析到逻辑视图名。 如果您的逻辑名称与真正的视图资源的名称匹配，则不需要任何映射。</td>
</tr>
<tr>
<td><code>InternalResourceViewResolver</code></td>
<td><code>UrlBasedViewResolver</code>的便捷子类，支持 <code>InternalResourceView</code>（实际上是Servlet和JSP）和子类，如<code>JstlView</code> 和 <code>TilesView</code>。 您可以使用<code>setViewClass(..)</code>为此解析程序生成的所有视图指定视图类。 有关详细信息，请参阅<a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/reactive/result/view/UrlBasedViewResolver.html"><code>UrlBasedViewResolver</code></a>javadoc。</td>
</tr>
<tr>
<td><code>FreeMarkerViewResolver</code></td>
<td><code>UrlBasedViewResolver</code> 的便捷子类，支持 <code>FreeMarkerView</code>及其自定义子类。</td>
</tr>
<tr>
<td><code>ContentNegotiatingViewResolver</code></td>
<td>实现 <code>ViewResolver</code> 接口，该接口根据请求文件名或Accept头解析视图。 请参阅 <a href="#mvc-multiple-representations">Content Negotiation</a>。</td>
</tr>
</tbody>
</table>
<p><a id="mvc-viewresolver-handling"></a></p>
<h5><a href="#mvc-viewresolver-handling"></a>处理</h5>
<p><a href="web-reactive.html#webflux-viewresolution-handling">Same as in Spring WebFlux</a></p>
<p>您可以在视图解析器链中声明多个视图解析器，并在必要时通过设置 <code>order</code>属性来指定排序。 请记住，order属性越高，视图解析器在链中的位置越晚。 .</p>
<p><code>ViewResolver</code> 可以返回null以指示无法找到该视图。 但是，对于JSP和<code>InternalResourceViewResolver</code>, 确定JSP是否存在的唯一方法是通过<code>RequestDispatcher</code>执行调度。 因此，您必须始终将<code>InternalResourceViewResolver</code>配置为视图解析器的整体顺序中的最后一个。</p>
<p>配置视图解析就像将<code>ViewResolver</code> bean添加到Spring配置一样简单。<a href="#mvc-config">MVC Config</a>为<a href="#mvc-config-view-resolvers">View Resolvers</a>提供专用配置API，并添加无逻辑视图控制器（<a href="#mvc-config-view-controller">View Controllers</a> ），这些控制器对于没有控制器逻辑的HTML模板渲染非常有用。</p>
<p><a id="mvc-redirecting-redirect-prefix"></a></p>
<h5><a href="#mvc-redirecting-redirect-prefix"></a>重定向</h5>
<p><a href="web-reactive.html#webflux-redirecting-redirect-prefix">Same as in Spring WebFlux</a></p>
<p>您可以在视图中使用<code>redirect:</code>前缀来执行重定向。<code>UrlBasedViewResolver</code>（及其子类）将此识别为需要重定向的指令。 视图名称的其余部分是重定向URL。</p>
<p>控制器本身可以根据逻辑视图名称进行操作。 逻辑视图名称（例如<code>redirect:/myapp/some/resource</code>）相对于当前Servlet上下文重定向，而名称如<code>redirect:http://myhost.com/some/arbitrary/path</code>重定向到绝对URL。</p>
<p>请注意，如果使用<code>@ResponseStatus</code>注解控制器方法，则注解值优先于 <code>RedirectView</code>设置的响应状态。</p>
<p><a id="mvc-redirecting-forward-prefix"></a></p>
<h5><a href="#mvc-redirecting-forward-prefix"></a>转发</h5>
<p>你也可以在视图名称中使用<code>forward:</code>前缀，来作为 <code>UrlBasedViewResolver</code>和其子类最终解析的视图名称。 这将创建一个 <code>InternalResourceView</code>，它执行<code>RequestDispatcher.forward()</code>。 因此，此前缀对于 <code>InternalResourceViewResolver</code>和<code>InternalResourceView</code>（对于JSP）没有用，但如果您使用其他视图技术时仍希望强制Servlet/JSP引擎处理资源的转发，则它可能会有所帮助。 请注意，您也可以链接多个视图解析器。</p>
<p><a id="mvc-multiple-representations"></a></p>
<h5><a href="#mvc-multiple-representations"></a>Content Negotiation</h5>
<p><a href="web-reactive.html#webflux-multiple-representations">Same as in Spring WebFlux</a></p>
<p><a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/servlet/view/ContentNegotiatingViewResolver.html"><code>ContentNegotiatingViewResolver</code></a>本身不解析视图，而是委托给其他视图解析器，并选择类似于客户端请求的表示的视图。 可以从<code>Accept</code>头或查询参数（例如， <code>&quot;/path?format=pdf&quot;</code>）确定表示。</p>
<p><code>ContentNegotiatingViewResolver</code>通过将请求的媒体类型与其每个ViewResolvers关联的View支持的媒体类型（也称为<code>Content-Type</code>）进行比较，选择适当的 <code>View</code>来处理请求。列表中具有兼容Content-Type的第一个<code>View</code>将表示返回给客户端。 如果 <code>ViewResolver</code>链无法提供兼容视图，则会查询通过<code>DefaultViews</code> 属性指定的视图列表。 后一个选项适用于单个视图，它可以呈现当前资源的适当表示，而不管逻辑视图名称如何。 <code>Accept</code>头可以包含通配符（例如<code>text/*</code>），在这种情况下，<code>Content-Type</code>为<code>text/xml</code>的View是兼容匹配。</p>
<p>有关配置详细信息，请参阅 <a href="#mvc-config">MVC Config</a> 下的<a href="#mvc-config-view-resolvers">View Resolvers</a> 。</p>
<p><a id="mvc-localeresolver"></a></p>
<h4><a href="#mvc-localeresolver"></a>1.1.9. Locale</h4>
<p>正如Spring Web MVC框架所做的那样，Spring架构的大多数部分都支持国际化。 <code>DispatcherServlet</code>允许您使用客户端的语言环境自动解析消息。 这是通过<code>LocaleResolver</code>对象完成的。</p>
<p>当请求进入时，<code>DispatcherServlet</code> 会查找当前语言环境解析器，如果找到，则会尝试使用它来设置语言环境。 您可以通过使用<code>RequestContext.getLocale()</code>方法，来获取由区域解析器解析到的结果。</p>
<p>除了自动解析语言环境之外，您还可以在处理程序时添加拦截器（有关拦截器的更多信息，请参阅<a href="#mvc-handlermapping-interceptor">Interception</a> ），以便于在特定情况下更改语言环境。例如（通过请求中的参数来改变语言环境）</p>
<p>区域解析器和拦截器在 <code>org.springframework.web.servlet.i18n</code>包中定义，并以正常方式在应用程序上下文中进行配置。 Spring中包含以下选择的语言环境解析器。</p>
<ul>
<li>
<p><a href="#mvc-timezone">Time Zone</a></p>
</li>
<li>
<p><a href="#mvc-localeresolver-acceptheader">Header Resolver</a></p>
</li>
<li>
<p><a href="#mvc-localeresolver-cookie">Cookie Resolver</a></p>
</li>
<li>
<p><a href="#mvc-localeresolver-session">Session Resolver</a></p>
</li>
<li>
<p><a href="#mvc-localeresolver-interceptor">Locale Interceptor</a></p>
</li>
</ul>
<p><a id="mvc-timezone"></a></p>
<h5><a href="#mvc-timezone"></a>Time Zone</h5>
<p>除了获取客户端的区域设置外，了解其时区通常也很有用。 <code>LocaleContextResolver</code> 接口提供了<code>LocaleResolver</code>的扩展，它允许解析器提供更丰富的 <code>LocaleContext</code>，其中可能包含时区信息。</p>
<p>当此解析器可用时，可以使用<code>RequestContext.getTimeZone()</code>方法获取用户的<code>TimeZone</code>。 时区信息由Spring的<code>ConversionService</code>注册的任何Date/Time <code>Converter</code>和<code>Formatter</code> 对象自动使用。</p>
<p><a id="mvc-localeresolver-acceptheader"></a></p>
<h5><a href="#mvc-localeresolver-acceptheader"></a>Header Resolver</h5>
<p>此区域解析器检查客户端（例如，Web浏览器）发送的请求头中的<code>accept-language</code>。 通常，此字段包含客户端操作系统的区域设置。 请注意，此解析器不支持时区信息。</p>
<p><a id="mvc-localeresolver-cookie"></a></p>
<h5><a href="#mvc-localeresolver-cookie"></a>Cookie Resolver</h5>
<p>此区域解析器检查客户端上可能存在的 <code>Cookie</code>，以查看是否指定了<code>Locale</code>或<code>TimeZone</code>。 如果是，则使用指定的详细信息。 通过使用此区域解析器的属性，您可以指定cookie的名称以及失效时间。 以下示例定义<code>CookieLocaleResolver</code>：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"localeResolver"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.web.servlet.i18n.CookieLocaleResolver"</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"cookieName"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"clientlanguage"</span>/&gt;</span>

    <span class="hljs-comment">&lt;!-- in seconds. If set to -1, the cookie is not persisted (deleted when browser shuts down) --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"cookieMaxAge"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"100000"</span>/&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>
</code></pre>
<p>下表描述了 <code>CookieLocaleResolver</code>的属性：</p>
<p>Table 4. CookieLocaleResolver properties:</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>cookieName</code></td>
<td>classname + LOCALE</td>
<td>cookie的名字</td>
</tr>
<tr>
<td><code>cookieMaxAge</code></td>
<td>Servlet container default</td>
<td>Cookie在客户端上持续存在的最长时间。 如果指定<code>-1</code>，则不会保留cookie。 它仅在客户端关闭浏览器之前可用。</td>
</tr>
<tr>
<td><code>cookiePath</code></td>
<td>/</td>
<td>限制cookie对您网站某个部分的可见性。 当指定了 <code>cookiePath</code>时，cookie仅对该路径及其下方的路径可见。</td>
</tr>
</tbody>
</table>
<p><a id="mvc-localeresolver-session"></a></p>
<h5><a href="#mvc-localeresolver-session"></a>Session Resolver</h5>
<p>您可以使用 <code>SessionLocaleResolver</code>从与用户请求关联的Session中获取<code>Locale</code> 和<code>TimeZone</code>。 与<code>CookieLocaleResolver</code>相比，此策略将本地选择的区域设置存储在Servlet容器的 <code>HttpSession</code>中。 因此，这些设置对于每个会话都是临时的，这些设置在会话结束时会丢失。</p>
<p>请注意，与外部会话管理机制没有直接关系，例如Spring Session项目。 此<code>SessionLocaleResolver</code> 根据当前的<code>HttpServletRequest</code>评估和修改相应的<code>HttpSession</code>属性。</p>
<p><a id="mvc-localeresolver-interceptor"></a></p>
<h5><a href="#mvc-localeresolver-interceptor"></a>Locale Interceptor</h5>
<p>您可以通过将<code>LocaleChangeInterceptor</code>添加到其中一个 <code>HandlerMapping</code>定义来启用语言环境的更改。 它会检测请求中的参数并相应地更改语言环境，在程序的应用程序上下文中调用 <code>LocaleResolver</code> 上的<code>setLocale</code>方法。 下一个示例显示，当调用包含名为 <code>siteLanguage</code>的参数的所有<code>*.view</code>资源时更改了区域设置。 例如，对URL的请求 <code>[http://www.sf.net/home.view?siteLanguage=nl](https://www.sf.net/home.view?siteLanguage=nl)</code>将网站语言更改为荷兰语。 以下示例显示如何拦截区域设置:</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"localeChangeInterceptor"</span>
        <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.web.servlet.i18n.LocaleChangeInterceptor"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"paramName"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"siteLanguage"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"localeResolver"</span>
        <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.web.servlet.i18n.CookieLocaleResolver"</span>/&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"urlMapping"</span>
        <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"interceptors"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">"localeChangeInterceptor"</span>/&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"mappings"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>/**/*.view=someController<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>
</code></pre>
<p><a id="mvc-themeresolver"></a></p>
<h4><a href="#mvc-themeresolver"></a>1.1.10. 主题</h4>
<p>您可以使用Spring Web MVC框架自带的主题来设置应用程序的整体外观，从而增强用户体验。 主题是静态资源的集合，通常是样式表和图像，它们会影响应用程序的视觉样式。</p>
<p><a id="mvc-themeresolver-defining"></a></p>
<h5><a href="#mvc-themeresolver-defining"></a>定义一个主题</h5>
<p>要在Web应用程序中使用主题，必须设置 <code>org.springframework.ui.context.ThemeSource</code>接口的实现。 <code>WebApplicationContext</code>接口扩展了 <code>ThemeSource</code>， 但将其职责委托给专用实现。 默认情况下，委托是 <code>org.springframework.ui.context.support.ResourceBundleThemeSource</code>的实现。它从类路径的根目录加载属性文件。 要使用自定义 <code>ThemeSource</code>实现或配置 <code>ResourceBundleThemeSource</code>的名称前缀，可以在应用程序上下文中使用保留名称<code>themeSource</code>注册bean。 Web应用程序上下文自动检测具有该名称的bean并使用它。</p>
<p>使用 <code>ResourceBundleThemeSource</code>时，主题在简单属性文件中定义。 属性文件列出构成主题的资源，如以下示例所示：</p>
<p>styleSheet=/themes/cool/style.css
background=/themes/cool/img/coolBg.jpg</p>
<p>属性的键是从视图代码引用主题元素的名称。 对于JSP，通常使用<code>spring:theme</code> 自定义标签执行此操作，该标记与<code>spring:message</code>标签非常相似。 以下JSP片段使用上一示例中定义的主题来自定义外观：</p>
<pre><code class="language-jsp">&lt;%@ taglib prefix="spring" uri="http://www.springframework.org/tags"%&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;link rel="stylesheet" href="&lt;spring:theme code='styleSheet'/&gt;" type="text/css"/&gt;
    &lt;/head&gt;
    &lt;body style="background=&lt;spring:theme code='background'/&gt;"&gt;
        ...
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>默认情况下，<code>ResourceBundleThemeSource</code>使用空的名称前缀。 因此，从类路径的根加载属性文件。 因此，您可以将<code>cool.properties</code>主题定义放在类路径根目录的目录中（例如，在 <code>/WEB-INF/classes</code>中）。 <code>ResourceBundleThemeSource</code>使用标准的Java资源包加载机制，从而使主题也具有国际化。 例如，我们可以有一个<code>/WEB-INF/classes/cool_nl.properties</code>，它引用一个带有荷兰文本的特殊背景图像。</p>
<p><a id="mvc-themeresolver-resolving"></a></p>
<h5><a href="#mvc-themeresolver-resolving"></a>解析主题</h5>
<p>定义主题后，<a href="#mvc-themeresolver-defining">如上一节所述</a>，您可以决定使用哪个主题。 <code>DispatcherServlet</code>查找名为<code>themeResolver</code>的bean，以找出要使用的<code>ThemeResolver</code>实现。 主题解析器的工作方式与<code>LocaleResolver</code>的工作方式大致相同。 它检测用于特定请求的主题，还可以更改请求的主题。 下表描述了Spring提供的主题解析器：</p>
<p>Table 5. ThemeResolver implementations :</p>
<table>
<thead>
<tr>
<th>Class</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>FixedThemeResolver</code></td>
<td>选择使用<code>defaultThemeName</code></td>
</tr>
<tr>
<td><code>SessionThemeResolver</code></td>
<td>主题在用户的HTTP会话中维护。 它只需要为每个会话设置一次，但不会在会话之间保留。</td>
</tr>
<tr>
<td><code>CookieThemeResolver</code></td>
<td>所选主题存储在客户端的cookie中。</td>
</tr>
</tbody>
</table>
<p>Spring还提供了一个<code>ThemeChangeInterceptor</code>，它允许通过简单的请求参数对每个请求进行主题更改。</p>
<p><a id="mvc-multipart"></a></p>
<h4><a href="#mvc-multipart"></a>1.1.11. Multipart 解析器</h4>
<p><a href="web-reactive.html#webflux-multipart">Same as in Spring WebFlux</a></p>
<p><code>org.springframework.web.multipart</code> 包中的 <code>MultipartResolver</code>是一种用于解析包括文件上传在内的多部分请求的策略。 他包含了一个<a href="https://jakarta.apache.org/commons/fileupload">Commons FileUpload</a> 的实现，另一个基于Servlet 3.0多部分请求解析。</p>
<p>要启用多部分处理，Spring的配置文件中，在 <code>DispatcherServlet</code> 配置名称为<code>multipartResolver</code>的<code>MultipartResolver</code> bean。 <code>DispatcherServlet</code>会自动检测并将其应用于请求中。 当收到内容类型为<code>multipart/form-data</code>的POST请求时，解析器会解析内容并将当前的<code>HttpServletRequest</code>包装为 <code>MultipartHttpServletRequest</code>，以提供对已解析部分的访问，并将其作为请求参数公开。</p>
<p><a id="mvc-multipart-resolver-commons"></a></p>
<h5><a href="#mvc-multipart-resolver-commons"></a>Apache Commons <code>FileUpload</code></h5>
<p>要使用Apache Commons <code>FileUpload</code>，您可以配置名为 <code>multipartResolver</code>的<code>CommonsMultipartResolver</code>r类型的bean。 您还需要添加<code>commons-fileupload</code>依赖。</p>
<p><a id="mvc-multipart-resolver-standard"></a></p>
<h5><a href="#mvc-multipart-resolver-standard"></a>Servlet 3.0</h5>
<p>需要通过Servlet容器配置启用Servlet 3.0多部分解析:</p>
<ul>
<li>
<p>在Java中，在注册Servlet时设置 <code>MultipartConfigElement</code>。</p>
</li>
<li>
<p>在<code>web.xml</code>中，将“<code>&quot;&lt;multipart-config&gt;&quot;</code>”部分添加到servlet声明中。</p>
</li>
</ul>
<p>以下示例显示如何在注册Servlet时设置 <code>MultipartConfigElement</code>:</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractAnnotationConfigDispatcherServletInitializer</span> </span>{

    <span class="hljs-comment">// ...</span>

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">customizeRegistration</span><span class="hljs-params">(ServletRegistration.Dynamic registration)</span> </span>{

        <span class="hljs-comment">// Optionally also set maxFileSize, maxRequestSize, fileSizeThreshold</span>
        registration.setMultipartConfig(<span class="hljs-keyword">new</span> MultipartConfigElement(<span class="hljs-string">"/tmp"</span>));
    }

}
</code></pre>
<p>一旦您配置好Servlet 3.0，您就可以添加名为<code>multipartResolver</code>的<code>StandardServletMultipartResolver</code>类型的bean。</p>
<p><a id="mvc-logging"></a></p>
<h4><a href="#mvc-logging"></a>1.1.12. 日志</h4>
<p><a href="web-reactive.html#webflux-logging">Same as in Spring WebFlux</a></p>
<p>Spring MVC中的DEBUG级别日志记录旨在实现紧凑，简约和人性化。 它侧重于那些一次又一次使用的高价值信息，其他的只有在调试特定问题时才有用。</p>
<p>TRACE级日志记录通常遵循与DEBUG相同的原则（例如，不应该是fire hose），但可以用于调试任何问题。 此外，一些日志消息可能在TRACE与DEBUG中显示不同的详细程度。</p>
<p>良好的日志记录来自使用日志的经验。 如果您发现任何不符合既定目标的事件，请告知我们。</p>
<p><a id="mvc-logging-sensitive-data"></a></p>
<h5><a href="#mvc-logging-sensitive-data"></a>敏感数据</h5>
<p><a href="web-reactive.html#webflux-logging-sensitive-data">Same as in Spring WebFlux</a></p>
<p>DEBUG和TRACE日志记录可能会记录敏感信息。 这就是默认情况下屏蔽请求参数和请求头的原因，并且必须通过 <code>DispatcherServlet</code>上的 <code>enableLoggingRequestDetails</code>属性显式启用它们的完整日志记录。</p>
<p>以下示例说明如何使用Java配置执行此操作：</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInitializer</span>
        <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractAnnotationConfigDispatcherServletInitializer</span> </span>{

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() {
        <span class="hljs-keyword">return</span> ... ;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() {
        <span class="hljs-keyword">return</span> ... ;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">protected</span> String[] getServletMappings() {
        <span class="hljs-keyword">return</span> ... ;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">customizeRegistration</span><span class="hljs-params">(Dynamic registration)</span> </span>{
        registration.setInitParameter(<span class="hljs-string">"enableLoggingRequestDetails"</span>, <span class="hljs-string">"true"</span>);
    }

}
</code></pre>
<p><a id="filters"></a></p>
<h3><a href="#filters"></a>1.2. 过滤器</h3>
<p><a href="web-reactive.html#webflux-filters">Same as in Spring WebFlux</a></p>
<p><code>spring-web</code>模块提供了一些有用的过滤器:</p>
<ul>
<li>
<p><a href="#filters-http-put">Form Data（表单数据）</a></p>
</li>
<li>
<p><a href="#filters-forwarded-headers">Forwarded Headers（转发请求头）</a></p>
</li>
<li>
<p><a href="#filters-shallow-etag">Shallow ETag（）</a></p>
</li>
<li>
<p><a href="#filters-cors">CORS</a></p>
</li>
</ul>
<p><a id="filters-http-put"></a></p>
<h4><a href="#filters-http-put"></a>1.2.1. 表单数据</h4>
<p>浏览器只能通过HTTP GET或HTTP POST提交表单数据，但非浏览器客户端也可以使用HTTP PUT，PATCH和DELETE提交表单数据。 Servlet API要求<code>ServletRequest.getParameter*()</code>方法仅支持HTTP POST的表单字段访问。.</p>
<p><code>spring-web</code>模块提供 <code>FormContentFilter</code>过滤器来拦截HTTP PUT，PATCH和DELETE请求，请求类型为 <code>application/x-www-form-urlencoded</code>， <code>FormContentFilter</code>从请求中读取表单数据， 并包装 <code>ServletRequest</code>，然后可以通过 <code>ServletRequest.getParameter*()</code>系列方法提供表单数据。</p>
<p><a id="filters-forwarded-headers"></a></p>
<h4><a href="#filters-forwarded-headers"></a>1.2.2. Forwarded Headers（转发请求头）</h4>
<p><a href="web-reactive.html#webflux-forwarded-headers">Same as in Spring WebFlux</a></p>
<p>当通过代理主机或者端口或者其他方案请求时（例如，负载均衡），这是，从客户端角度看，创建正确的主机，端口或者其他方案成为一项挑战，</p>
<p><a href="https://tools.ietf.org/html/rfc7239">RFC 7239</a> RFC 7239定义了代理可以用来提供有关原始请求信息的转发HTTP头。 还有其他非标准头文件，包括<code>X-Forwarded-Host</code>, <code>X-Forwarded-Port</code>, <code>X-Forwarded-Proto</code>, <code>X-Forwarded-Ssl</code>, 和 <code>X-Forwarded-Prefix</code>。</p>
<p><code>ForwardedHeaderFilter</code>是一个Servlet过滤器，它根据 <code>Forwarded</code> 头部信息修改请求的主机，端口和方案，然后删除请求头。</p>
<p>当转发请求头时需要注意的安全事项，因为应用程序无法知道请求头是代理按我们想的那样添加还是由客户端恶意添加，这就是为什么应该将信任边界的代理配置为删除来自外部的不受信任的转发请求头。 您还可以使用<code>removeOnly=true</code>配置<code>ForwardedHeaderFilter</code>，在这种情况下，它会删除但不使用标头。</p>
<p><a id="filters-shallow-etag"></a></p>
<h4><a href="#filters-shallow-etag"></a>1.2.3. Shallow ETag</h4>
<p><code>ShallowEtagHeaderFilter</code>过滤器通过缓存写入响应的内容并从中计算MD5哈希来创建 “shallow”ETag。 客户端下次发送时， 它会执行相同操作，但它也会将计算值与<code>If-None-Match</code>请求头进行比较，如果两者相等，则返回304（NOT_MODIFIED）。</p>
<p>此策略可以节省网络带宽，但不能节省CPU，因为必须为每个请求计算完整响应。 前面描述的控制器级别的其他策略可以避免计算。 请参阅 <a href="#mvc-caching">HTTP Caching</a>。</p>
<p>此过滤器具有<code>writeWeakETag</code>参数，该参数将过滤器配置为写入弱ETag，类似于以下内容：<code>W/&quot;02a2d595e6ed9a0b24f027f2b63b134d6&quot;</code>（如<a href="https://tools.ietf.org/html/rfc7232#section-2.3">RFC 7232 Section 2.3</a>）。</p>
<p><a id="filters-cors"></a></p>
<h4><a href="#filters-cors"></a>1.2.4. CORS</h4>
<p><a href="web-reactive.html#webflux-filters-cors">Same as in Spring WebFlux</a></p>
<p>Spring MVC通过控制器上的注解为CORS配置提供细粒度的支持。 但是，当与Spring Security一起使用时，我们建议依赖于必须在Spring Security的过滤器链之前配置的内置<code>CorsFilter</code>。</p>
<p>有关更多详细信息，请参阅 <a href="#mvc-cors">CORS</a>和<a href="#mvc-cors-filter">CORS Filter</a> 过滤器部分。</p>
<p><a id="mvc-controller"></a></p>
<h3><a href="#mvc-controller"></a>1.3. 注解控制器</h3>
<p><a href="web-reactive.html#webflux-controller">Same as in Spring WebFlux</a></p>
<p>Spring MVC提供了基于注解的编程模型，其中<code>@Controller</code> 和 <code>@RestController</code> 组件使用注解来表示请求映射、请求输入、异常处理等。被注解的控制器拥有灵活的方法签名，并且无需扩展基类或实现特定的接口。以下示例显示了由注解定义的控制器：</p>
<pre><code class="language-java"><span class="hljs-meta">@Controller</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>{

    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">handle</span><span class="hljs-params">(Model model)</span> </span>{
        model.addAttribute(<span class="hljs-string">"message"</span>, <span class="hljs-string">"Hello World!"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-string">"index"</span>;
    }
}
</code></pre>
<p>在前面的示例中，该方法接受<code>Model</code>并将视图名称作为String返回，但是存在许多其他选项，本章稍后将对其进行说明。</p>
<p>有关<a href="https://spring.io/guides">spring.io</a>的指南和教程，请使用本节中介绍的基于注解的编程模型。</p>
<p><a id="mvc-ann-controller"></a></p>
<h4><a href="#mvc-ann-controller"></a>1.3.1. 声明</h4>
<p><a href="web-reactive.html#webflux-ann-controller">Same as in Spring WebFlux</a></p>
<p>您可以在Servlet的<code>WebApplicationContext</code>中使用标准的Spring bean定义来定义控制器bean。<code>@Controller</code>模板允许自动检测， 与Spring支持检测类路径中的<code>@Component</code>类一样，并会自动注册bean定义。它还充当注解类的模板，表示它充当的是Web组件的角色。</p>
<p>要启用<code>@Controller</code> bean的自动检测，您可以将组件扫描添加到Java配置中，如以下示例所示:</p>
<pre><code>@Configuration
@ComponentScan(&quot;org.example.web&quot;)
public class WebConfig {

    // ...
}
</code></pre>
<p>以下示例显示了与前面示例等效的XML配置:</p>
<pre><code class="language-java">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:p="http://www.springframework.org/schema/p"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd"&gt;

    &lt;context:component-scan base-package="org.example.web"/&gt;

    &lt;!-- ... --&gt;

&lt;/beans&gt;
</code></pre>
<p><code>@RestController</code>是一个<a href="core.html#beans-meta-annotations">组合注解</a> ，它本身由<code>@Controller</code> 和 <code>@ResponseBody</code>元注解组成。 其每个方法都继承类型级别（type-level）的 <code>@ResponseBody</code>注解，因此，直接写入响应主体与视图渲染和使用HTML模板。</p>
<p><a id="mvc-ann-requestmapping-proxying"></a></p>
<h5><a href="#mvc-ann-requestmapping-proxying"></a>AOP 代理</h5>
<p>在某些情况下，您需要在运行时使用AOP代理装饰控制器。 例如，如果您想在控制器上直接使用<code>@Transactional</code>注解。 在这种情况下，对于控制器而言，我们建议使用基于类的代理。 这通常也是控制器的默认选择。 但是，如果控制器没有实现Spring Context回调的接口 （例如<code>InitializingBean</code>, <code>*Aware</code>等）， 则可能需要显式配置基于类的代理。 例如，使用 <code>&lt;tx:annotation-driven/&gt;</code>，您可以更改为<code>&lt;tx:annotation-driven proxy-target-class=&quot;true&quot;/&gt;</code>。</p>
<p><a id="mvc-ann-requestmapping"></a></p>
<h4><a href="#mvc-ann-requestmapping"></a>1.3.2. Request Mapping</h4>
<p><a href="web-reactive.html#webflux-ann-requestmapping">Same as in Spring WebFlux</a></p>
<p><code>@RequestMapping</code>注解用于将请求映射到控制器方法。它具有各种属性，可以通过URL、HTTP方法、请求参数、请求头参数（headers）和媒体类型进行匹配。 可以在类级别使用它来表示共享映射，或在方法级别上用于缩小到特定的端点映射范围。</p>
<p>还有<code>@RequestMapping</code>的HTTP方法特定的缩写变量:</p>
<ul>
<li>
<p><code>@GetMapping</code></p>
</li>
<li>
<p><code>@PostMapping</code></p>
</li>
<li>
<p><code>@PutMapping</code></p>
</li>
<li>
<p><code>@DeleteMapping</code></p>
</li>
<li>
<p><code>@PatchMapping</code></p>
</li>
</ul>
<p>这些简洁的注解是<a href="#mvc-ann-requestmapping-composed">自定义注解</a>，因为，大多数的控制器方法应该映射到HTTP方法而不是使用<code>@RequestMapping</code>。默认情况下， <code>@RequestMapping</code>和所有HTTP方法匹配。在类上定义的仍然需要<code>@RequestMapping</code> 来表示共享映射。</p>
<p>以下示例具有类型和方法级别映射:</p>
<pre><code class="language-java"><span class="hljs-meta">@RestController</span>
<span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/persons"</span>)
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonController</span> </span>{

    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/{id}"</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> Person <span class="hljs-title">getPerson</span><span class="hljs-params">(@PathVariable Long id)</span> </span>{
        <span class="hljs-comment">// ...</span>
    }

    <span class="hljs-meta">@PostMapping</span>
    <span class="hljs-meta">@ResponseStatus</span>(HttpStatus.CREATED)
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(@RequestBody Person person)</span> </span>{
        <span class="hljs-comment">// ...</span>
    }
}
</code></pre>
<p><a id="mvc-ann-requestmapping-uri-templates"></a></p>
<h5><a href="#mvc-ann-requestmapping-uri-templates"></a>URI 模式匹配</h5>
<p><a href="web-reactive.html#webflux-ann-requestmapping-uri-templates">Same as in Spring WebFlux</a></p>
<p>你可以使用glob模式和通配符来映射请求:</p>
<ul>
<li>
<p><code>?</code> 匹配一个字符</p>
</li>
<li>
<p><code>*</code> 匹配路径段一个或多个字符</p>
</li>
<li>
<p><code>**</code> 匹配0个或多个路径段</p>
</li>
</ul>
<p>您还可以使用 <code>@PathVariable</code>声明URI变量并访问它们的值，如以下示例所示:</p>
<pre><code>@GetMapping(&quot;/owners/{ownerId}/pets/{petId}&quot;)
public Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) {
    // ...
}
</code></pre>
<p>您可以在类和方法级别声明URI变量，如以下示例所示：</p>
<pre><code class="language-java"><span class="hljs-meta">@Controller</span>
<span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/owners/{ownerId}"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OwnerController</span> </span>{

    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/pets/{petId}"</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> Pet <span class="hljs-title">findPet</span><span class="hljs-params">(@PathVariable Long ownerId, @PathVariable Long petId)</span> </span>{
        <span class="hljs-comment">// ...</span>
    }
}
</code></pre>
<p>URI变量会自动转换为适当的类型，或者引发 <code>TypeMismatchException</code>。 默认情况下支持简单类型（<code>int</code>, <code>long</code>, <code>Date</code>等），您也可以注册对任何其他数据类型的支持。 请参见<a href="#mvc-ann-typeconversion">Type Conversion</a> and <a href="#mvc-ann-initbinder"><code>DataBinder</code></a>。</p>
<p>你可以显示命名URI 变量(例如, <code>@PathVariable(&quot;customId&quot;)</code>),但是如果名称是相同的，并且代码是使用调试信息编译的，或者在Java 8中使用<code>-parameters</code> 编译器标记。 则可以保留该详细信息。</p>
<p>语法<code>{varName:regex}</code>声明一个具有正则表达式的URI变量，其语法为<code>{varName:regex}</code>。例如，给定URL<code>&quot;/spring-web-3.0.5 .jar&quot;</code>，以下方法提取名称，版本和文件扩展名:</p>
<pre><code>@GetMapping(&quot;/{name:[a-z-]+}-{version:\\d\\.\\d\\.\\d}{ext:\\.[a-z]+}&quot;)
public void handle(@PathVariable String version, @PathVariable String ext) {
    // ...
}
</code></pre>
<p>URI路径模式还可以嵌入<code>${…​}</code>，在启动时通过<code>PropertyPlaceHolderConfigurer</code>解析本地、系统、环境和其他属性源时解析的占位符。例如，这种模式可以使用基于某些外部配置对基URL进行参数化</p>
<p>Spring MVC使用 <code>PathMatcher</code>联系和 <code>AntPathMatcher</code>实现位于<code>spring-core</code> URI路径匹配。</p>
<p><a id="mvc-ann-requestmapping-pattern-comparison"></a></p>
<h5><a href="#mvc-ann-requestmapping-pattern-comparison"></a>模式比较</h5>
<p><a href="web-reactive.html#webflux-ann-requestmapping-pattern-comparison">Same as in Spring WebFlux</a></p>
<p>当多个模式与URL匹配时，必须对它们进行比较以找到最佳匹配。 这是通过使用 <code>AntPathMatcher.getPatternComparator(String path)</code>来完成的，它会查找更具体的模式。</p>
<p>如果URI变量的数量较少且单个通配符计为1且双通配符计为2，那么模式就不那么具体了。如果模式得到的分数相等，那么会选择较长的模式匹配。如果分数和长度都相同，则会选择拥有比通配符更多的URI变量的模式。</p>
<p>默认映射模式（<code>/**</code>）从评分中排除，并始终排在最后。 此外，前缀模式（例如<code>/public/**</code>）被认为比没有双通配符的其他模式更不具体。</p>
<p>有关详细信息，请参阅<a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/util/AntPathMatcher.html"><code>AntPathMatcher</code></a> 中的 <a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/util/AntPathMatcher.AntPatternComparator.html"><code>AntPatternComparator</code></a>。 您可以自定义<a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/util/PathMatcher.html"><code>PathMatcher</code></a> 的实现. 请参阅 配置中的<a href="#mvc-config-path-matching">Path Matching</a></p>
<p><a id="mvc-ann-requestmapping-suffix-pattern-match"></a></p>
<h5><a href="#mvc-ann-requestmapping-suffix-pattern-match"></a>后缀匹配</h5>
<p>默认情况下,默认情况下，Spring MVC执行<code>.*</code> 后缀模式匹配，以便映射到 <code>/person</code>的控制器也隐式映射到 <code>/person.*</code>。这里使用文件扩展名来解释用于响应的请求内容类型（即，而不是 <code>Accept</code>请求头） - 例如，<code>/person.pdf</code>，<code>/person.xml</code>等。</p>
<p>当浏览器用于发送难以持续交互的<code>Accept</code>头时，必须以这种方式使用文件扩展名。目前，这不再是必需的，判断 <code>Accept</code>头应该是首选。</p>
<p>随着时间的推移，文件扩展名的使用已经证明有多种方式存在问题。 当使用URI变量，路径参数和URI编码进行覆盖时，它可能会导致歧义。 有关基于URL的授权和安全性的推理（有关更多详细信息，请参阅下一节）也变得更加困难。</p>
<p>要完全禁用文件扩展名，必须同时设置以下两项:</p>
<ul>
<li>
<p><code>useSuffixPatternMatching(false)</code>, see <a href="#mvc-config-path-matching">PathMatchConfigurer</a></p>
</li>
<li>
<p><code>favorPathExtension(false)</code>, see <a href="#mvc-config-content-negotiation">ContentNegotiationConfigurer</a></p>
</li>
</ul>
<p>基于URL的内容协商仍然有用（例如，在浏览器中键入URL时）。 为此，我们建议使用基于查询参数的策略来避免文件扩展名带来的大多数问题。 或者，如果必须使用文件扩展名，请考虑通过<a href="#mvc-config-content-negotiation">ContentNegotiationConfigurer</a>的<code>mediaTypes</code>属性将它们限制为显式注册的扩展名列表。</p>
<p><a id="mvc-ann-requestmapping-rfd"></a></p>
<h5><a href="#mvc-ann-requestmapping-rfd"></a>后缀匹配和RFD</h5>
<p>反射文件下载（Reflected file download）攻击与XSS类似，因为它依赖请求输入，例如查询参数、URI变量，并且在响应中被反射。但是，RFD攻击不是将JavaScript插入HTML，而是依赖浏览器切换来执行下载，进而在之后的双击时将响应作为可执行脚本处理。</p>
<p>在Spring MVC中，<code>@ResponseBody</code>和 <code>ResponseEntity</code>方法存在风险，因为它们可以呈现不同的内容类型，客户端可以通过URL路径扩展来请求。 禁用后缀模式匹配并使用路径扩展进行内容协商可降低风险，但不足以防止RFD攻击。</p>
<p>为了防止RFD攻击，在呈现响应主体之前，需要在Spring MVC添加 <code>Content-Disposition:inline;filename=f.txt</code>头用于提供固定和安全的下载文件。只有在URL路径包含的文件扩展名中既不包含白名单，也没有为内容协商显式注册以时，才需要这样做。 但是，在浏览器直接键入URL时，可能会产生副作用。</p>
<p>默认情况下，有许多常见的路径扩展白名单。具有自定义<code>HttpMessageConverter</code>实现的应用程序可以显式注册内容协商的文件扩展名，以避免为这些扩展添加<code>Content-Disposition</code> 头。 请参阅<a href="#mvc-config-content-negotiation">Content Types</a></p>
<p>有关RFD的其他建议，请参阅<a href="https://pivotal.io/security/cve-2015-5211">CVE-2015-5211</a>。</p>
<p><a id="mvc-ann-requestmapping-consumes"></a></p>
<h5><a href="#mvc-ann-requestmapping-consumes"></a>消费者媒体类型</h5>
<p><a href="web-reactive.html#webflux-ann-requestmapping-consumes">Same as in Spring WebFlux</a></p>
<p>您可以根据请求的<code>Content-Type</code>缩小请求映射范围，如以下示例所示:</p>
<pre><code class="language-java"><span class="hljs-meta">@PostMapping</span>(path = <span class="hljs-string">"/pets"</span>, consumes = <span class="hljs-string">"application/json"</span>) (<span class="hljs-number">1</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addPet</span><span class="hljs-params">(@RequestBody Pet pet)</span> </span>{
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<p><strong>1</strong>、使用 <code>consumes</code>属性来缩小内容类型的映射。</p>
<p><code>consumes</code>属性还支持否定表达式 - 例如，<code>!text/plain</code>表示除 <code>text/plain</code>之外的任何内容类型。</p>
<p>您可以在类级别声明共享 <code>consumes</code>属性。 但是，与大多数其他请求映射属性不同，在类级别使用时，方法级别会 <code>consumes</code> 属性覆盖而不是扩展类级别声明。</p>
<p><code>MediaType</code>为常用媒体类型提供常量，例如<code>APPLICATION_JSON_VALUE</code> and <code>APPLICATION_XML_VALUE</code>。</p>
<p><a id="mvc-ann-requestmapping-produces"></a></p>
<h5><a href="#mvc-ann-requestmapping-produces"></a>生产者媒体类型</h5>
<p><a href="web-reactive.html#webflux-ann-requestmapping-produces">Same as in Spring WebFlux</a></p>
<p>您可以根据<code>Accept</code>请求头和控制器方法生成的内容类型列表来缩小请求映射，如以下示例所示：</p>
<pre><code class="language-java"><span class="hljs-meta">@GetMapping</span>(path = <span class="hljs-string">"/pets/{petId}"</span>, produces = <span class="hljs-string">"application/json;charset=UTF-8"</span>) (<span class="hljs-number">1</span>)
<span class="hljs-meta">@ResponseBody</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> Pet <span class="hljs-title">getPet</span><span class="hljs-params">(@PathVariable String petId)</span> </span>{
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<p><strong>1</strong></p>
<p>使用<code>produces</code>属性来缩小内容类型的映射。</p>
<p>媒体类型可以指定字符集。 支持否定表达式 - 例如， <code>!text/plain</code>表示&quot;text/plain&quot;以外的任何内容类型。</p>
<p>对于JSON内容类型，即使 <a href="https://tools.ietf.org/html/rfc7159#section-11">RFC7159</a>明确声明“没有为此注册定义charset参数”，也应指定UTF-8字符集，因为某些浏览器要求它正确解释UTF-8特殊字符。</p>
<p>您可以在类级别声明共享的<code>produces</code>属性。 但是，与大多数其他请求映射属性不同，在类级别使用时，方法级别会生成属性覆盖，而不是扩展类级别声明。</p>
<p><code>MediaType</code>为常用媒体类型提供常量，例如<code>APPLICATION_JSON_UTF8_VALUE</code> and <code>APPLICATION_XML_VALUE</code>。</p>
<p><a id="mvc-ann-requestmapping-params-and-headers"></a></p>
<h5><a href="#mvc-ann-requestmapping-params-and-headers"></a>参数, 请求头</h5>
<p><a href="web-reactive.html#webflux-ann-requestmapping-params-and-headers">Same as in Spring WebFlux</a></p>
<p>您可以根据请求参数条件缩小请求映射。 您可以测试是否存在请求参数（<code>myParam</code>），缺少一个（<code>!myParam</code>）或特定值（<code>myParam=myValue</code>）。 以下示例显示如何测试特定值：</p>
<pre><code class="language-java"><span class="hljs-meta">@GetMapping</span>(path = <span class="hljs-string">"/pets/{petId}"</span>, params = <span class="hljs-string">"myParam=myValue"</span>) (<span class="hljs-number">1</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">findPet</span><span class="hljs-params">(@PathVariable String petId)</span> </span>{
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<p><strong>1</strong>、测试<code>myParam</code>是否等于<code>myValue</code>。</p>
<p>您还可以将其与请求头条件一起使用，如以下示例所示：:</p>
<pre><code class="language-java"><span class="hljs-meta">@GetMapping</span>(path = <span class="hljs-string">"/pets"</span>, headers = <span class="hljs-string">"myHeader=myValue"</span>) (<span class="hljs-number">1</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">findPet</span><span class="hljs-params">(@PathVariable String petId)</span> </span>{
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<p><strong>1</strong>、Testing whether <code>myHeader</code> equals <code>myValue</code> 。.</p>
<p>您可以将 <code>Content-Type</code>和 <code>Accept</code> 与headers条件匹配，但最好使用<a href="#mvc-ann-requestmapping-consumes">consumes</a>和<a href="#mvc-ann-requestmapping-produces">produces</a>替代。</p>
<p><a id="mvc-ann-requestmapping-head-options"></a></p>
<h5><a href="#mvc-ann-requestmapping-head-options"></a>HTTP HEAD, OPTIONS</h5>
<p><a href="web-reactive.html#webflux-ann-requestmapping-head-options">Same as in Spring WebFlux</a></p>
<p><code>@GetMapping</code> (和 <code>@RequestMapping(method=HttpMethod.GET)</code>)一样，为了请求映射的目的，透明地支持HTTP HEAD以进行请求映射。控制器方法无需更改。 在<code>javax.servlet.http.HttpServlet</code>中应用的响应包确保有<code>Content-Length</code>标头并且设置为写入的字节数，但实际上不会写入响应。</p>
<p><code>@GetMapping</code> (and <code>@RequestMapping(method=HttpMethod.GET)</code>)一样，为了请求映射的目的，被隐式映射到并支持HTTP HEAD，处理HTTP HEAD请求就像它是HTTP GET一样，但不是写入正文，而是计算字节数并设置 <code>Content-Length</code>头。</p>
<p>默认情况下，HTTP OPTIONS通过设置<code>Allow</code>响应头来为所有具有匹配URL模式的@RequestMapping方法中列出的HTTP方法列表来处理HTTP选项。</p>
<p>对于没有HTTP方法声明的<code>@RequestMapping</code>，Allow请求头可以设置为 <code>GET,HEAD,POST,PUT,PATCH,DELETE,OPTIONS</code>。 控制器方法应始终声明支持的HTTP方法（例如，通过使用特定于HTTP方法的变体：<code>@GetMapping</code>, <code>@PostMapping</code>等）。</p>
<p>您可以将 <code>@RequestMapping</code> 方法显式映射到HTTP HEAD和HTTP OPTIONS，但在常见情况下这不是必需的。</p>
<p><a id="mvc-ann-requestmapping-composed"></a></p>
<h5><a href="#mvc-ann-requestmapping-composed"></a>自定义注解</h5>
<p><a href="web-reactive.html#mvc-ann-requestmapping-head-options">Same as in Spring WebFlux</a></p>
<p>Spring MVC支持使用 <a href="core.html#beans-meta-annotations">组合注解</a>进行请求映射。 这些注解本身是使用 <code>@RequestMapping</code>进行元注解的，并且用于重新声明具有更窄，更具体目的的 <code>@RequestMapping</code>属性的子集（或全部）。</p>
<p><code>@GetMapping</code>, <code>@PostMapping</code>, <code>@PutMapping</code>, <code>@DeleteMapping</code>, 和 <code>@PatchMapping</code> 就是组合注解最好的示例， 提供它们是因为，可以说，大多数控制器方法应该映射到特定的HTTP方法，而不是使用<code>@RequestMapping</code>，默认情况下，它与所有HTTP方法匹配。 如果您需要组合注解的示例，请查看如何声明这些注解。</p>
<p>Spring MVC还支持使用自定义请求匹配逻辑的自定义请求映射属性。这是一个更高级的选项，需要继承<code>RequestMappingHandlerMapping</code> 并覆盖<code>getCustomMethodCondition</code> 方法， 您可以在其中检查自定义属性并返回自己的<code>RequestCondition</code>。</p>
<p><a id="mvc-ann-requestmapping-registration"></a></p>
<h5><a href="#mvc-ann-requestmapping-registration"></a>显式注册</h5>
<p><a href="web-reactive.html#webflux-ann-requestmapping-registration">Same as in Spring WebFlux</a></p>
<p>您可以以编程方式注册处理程序方法，您可以将其用于动态注册或高级情况，例如不同URL下的同一处理程序的不同实例。 以下示例注册处理程序方法：</p>
<pre><code class="language-java">@Configuration
public class MyConfig {

    @Autowired
    public void setHandlerMapping(RequestMappingHandlerMapping mapping, UserHandler handler) (1)
            throws NoSuchMethodException {

        RequestMappingInfo info = RequestMappingInfo
                .paths("/user/{id}").methods(RequestMethod.GET).build(); (2)

        Method method = UserHandler.class.getMethod("getUser", Long.class); (3)

        mapping.registerMapping(info, handler, method); (4)
    }

}
</code></pre>
<p><strong>1</strong>、为控制器注入目标处理程序和处理程序映射</p>
<p><strong>2</strong>、准备映射元数据的请求。</p>
<p><strong>3</strong>、获取处理程序方法。</p>
<p><strong>4</strong>、添加注册。</p>
<p><a id="mvc-ann-methods"></a></p>
<h4><a href="#mvc-ann-methods"></a>1.3.3. 程序处理方法</h4>
<p><a href="web-reactive.html#webflux-ann-methods">Same as in Spring WebFlux</a></p>
<p><code>@RequestMapping</code> 处理程序方法具有灵活的签名,可以从一系列受支持的控制器方法参数和返回值中进行选择.</p>
<p><a id="mvc-ann-arguments"></a></p>
<h5><a href="#mvc-ann-arguments"></a>方法参数</h5>
<p><a href="web-reactive.html#webflux-ann-arguments">Same as in Spring WebFlux</a></p>
<p>下表显示了受支持的控制器方法参数，任何参数都不支持响应式(Reactive)类型。</p>
<p>JDK 8’s <code>java.util.Optional</code> 作为方法参数来支持的，它与具有必需属性的注解(例如<code>@RequestParam</code>, <code>@RequestHeader</code>等相结合)。 并且等同于<code>required=false</code>。</p>
<table>
<thead>
<tr>
<th>控制器方法参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>WebRequest</code>, <code>NativeWebRequest</code></td>
<td>无需直接使用Servlet API即可访问请求参数以及request和session属性。</td>
</tr>
<tr>
<td><code>javax.servlet.ServletRequest</code>, <code>javax.servlet.ServletResponse</code></td>
<td>选择任何特定的请求或响应类型 - 例如，<code>ServletRequest</code>, <code>HttpServletRequest</code>或Spring的<code>MultipartRequest</code>, <code>MultipartHttpServletRequest</code>。</td>
</tr>
<tr>
<td><code>javax.servlet.http.HttpSession</code></td>
<td>强制进行会话。 因此，此类参数永远不可能为<code>null</code>. 请注意，会话访问不是线程安全的。 如果允许多个请求同时访问会话，请考虑将<code>RequestMappingHandlerAdapter</code>实例的<code>synchronizeOnSession</code>标志设置为true。</td>
</tr>
<tr>
<td><code>javax.servlet.http.PushBuilder</code></td>
<td>Spring4.0 push生成器API用于编程HTTP/2资源推送， 请注意，根据Servlet规范，如果客户端不支持该HTTP/2功能，则注入的<code>PushBuilder</code>实例可以为null。</td>
</tr>
<tr>
<td><code>java.security.Principal</code></td>
<td>当前经过身份验证的用户 - 如果已知，可能是特定的<code>Principal</code>实现类。</td>
</tr>
<tr>
<td><code>HttpMethod</code></td>
<td>请求的HTTP方法。</td>
</tr>
<tr>
<td><code>java.util.Locale</code></td>
<td>当前请求区域设置，由最可用的<code>LocaleResolver</code>（实际上是已配置的 <code>LocaleResolver</code>或<code>LocaleContextResolver</code>）确定。</td>
</tr>
<tr>
<td><code>java.util.TimeZone</code> + <code>java.time.ZoneId</code></td>
<td>与当前请求关联的时区，由<code>LocaleContextResolver</code>确定。</td>
</tr>
<tr>
<td><code>java.io.InputStream</code>, <code>java.io.Reader</code></td>
<td>用于访问Servlet API公开的原始请求主体。</td>
</tr>
<tr>
<td><code>java.io.OutputStream</code>, <code>java.io.Writer</code></td>
<td>用于访问Servlet API公开的原始响应主体。</td>
</tr>
<tr>
<td><code>@PathVariable</code></td>
<td>用于访问URI模板变量。 请参阅<a href="#mvc-ann-requestmapping-uri-templates">URI模式</a>。</td>
</tr>
<tr>
<td><code>@MatrixVariable</code></td>
<td>用于访问URI路径段中的名称 - 值对。 请参见<a href="#mvc-ann-matrix-variables">矩阵变量</a>。</td>
</tr>
<tr>
<td><code>@RequestParam</code></td>
<td>用于访问Servlet请求参数，包括多部分文件。 参数值将转换为声明的方法参数类型。 请参阅<a href="#mvc-ann-requestparam"><code>@RequestParam</code></a>以及<a href="#mvc-multipart-forms">Multipart</a>。 请注意，对于简单的参数值，使用<code>@RequestParam</code>是可选的。 请参阅本表末尾的“任何其他参数”。</td>
</tr>
<tr>
<td><code>@RequestHeader</code></td>
<td>用于访问请求头。 头的值将转换为声明的方法参数类型。 请参阅<a href="#mvc-ann-requestheader"><code>@RequestHeader</code></a>。</td>
</tr>
<tr>
<td><code>@CookieValue</code></td>
<td>用于访问cookie。 Cookie值将转换为声明的方法参数类型。 请参阅<a href="#mvc-ann-cookievalue"><code>@CookieValue</code></a>。</td>
</tr>
<tr>
<td><code>@RequestBody</code></td>
<td>用于访问HTTP请求正文。 通过使用<code>HttpMessageConverter</code>实现将正文内容转换为声明的方法参数类型。 请参阅 <a href="#mvc-ann-requestbody"><code>@RequestBody</code></a>。</td>
</tr>
<tr>
<td><code>HttpEntity&lt;B&gt;</code></td>
<td>用于访问请求标头和正文。 使用<code>HttpMessageConverter</code>转换正文。 见<a href="#mvc-ann-httpentity">HttpEntity</a>。</td>
</tr>
<tr>
<td><code>@RequestPart</code></td>
<td>要访问<code>multipart/form-data</code>请求中的部件，请使用<code>HttpMessageConverter</code>转换部件的主体。 见<a href="#mvc-multipart-forms">Multipart</a>。</td>
</tr>
<tr>
<td><code>java.util.Map</code>, <code>org.springframework.ui.Model</code>, <code>org.springframework.ui.ModelMap</code></td>
<td>用于访问HTML控制器中使用的模型，并将其作为视图呈现的一部分暴露给模板。</td>
</tr>
<tr>
<td><code>RedirectAttributes</code></td>
<td>指定在重定向（即，要附加到查询字符串）时使用的属性，以及临时存储的flash属性，直到重定向后的请求为止。 请参阅 <a href="#mvc-redirecting-passing-data">重定向属性</a>和<a href="#mvc-flash-attributes">Flash属性</a>。</td>
</tr>
<tr>
<td><code>@ModelAttribute</code></td>
<td>用于访问模型中的现有属性（如果不存在则实例化），并应用数据绑定和验证。 请参阅<a href="#mvc-ann-modelattrib-method-args"><code>@ModelAttribute</code></a> 以及<a href="#mvc-ann-modelattrib-methods">Model</a>和<a href="#mvc-ann-initbinder"><code>DataBinder</code></a>。请注意，使用<code>@ModelAttribute</code> 是可选的（例如，设置其属性）。 请参阅本表末尾的“任何其他参数”。</td>
</tr>
<tr>
<td><code>Errors</code>, <code>BindingResult</code></td>
<td>用于访问来自命令对象的验证和数据绑定的错误（即 <code>@ModelAttribute</code>参数）或来自验证 <code>@RequestBody</code>或 <code>@RequestPart</code> 参数的错误。 您必须在经过验证的方法参数后立即声明<code>Errors</code>或<code>BindingResult</code>参数。</td>
</tr>
<tr>
<td><code>SessionStatus</code> + class-level <code>@SessionAttributes</code></td>
<td>用于标记表单处理完成，从而触发通过类级别<code>@SessionAttributes</code>注解声明的会话属性的清除。 有关更多详细信息，请参阅<a href="#mvc-ann-sessionattributes"><code>@SessionAttributes</code></a>。</td>
</tr>
<tr>
<td><code>UriComponentsBuilder</code></td>
<td>用于准备相对于当前请求的主机，端口，方案，上下文路径和servlet映射的文字部分的URL。 请参阅<a href="#mvc-uri-building">URI Links</a>。</td>
</tr>
<tr>
<td><code>@SessionAttribute</code></td>
<td>用于访问任何会话属性，与由于类级别<code>@SessionAttributes</code>声明的结束形成对比。 有关更多详细信息，请参阅 <a href="#mvc-ann-sessionattribute"><code>@SessionAttribute</code></a>。</td>
</tr>
<tr>
<td><code>@RequestAttribute</code></td>
<td>用于访问请求属性。 有关更多详细信息，请参阅<a href="#mvc-ann-requestattrib"><code>@RequestAttribute</code></a>。</td>
</tr>
<tr>
<td>Any other argument</td>
<td>如果方法参数与此表中的任何值不匹配，并且它是一个简单类型（由 <a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-">BeanUtils#isSimpleProperty</a>确定， 则它被解析为 <code>@RequestParam</code>。否则，它将被解析为<code>@ModelAttribute</code>。</td>
</tr>
</tbody>
</table>
<p><a id="mvc-ann-return-types"></a></p>
<h5><a href="#mvc-ann-return-types"></a>返回值</h5>
<p><a href="web-reactive.html#webflux-ann-return-types">Same as in Spring WebFlux</a></p>
<p>下表描述了支持的控制器方法返回值。 所有返回值都支持响应式类型。</p>
<table>
<thead>
<tr>
<th>控制器方法返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>@ResponseBody</code></td>
<td>返回值通过<code>HttpMessageConverter</code>实现转换并写入响应。 请参阅<a href="#mvc-ann-responsebody"><code>@ResponseBody</code></a>。</td>
</tr>
<tr>
<td><code>HttpEntity&lt;B&gt;</code>, <code>ResponseEntity&lt;B&gt;</code></td>
<td>指定完整响应（包括HTTP头和主体）的返回值将通过 <code>HttpMessageConverter</code>实现转换并写入响应。 请参阅<a href="#mvc-ann-responseentity">ResponseEntity</a>。</td>
</tr>
<tr>
<td><code>HttpHeaders</code></td>
<td>用于返回带头部信息且没有正文的响应。</td>
</tr>
<tr>
<td><code>String</code></td>
<td>要使用<code>ViewResolver</code>实现解析的视图名称，并与隐式模型一起使用 - 通过命令对象和 <code>@ModelAttribute</code>方法确定。 处理程序方法还可以通过声明 <code>Model</code>参数以编程方式丰富模型（请参阅 <a href="#mvc-ann-requestmapping-registration">显式注册</a>）。</td>
</tr>
<tr>
<td><code>View</code></td>
<td>用于与隐式模型一起呈现的<code>View</code>实例 - 通过命令对象和<code>@ModelAttribute</code>方法确定。 处理程序方法还可以通过声明<code>Model</code>参数以编程方式丰富模型（请参阅 <a href="#mvc-ann-requestmapping-registration">显式注册</a>）。</td>
</tr>
<tr>
<td><code>java.util.Map</code>, <code>org.springframework.ui.Model</code></td>
<td>要添加到隐式模型的属性，通过<code>RequestToViewNameTranslator</code>隐式确定视图名称。</td>
</tr>
<tr>
<td><code>@ModelAttribute</code></td>
<td>要添加到模型的属性，通过<code>RequestToViewNameTranslator</code>隐式确定视图名称。请注意，<code>@ModelAttribute</code>是可选的。 请参阅本表末尾的“任何其他返回值”。</td>
</tr>
<tr>
<td><code>ModelAndView</code> object</td>
<td>要使用的视图和模型属性，以及（可选）响应状态。</td>
</tr>
<tr>
<td><code>void</code></td>
<td>如果具有<code>void</code>返回类型（或返回值为 <code>null</code> ）的方法，如果它还具有<code>ServletResponse</code>，<code>OutputStream</code>参数或<code>@ResponseStatus</code>注解， 则认为已完全处理该响应。 如果控制器已进行正<code>ETag</code>或<code>lastModified</code> 时间戳检查，则也是如此（有关详细信息，请参阅<a href="#mvc-caching-etag-lastmodified">Controllers</a>）。如果以上都不是真的，则<code>void</code>返回类型也可以指示REST控制器的“无响应主体”或HTML控制器的默认视图名称选择。</td>
</tr>
<tr>
<td><code>DeferredResult&lt;V&gt;</code></td>
<td>从任何线程异步生成任何前面的返回值 - 例如，由于某些事件或回调。 请参阅<a href="#mvc-ann-async">Asynchronous Requests</a> 和 <a href="#mvc-ann-async-deferredresult"><code>DeferredResult</code></a>.</td>
</tr>
<tr>
<td><code>Callable&lt;V&gt;</code></td>
<td>在Spring MVC管理的线程中异步生成上述任何返回值。 请参阅 <a href="#mvc-ann-async">Asynchronous Requests</a> 和 <a href="#mvc-ann-async-callable"><code>Callable</code></a>.</td>
</tr>
<tr>
<td><code>ListenableFuture&lt;V&gt;</code>, <code>java.util.concurrent.CompletionStage&lt;V&gt;</code>, <code>java.util.concurrent.CompletableFuture&lt;V&gt;</code></td>
<td>作为替代<code>DeferredResult</code>的便捷操作（例如，当底层服务返回其中一个时）。</td>
</tr>
<tr>
<td><code>ResponseBodyEmitter</code>, <code>SseEmitter</code></td>
<td>使用<code>HttpMessageConverter</code>实现以异步方式发送对象流以写入响应。 还支持<code>ResponseEntity</code>的主体。 请参阅<a href="#mvc-ann-async">Asynchronous Requests</a> and <a href="#mvc-ann-async-http-streaming">HTTP Streaming</a>.</td>
</tr>
<tr>
<td><code>StreamingResponseBody</code></td>
<td>异步写入响应<code>OutputStream</code>。 还支持<code>ResponseEntity</code>的主体。 请参阅<a href="#mvc-ann-async">Asynchronous Requests</a> and <a href="#mvc-ann-async-http-streaming">HTTP Streaming</a>.</td>
</tr>
<tr>
<td>Reactive types — Reactor, RxJava, or others through <code>ReactiveAdapterRegistry</code></td>
<td>使用multi-value流（例如，<code>Flux</code>, <code>Observable</code>）替代<code>DeferredResult</code>收集到<code>List</code>中。对于流式场景(例如, <code>text/event-stream</code>, <code>application/json+stream</code>), <code>SseEmitter</code> 和 <code>ResponseBodyEmitter</code> 使用的是在Spring MVC 管理的线程上执行<code>ServletOutputStream</code>阻塞I/O，这是 针对每一个Write的。请参阅 <a href="#mvc-ann-async">Asynchronous Requests</a> 和 <a href="#mvc-ann-async-reactive-types">Reactive Types</a>.</td>
</tr>
<tr>
<td>Any other return value</td>
<td>任何与此表中任何早期值不匹配且返回值为<code>String</code> 或<code>void</code>的返回值都被视为视图名称（通过<code>RequestToViewNameTranslator</code>应用默认视图名称选择）， 前提是它不是简单类型，由 <a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-">BeanUtils#isSimpleProperty</a>确定，简单类型的值仍未解决。</td>
</tr>
</tbody>
</table>
<p><a id="mvc-ann-typeconversion"></a></p>
<h5><a href="#mvc-ann-typeconversion"></a>类型转换</h5>
<p><a href="web-reactive.html#webflux-ann-typeconversion">Same as in Spring WebFlux</a></p>
<p>如果参数声明为String以外的其他参数，则表示某些带注解的控制器方法参数（例如<code>@RequestParam</code>, <code>@RequestHeader</code>, <code>@PathVariable</code>, <code>@MatrixVariable</code>, 和 <code>@CookieValue</code>）可能需要进行类型转换。</p>
<p>对于此类情况，将根据配置的转换器自动应用类型转换。 默认情况下，支持简单类型（<code>int</code>, <code>long</code>, <code>Date</code>和其他）。 您可以通过<code>WebDataBinder</code>（请参阅<a href="#mvc-ann-initbinder"><code>DataBinder</code></a>）或使用<code>FormattingConversionService</code>注册<code>Formatters</code>来自定义类型转换。 请参见 <a href="core.html#format">Spring Field Formatting</a>。</p>
<p><a id="mvc-ann-matrix-variables"></a></p>
<h5><a href="#mvc-ann-matrix-variables"></a>矩阵变量</h5>
<p><a href="web-reactive.html#webflux-ann-matrix-variables">Same as in Spring WebFlux</a></p>
<p><a href="https://tools.ietf.org/html/rfc3986#section-3.3">RFC 3986</a>讨论了路径段中的携带键值对。 在Spring MVC中，我们将那些基于Tim Berners-Lee的 <a href="https://www.w3.org/DesignIssues/MatrixURIs.html">“old post”</a> 称为“矩阵变量”，但它们也可以称为URI路径参数。</p>
<p>矩阵变量可以在任意路径段落中出现，每对矩阵变量之间使用分号隔开，多个值可以用逗号隔开（例如，<code>/cars;color=red,green;year=2012</code>）， 也可以通过重复的变量名称指定多个值（例如，<code>color=red;color=green;color=blue</code>）。</p>
<p>如果URL有可能会包含矩阵变量，那么在请求路径的映射配置上就需要使用URI模板来体现。这样才能确保请求可以被正确地映射，而不管矩阵变量在URI中是否出现、出现的次序是怎样的等。以下示例使用矩阵变量：</p>
<pre><code class="language-java"><span class="hljs-comment">// GET /pets/42;q=11;r=22</span>

<span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/pets/{petId}"</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">findPet</span><span class="hljs-params">(@PathVariable String petId, @MatrixVariable <span class="hljs-keyword">int</span> q)</span> </span>{

    <span class="hljs-comment">// petId == 42</span>
    <span class="hljs-comment">// q == 11</span>
}
</code></pre>
<p>由于任意路径段落中都可以含有矩阵变量，在某些场景下，开发者需要用更精确的信息来指定矩阵变量的位置。以下示例说明如何执行此操作：</p>
<pre><code class="language-java"><span class="hljs-comment">// GET /owners/42;q=11/pets/21;q=22</span>

<span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/owners/{ownerId}/pets/{petId}"</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">findPet</span><span class="hljs-params">(
        @MatrixVariable(name=<span class="hljs-string">"q"</span>, pathVar=<span class="hljs-string">"ownerId"</span>)</span> <span class="hljs-keyword">int</span> q1,
        @<span class="hljs-title">MatrixVariable</span><span class="hljs-params">(name=<span class="hljs-string">"q"</span>, pathVar=<span class="hljs-string">"petId"</span>)</span> <span class="hljs-keyword">int</span> q2) </span>{

    <span class="hljs-comment">// q1 == 11</span>
    <span class="hljs-comment">// q2 == 22</span>
}
</code></pre>
<p>矩阵变量可以定义为可选，并指定默认值，如以下示例所示：</p>
<pre><code class="language-java"><span class="hljs-comment">// GET /pets/42</span>

<span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/pets/{petId}"</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">findPet</span><span class="hljs-params">(@MatrixVariable(required=<span class="hljs-keyword">false</span>, defaultValue=<span class="hljs-string">"1"</span>)</span> <span class="hljs-keyword">int</span> q) </span>{

    <span class="hljs-comment">// q == 1</span>
}
</code></pre>
<p>要获取所有矩阵变量，可以使用<code>MultiValueMap</code>，如以下示例所示:</p>
<pre><code class="language-java"><span class="hljs-comment">// GET /owners/42;q=11;r=12/pets/21;q=22;s=23</span>

<span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/owners/{ownerId}/pets/{petId}"</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">findPet</span><span class="hljs-params">(
        @MatrixVariable MultiValueMap&lt;String, String&gt; matrixVars,
        @MatrixVariable(pathVar=<span class="hljs-string">"petId"</span>)</span> MultiValueMap&lt;String, String&gt; petMatrixVars) </span>{

    <span class="hljs-comment">// matrixVars: ["q" : [11,22], "r" : 12, "s" : 23]</span>
    <span class="hljs-comment">// petMatrixVars: ["q" : 22, "s" : 23]</span>
}
</code></pre>
<p>请注意，您需要启用矩阵变量的使用。 在MVC Java配置中，您需要通过 <a href="#mvc-config-path-matching">路径匹配</a>将<code>removeSemicolonContent=false</code> 设置为<code>UrlPathHelper</code>。 在MVC XML命名空间中，您可以设置<code>&lt;mvc:annotation-driven enable-matrix-variables=&quot;true&quot;/&gt;</code>。</p>
<p><a id="mvc-ann-requestparam"></a></p>
<h5><a href="#mvc-ann-requestparam"></a><code>@RequestParam</code></h5>
<p><a href="web-reactive.html#webflux-ann-requestparam">Same as in Spring WebFlux</a></p>
<p>您可以使用<code>@RequestParam</code>注解将Servlet请求参数（即查询参数或表单数据）绑定到控制器中的方法参数。</p>
<p>以下示例显示了如何执行此操作：</p>
<pre><code class="language-java"><span class="hljs-meta">@Controller</span>
<span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/pets"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EditPetForm</span> </span>{

    <span class="hljs-comment">// ...</span>

    <span class="hljs-meta">@GetMapping</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">setupForm</span><span class="hljs-params">(@RequestParam(<span class="hljs-string">"petId"</span>)</span> <span class="hljs-keyword">int</span> petId, Model model) </span>{ (<span class="hljs-number">1</span>)
        Pet pet = <span class="hljs-keyword">this</span>.clinic.loadPet(petId);
        model.addAttribute(<span class="hljs-string">"pet"</span>, pet);
        <span class="hljs-keyword">return</span> <span class="hljs-string">"petForm"</span>;
    }

    <span class="hljs-comment">// ...</span>

}
</code></pre>
<p><strong>1</strong>、使用 <code>@RequestParam</code>绑定<code>petId</code>。</p>
<p>若参数使用了该注解，则该参数默认是必须提供的.但您可以通过将<code>@RequestParam</code>注解的<code>required</code>属性设置为false或通过使用 <code>java.util.Optional</code>包装器声明参数来指定方法参数是可选的。</p>
<p>如果目标方法参数类型不是<code>String</code>，则会自动应用类型转换。 请参阅<a href="#mvc-ann-typeconversion">类型转换</a>。</p>
<p>将参数类型声明为数组或列表允许为同一参数名称解析多个参数值。</p>
<p>当<code>@RequestParam</code>注解声明为<code>Map&lt;String, String&gt;</code> 或<code>MultiValueMap&lt;String, String&gt;</code>时， 如果注解中未指定参数名称，则会使用每个给定参数名称的请求参数值填充映射。</p>
<p>请注意，使用<code>@RequestParam</code>是可选的（例如，设置其属性）。 默认情况下， 任何属于简单值类型的参数（由<a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-">BeanUtils#isSimpleProperty</a>确定）并且未被任何其他参数解析器解析，都被视为使用<code>@RequestParam</code>进行注解。</p>
<p><a id="mvc-ann-requestheader"></a></p>
<h5><a href="#mvc-ann-requestheader"></a><code>@RequestHeader</code></h5>
<p><a href="web-reactive.html#webflux-ann-requestheader">Same as in Spring WebFlux</a></p>
<p>您可以使用<code>@RequestHeader</code>注解将请求标头绑定到控制器中的方法参数。</p>
<p>考虑以下请求，请求头为:</p>
<p>Host                    localhost:8080
Accept                  text/html,application/xhtml+xml,application/xml;q=0.9
Accept-Language         fr,en-gb;q=0.7,en;q=0.3
Accept-Encoding         gzip,deflate
Accept-Charset          ISO-8859-1,utf-8;q=0.7,*;q=0.7
Keep-Alive              300</p>
<p>以下示例获取<code>Accept-Encoding</code>和<code>Keep-Alive</code> 头的值：</p>
<pre><code class="language-java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/demo"</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">(
        @RequestHeader(<span class="hljs-string">"Accept-Encoding"</span>)</span> String encoding, <span class="hljs-params">(<span class="hljs-number">1</span>)</span>
        @<span class="hljs-title">RequestHeader</span><span class="hljs-params">(<span class="hljs-string">"Keep-Alive"</span>)</span> <span class="hljs-keyword">long</span> keepAlive) </span>{ (<span class="hljs-number">2</span>)
    <span class="hljs-comment">//...</span>
}
</code></pre>
<p><strong>1</strong>、获取 <code>Accept-Encoding</code> 头部信息.</p>
<p><strong>2</strong>、获取 <code>Keep-Alive</code> 头部信息.</p>
<p>如果目标方法参数类型不是<code>String</code>，则会自动应用类型转换。 请参阅<a href="#mvc-ann-typeconversion">类型转换</a>。</p>
<p>在<code>Map&lt;String, String&gt;</code>，<code>MultiValueMap&lt;String, String&gt;</code>或<code>HttpHeaders</code>参数上使用 <code>@RequestHeader</code>注解时，将使用所有请求头值填充映射。</p>
<p>内置支持可用于将逗号分隔的字符串转换为字符串或字符串集或类型转换系统已知的其他类型。 例如，使用 <code>@RequestHeader(&quot;Accept&quot;)</code> 注解的方法参数可以是<code>String</code>类型，也可以是<code>String[]</code>或<code>List&lt;String&gt;</code>。</p>
<p><a id="mvc-ann-cookievalue"></a></p>
<h5><a href="#mvc-ann-cookievalue"></a><code>@CookieValue</code></h5>
<p><a href="web-reactive.html#webflux-ann-cookievalue">Same as in Spring WebFlux</a></p>
<p>您可以使用<code>@CookieValue</code>注解将HTTP cookie的值绑定到控制器中的方法参数。</p>
<p>考虑使用以下cookie的请求:</p>
<p>JSESSIONID=415A4AC178C59DACE0B2C9CA727CDD84</p>
<p>以下示例显示了如何获取cookie值：</p>
<pre><code class="language-java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/demo"</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">(@CookieValue(<span class="hljs-string">"JSESSIONID"</span>)</span> String cookie) </span>{ (<span class="hljs-number">1</span>)
    <span class="hljs-comment">//...</span>
}
</code></pre>
<p><strong>1</strong>、获取<code>JSESSIONID</code> cookie的值</p>
<p>如果目标方法参数类型不是<code>String</code>，则自动应用类型转换。 请参阅<a href="#mvc-ann-typeconversion">类型转换</a>。</p>
<p><a id="mvc-ann-modelattrib-method-args"></a></p>
<h5><a href="#mvc-ann-modelattrib-method-args"></a><code>@ModelAttribute</code></h5>
<p><a href="web-reactive.html#webflux-ann-modelattrib-method-args">Same as in Spring WebFlux</a></p>
<p>您可以在方法参数上使用<code>@ModelAttribute</code>注解来从模型访问属性，或者如果不存在则将其实例化。 model属性还覆盖了名称与字段名称匹配的HTTP Servlet请求参数的值。 这称为数据绑定，它使您不必处理解析和转换单个查询参数和表单字段。 以下示例显示了如何执行此操作：</p>
<pre><code class="language-java"><span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/owners/{ownerId}/pets/{petId}/edit"</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">processSubmit</span><span class="hljs-params">(@ModelAttribute Pet pet)</span> </span>{ } (<span class="hljs-number">1</span>)
</code></pre>
<p><strong>1</strong>、绑定一个<code>Pet</code>的实例。</p>
<p>上面的<code>Pet</code>实例解析如下：:</p>
<ul>
<li>
<p>它可能来自已经添加的<a href="#mvc-ann-modelattrib-methods">Model</a>.</p>
</li>
<li>
<p>它可能因为<a href="#mvc-ann-sessionattributes"><code>@SessionAttributes</code></a>注解的使用已经存在在model中.</p>
</li>
<li>
<p>它可能是由URI模板变量和<code>转换</code>中取得的（下面会详细讲解）.</p>
</li>
<li>
<p>它可能是调用了自身的默认构造器被实例化出来的.</p>
</li>
<li>
<p>他可能从调用具有与Servlet请求参数匹配的参数的“primary constructor”。 参数名称通过JavaBeans<code>@ConstructorProperties</code>或字节码中的运行时保留参数名称确定。</p>
</li>
</ul>
<p>虽然通常使用<a href="#mvc-ann-modelattrib-methods">Model</a>来使用属性填充模型，但另一种替代方法是依赖于<code>Converter&lt;String, T&gt;</code>和URI路径变量。 在以下示例中，model属性名称<code>account</code>匹配URI路径变量 <code>account</code>，并通过将String字符串传递到已注册的<code>Converter&lt;String, Account&gt;</code>转换器来加载<code>Account</code> ：</p>
<pre><code class="language-java"><span class="hljs-meta">@PutMapping</span>(<span class="hljs-string">"/accounts/{account}"</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">save</span><span class="hljs-params">(@ModelAttribute(<span class="hljs-string">"account"</span>)</span> Account account) </span>{
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>下一步就是数据的绑定，<code>WebDataBinder</code>类能将请求参数，包括字符串的查询参数和表单字段等，通过名称匹配到model的属性上。成功匹配的字段在需要的时候会进行一次类型转换（从String类型到目标字段的类型），然后被填充到model对应的属性中， 有关数据绑定（和验证）的更多信息，请参阅<a href="core.html#validation">Validation</a>。 有关自定义数据绑定的更多信息，请参阅<a href="#mvc-ann-initbinder"><code>DataBinder</code></a>。</p>
<p>数据绑定可能导致错误。 默认情况下，会引发<code>BindException</code> 。 但是，要在控制器方法中检查此类错误，可以在<code>@ModelAttribute</code>旁边添加一个<code>BindingResult</code>参数，如以下示例所示：</p>
<pre><code class="language-java"><span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/owners/{ownerId}/pets/{petId}/edit"</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">processSubmit</span><span class="hljs-params">(@ModelAttribute(<span class="hljs-string">"pet"</span>)</span> Pet pet, BindingResult result) </span>{ (<span class="hljs-number">1</span>)
    <span class="hljs-keyword">if</span> (result.hasErrors()) {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"petForm"</span>;
    }
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<p><strong>1</strong>、在<code>@ModelAttribute</code>旁边添加 <code>BindingResult</code>。</p>
<p>在某些情况下，您可能希望在没有数据绑定的情况下访问model属性。对于这种情况，您可以将model注入控制器并直接访问它，或者设置<code>@ModelAttribute(binding=false)</code>，如下例所示：</p>
<pre><code class="language-java"><span class="hljs-meta">@ModelAttribute</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> AccountForm <span class="hljs-title">setUpForm</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AccountForm();
}

<span class="hljs-meta">@ModelAttribute</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> Account <span class="hljs-title">findAccount</span><span class="hljs-params">(@PathVariable String accountId)</span> </span>{
    <span class="hljs-keyword">return</span> accountRepository.findOne(accountId);
}

<span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"update"</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">update</span><span class="hljs-params">(@Valid AccountUpdateForm form, BindingResult result,
        @ModelAttribute(binding=<span class="hljs-keyword">false</span>)</span> Account account) </span>{ (<span class="hljs-number">1</span>)
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<p><strong>1</strong>、设置 <code>@ModelAttribute(binding=false)</code>.</p>
<p>通过添加<code>javax.validation.Valid</code>注解或Spring的<code>@Validated</code>注解（<a href="core.html#validation-beanvalidation">Bean validation</a>和<a href="core.html#validation">Spring validation</a>），您可以在数据绑定后自动应用验证。 以下示例显示了如何执行此操作：</p>
<pre><code class="language-java"><span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/owners/{ownerId}/pets/{petId}/edit"</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">processSubmit</span><span class="hljs-params">(@Valid @ModelAttribute(<span class="hljs-string">"pet"</span>)</span> Pet pet, BindingResult result) </span>{ (<span class="hljs-number">1</span>)
    <span class="hljs-keyword">if</span> (result.hasErrors()) {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"petForm"</span>;
    }
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<p><strong>1</strong>、验证 <code>Pet</code> 实例.</p>
<p>请注意，使用<code>@ModelAttribute</code>是可选的（例如，设置其属性）。 默认情况下，任何非简单值类型的参数（由<a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-">BeanUtils#isSimpleProperty</a>确定）并且未被任何其他参数解析器解析，都被视为使用<code>@ModelAttribute</code>进行注解。</p>
<p><a id="mvc-ann-sessionattributes"></a></p>
<h5><a href="#mvc-ann-sessionattributes"></a><code>@SessionAttributes</code></h5>
<p><a href="web-reactive.html#webflux-ann-sessionattributes">Same as in Spring WebFlux</a></p>
<p><code>@SessionAttributes</code>用于在请求之间的HTTP Servlet会话中存储model属性。 它是一个类型级别的注解，用于声明特定控制器使用的会话属性。 这通常列出model属性的名称或model属性的类型，这些属性应该透明地存储在会话中以供后续访问请求使用。</p>
<p>以下示例使用<code>@SessionAttributes</code>注解:</p>
<pre><code class="language-java"><span class="hljs-meta">@Controller</span>
<span class="hljs-meta">@SessionAttributes</span>(<span class="hljs-string">"pet"</span>) (<span class="hljs-number">1</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EditPetForm</span> </span>{
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<p><strong>1</strong>、Using the <code>@SessionAttributes</code> annotation.</p>
<p>在第一个请求中，当名称为<code>pet</code>的model属性添加到模型中时，他会自动保存到HTTP Servlet会话中，并保持不变，直到另一个控制器方法使用<code>SessionStatus</code>方法参数来清除存储，如下例所示：</p>
<pre><code class="language-java"><span class="hljs-meta">@Controller</span>
<span class="hljs-meta">@SessionAttributes</span>(<span class="hljs-string">"pet"</span>) (<span class="hljs-number">1</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EditPetForm</span> </span>{

    <span class="hljs-comment">// ...</span>

    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/pets/{id}"</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">handle</span><span class="hljs-params">(Pet pet, BindingResult errors, SessionStatus status)</span> </span>{
        <span class="hljs-keyword">if</span> (errors.hasErrors) {
            <span class="hljs-comment">// ...</span>
        }
            status.setComplete(); (<span class="hljs-number">2</span>)
            <span class="hljs-comment">// ...</span>
        }
    }
}
</code></pre>
<p><strong>1</strong>、在Servlet会话中存储<code>Pet</code>值。</p>
<p><strong>2</strong>、在Servlet会话中清除<code>Pet</code>值。</p>
<p><a id="mvc-ann-sessionattribute"></a></p>
<h5><a href="#mvc-ann-sessionattribute"></a><code>@SessionAttribute</code></h5>
<p><a href="web-reactive.html#webflux-ann-sessionattribute">Same as in Spring WebFlux</a></p>
<p>如果需要访问已存在的被全局session属性，例如在控制器之外（如通过过滤器）的（可有可无），请在方法参数上使用<code>@SessionAttribute</code>注解：</p>
<pre><code class="language-java"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/"</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">handle</span><span class="hljs-params">(@SessionAttribute User user)</span> </span>{ (<span class="hljs-number">1</span>)
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<p><strong>1</strong>、Using a <code>@SessionAttribute</code> annotation.</p>
<p>对于需要添加或删除会话属性的用例，请考虑将<code>org.springframework.web.context.request.WebRequest</code>或<code>javax.servlet.http.HttpSession</code>注入控制器方法。</p>
<p>作为控制器工作流的一部分，在会话中临时存储模型属性的方法可以使用<code>@SessionAttributes</code>，详情请参阅<a href="#mvc-ann-sessionattributes"><code>@SessionAttributes</code></a>。</p>
<p><a id="mvc-ann-requestattrib"></a></p>
<h5><a href="#mvc-ann-requestattrib"></a><code>@RequestAttribute</code></h5>
<p><a href="web-reactive.html#webflux-ann-requestattrib">Same as in Spring WebFlux</a></p>
<p>与<code>@SessionAttribute</code>类似，<code>@RequestAttribute</code>注解可用于访问由过滤器（<code>Filter</code>）或拦截器（<code>HandlerInterceptor</code>）创建的已存在的请求属性:</p>
<pre><code class="language-java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/"</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">handle</span><span class="hljs-params">(@RequestAttribute Client client)</span> </span>{ (<span class="hljs-number">1</span>)
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<p><strong>1</strong>、Using the <code>@RequestAttribute</code> annotation.</p>
<p><a id="mvc-redirecting-passing-data"></a></p>
<h5><a href="#mvc-redirecting-passing-data"></a>Redirect 属性</h5>
<p>默认情况下，所有模型属性都被视为在重定向URL中公开为URI模板变量。 在其余属性中，原始类型或集合或基本类型数组的属性将自动附加为查询参数。</p>
<p>如果专门为重定向准备了模型实例，期望的结果则是将原始类型属性作为查询参数。 但是，在带注解的控制器中，为了渲染目的，模型可以包含其他属性（例如，下拉字段值）。 为了避免在URL中出现此类属性的可能性，<code>@RequestMapping</code>方法可以声明<code>RedirectAttributes</code>类型的参数， 并使用它来指定可供<code>RedirectView</code>使用的确切属性。 如果方法重定向，则使用<code>RedirectAttributes</code>的内容。 否则，使用模型的内容。</p>
<p><code>RequestMappingHandlerAdapter</code>提供了一个名为<code>ignoreDefaultModelOnRedirect</code>的标志，您可以使用该标志指示如果控制器方法重定向，则永远不应使用默认模型的内容。 相反，控制器方法应声明<code>RedirectAttributes</code>类型的属性，如果不这样做，则不应将任何属性传递给<code>RedirectView</code>。 MVC命名空间和MVC Java配置都将此标志设置为<code>false</code>，以保持向后兼容性。 但是，对于新应用程序，我们建议将其设置为<code>true</code>。</p>
<p>请注意，扩展重定向URL时，当前请求中的URI模板变量会自动可用，您需要通过 <code>Model</code>或<code>RedirectAttributes</code>显式添加它们。 以下示例显示如何定义重定向：</p>
<pre><code class="language-java"><span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/files/{path}"</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">upload</span><span class="hljs-params">(...)</span> </span>{
    <span class="hljs-comment">// ...</span>
    <span class="hljs-keyword">return</span> <span class="hljs-string">"redirect:files/{path}"</span>;
}
</code></pre>
<p>将数据传递到重定向目标的另一种方法是使用flash属性。 与其他重定向属性不同，Flash属性保存在HTTP会话中（因此，不会出现在URL中）。 有关更多信息，请参阅 <a href="#mvc-flash-attributes">Flash 属性</a>。</p>
<p><a id="mvc-flash-attributes"></a></p>
<h5><a href="#mvc-flash-attributes"></a>Flash 属性</h5>
<p>Flash属性（flash attributes）提供了一个请求为另一个请求存储有用属性的方法。这在重定向的时候最常使用，比如常见的POST/REDIRECT/GET模式。 Flash属性会在重定向前被暂时地保存起来（通常是保存在session中），重定向后会重新被下一个请求取用并立即从原保存地移除。</p>
<p>为支持flash属性，Spring MVC提供了两个抽象。 <code>FlashMap</code>被用来存储flash属性，而用<code>FlashMapManager</code>来存储、取回、管理<code>FlashMap</code>的实例。</p>
<p>对flash属性的支持默认是启用“on” 的，并不需要显式声明，不过没用到它时它绝不会主动地去创建HTTP会话（session）。对于每个请求，框架都会“input” 一个<code>FlashMap</code>，里面存储了从上个请求（如果有）保存下来的属性；同时，每个请求也会“output”<code>FlashMap</code>，里面保存了要给下个请求使用的属性。 两个<code>FlashMap</code>实例在Spring MVC应用中的任何地点都可以通过<code>RequestContextUtils</code>工具类的静态方法取得。</p>
<p>控制器通常不需要直接接触<code>FlashMap</code>。一般是通过<code>@RequestMapping</code>方法去接受<code>RedirectAttributes</code>类型的参数，然后直接地往其中添加flash属性。 通过<code>RedirectAttributes</code>对象添加进去的flash属性会自动被填充到请求的“output”<code>FlashMap</code>对象中去。类似地，重定向后“input”的<code>FlashMap</code>属性也会自动被添加到服务重定向URL的控制器参数Model中去</p>
<p>匹配请求所使用的flash属性</p>
<p>flash属性的概念在其他许多的Web框架中也存在，并且实践证明有时可能会导致并发上的问题。这是因为从定义上讲，flash属性保存的时间是到下个请求接收到之前。 问题在于，“next”请求不一定刚好就是需要重定向到的那个请求，它有可能是其他的异步请求（比如polling请求或者资源请求等）。这会导致flash属性在到达真正的目标请求前就被移除了。</p>
<p>为了减少这个问题发生的可能性，重定向视图<code>RedirectView</code>会自动为一个<code>FlashMap</code>实例记录其目标重定向URL的路径和查询参数。然后，默认的<code>FlashMapManager</code>会在为请求查找其该“input”的<code>FlashMap</code>时，匹配这些信息。</p>
<p>这并不能完全解决重定向的并发问题，但极大程度地减少了这种可能性，因为它可以从重定向URL已有的信息中来做匹配。因此，一般只有在重定向的场景下，才推荐使用flash属性。</p>
<p><a id="mvc-multipart-forms"></a></p>
<h5><a href="#mvc-multipart-forms"></a>Multipart</h5>
<p><a href="web-reactive.html#webflux-multipart-forms">Same as in Spring WebFlux</a></p>
<p>启用<code>MultipartResolver</code>后，将解析具有<code>multipart/form-data</code>的POST请求的内容，并将其作为常规请求参数进行访问。 以下示例访问一个常规表单字段和一个上载文件：</p>
<pre><code class="language-java"><span class="hljs-meta">@Controller</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileUploadController</span> </span>{

    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/form"</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">handleFormUpload</span><span class="hljs-params">(@RequestParam(<span class="hljs-string">"name"</span>)</span> String name,
            @<span class="hljs-title">RequestParam</span><span class="hljs-params">(<span class="hljs-string">"file"</span>)</span> MultipartFile file) </span>{

        <span class="hljs-keyword">if</span> (!file.isEmpty()) {
            <span class="hljs-keyword">byte</span>[] bytes = file.getBytes();
            <span class="hljs-comment">// store the bytes somewhere</span>
            <span class="hljs-keyword">return</span> <span class="hljs-string">"redirect:uploadSuccess"</span>;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-string">"redirect:uploadFailure"</span>;
    }
}
</code></pre>
<p>将参数类型声明为<code>List&lt;MultipartFile&gt;</code>允许为同一参数名称解析多个文件。</p>
<p>当<code>@RequestParam</code>注解声明为<code>Map&lt;String, MultipartFile&gt;</code>或<code>MultiValueMap&lt;String, MultipartFile&gt;</code>时，如果注解中未指定参数名称，则会使用每个给定参数名称的多部分文件填充map。</p>
<p>使用Servlet 3.0多部分解析，您也可以将 <code>javax.servlet.http.Part</code>而不是Spring的<code>MultipartFile</code>声明为方法参数或集合值类型。</p>
<p>您还可以将多部分内容用作绑定到<a href="#mvc-ann-modelattrib-method-args">命令对象</a>的数据的一部分。 例如，前面示例中的表单字段和文件可以是表单对象上的字段，如以下示例所示：</p>
<pre><code class="language-java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyForm</span> </span>{

    <span class="hljs-keyword">private</span> String name;

    <span class="hljs-keyword">private</span> MultipartFile file;

    <span class="hljs-comment">// ...</span>
}

<span class="hljs-meta">@Controller</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileUploadController</span> </span>{

    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/form"</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">handleFormUpload</span><span class="hljs-params">(MyForm form, BindingResult errors)</span> </span>{
        <span class="hljs-keyword">if</span> (!form.getFile().isEmpty()) {
            <span class="hljs-keyword">byte</span>[] bytes = form.getFile().getBytes();
            <span class="hljs-comment">// store the bytes somewhere</span>
            <span class="hljs-keyword">return</span> <span class="hljs-string">"redirect:uploadSuccess"</span>;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-string">"redirect:uploadFailure"</span>;
    }
}
</code></pre>
<p>还可以在RESTful服务方案中从非浏览器客户端提交多部分请求。 以下示例显示了带有JSON的文件：</p>
<pre><code class="language-json">POST /someUrl
Content-Type: multipart/mixed

--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp
Content-Disposition: form-data; name="meta-data"
Content-Type: application/json; charset=UTF-8
Content-Transfer-Encoding: 8bit

{
    "name": "value"
}
--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp
Content-Disposition: form-data; name="file-data"; filename="file.properties"
Content-Type: text/xml
Content-Transfer-Encoding: 8bit
... File Data ...

</code></pre>
<p>对于名称为&quot;meta-data&quot; 的部分，可以通过控制器方法上的<code>@RequestParam</code>String metadata参数来获得。但对于那部分请求体中为JSON格式数据的请求， 可能更想通过接受一个对应的强类型对象，就像<code>@RequestBody</code>通过<a href="integration.html#rest-message-conversion">HttpMessageConverter</a>将一般请求的请求体转换成一个对象一样。使用<code>@RequestPart</code>注解访问多部分：</p>
<pre><code class="language-java"><span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/"</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">handle</span><span class="hljs-params">(@RequestPart(<span class="hljs-string">"meta-data"</span>)</span> MetaData metadata,
        @<span class="hljs-title">RequestPart</span><span class="hljs-params">(<span class="hljs-string">"file-data"</span>)</span> MultipartFile file) </span>{
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>您可以将<code>@RequestPart</code>与<code>javax.validation.Valid</code>结合使用，或使用Spring的<code>@Validated</code>注解，这两种注解都会导致应用标准Bean验证。 默认情况下，验证错误会导致<code>MethodArgumentNotValidException</code>， 并将其转换为400（BAD_REQUEST）响应。 或者，您可以通过<code>Errors</code> 或<code>BindingResult</code> 参数在控制器内本地处理验证错误，如以下示例所示:</p>
<pre><code class="language-java"><span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/"</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">handle</span><span class="hljs-params">(@Valid @RequestPart(<span class="hljs-string">"meta-data"</span>)</span> MetaData metadata,
        BindingResult result) </span>{
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<p><a id="mvc-ann-requestbody"></a></p>
<h5><a href="#mvc-ann-requestbody"></a><code>@RequestBody</code></h5>
<p><a href="web-reactive.html#webflux-ann-requestbody">Same as in Spring WebFlux</a></p>
<p>您可以使用<code>@RequestBody</code>注解通过<a href="integration.html#rest-message-conversion"><code>HttpMessageConverter</code></a>将请求主体读取并反序列化为<code>Object</code>。 以下示例使用<code>@RequestBody</code>参数:</p>
<pre><code class="language-java"><span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/accounts"</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">(@RequestBody Account account)</span> </span>{
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>您可以使用<a href="#mvc-config">MVC Config</a> 的<a href="#mvc-config-message-converters">Message Converters</a>选项来配置或自定义消息转换。</p>
<p>您可以将<code>@RequestBody</code>与<code>javax.validation.Valid</code>或Spring的<code>@Validated</code> 注解结合使用，这两种注解都会导致应用标准Bean验证。 默认情况下，验证错误会导致 <code>MethodArgumentNotValidException</code>，并将其转换为400（BAD_REQUEST）响应。 或者，您可以通过<code>Errors</code>或<code>BindingResult</code>参数在控制器内本地处理验证错误，如以下示例所示：:</p>
<pre><code class="language-java"><span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/accounts"</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">(@Valid @RequestBody Account account, BindingResult result)</span> </span>{
    <span class="hljs-comment">// ...</span>
}

</code></pre>
<p><a id="mvc-ann-httpentity"></a></p>
<h5><a href="#mvc-ann-httpentity"></a>HttpEntity</h5>
<p><a href="web-reactive.html#webflux-ann-httpentity">Same as in Spring WebFlux</a></p>
<p><code>HttpEntity</code>与使用<a href="#mvc-ann-requestbody"><code>@RequestBody</code></a>或多或少有些类似，但它基于一个公开请求头和正文的容器对象。 以下清单显示了一个示例:</p>
<pre><code class="language-java"><span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/accounts"</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">(HttpEntity&lt;Account&gt; entity)</span> </span>{
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<p><a id="mvc-ann-responsebody"></a></p>
<h5><a href="#mvc-ann-responsebody"></a><code>@ResponseBody</code></h5>
<p><a href="web-reactive.html#webflux-ann-responsebody">Same as in Spring WebFlux</a></p>
<p>您可以在方法上使用<code>@ResponseBody</code>注解，以通过<a href="integration.html#rest-message-conversion">HttpMessageConverter</a>将返回序列化到响应主体。 以下清单显示了一个示例:</p>
<pre><code class="language-java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/accounts/{id}"</span>)
<span class="hljs-meta">@ResponseBody</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> Account <span class="hljs-title">handle</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>类级别也支持<code>@ResponseBody</code> ，在这种情况下，它由所有控制器方法继承。 例如<code>@RestController</code>的效果，它只不过是一个用<code>@Controller</code>和<code>@ResponseBody</code>标记的元注解。</p>
<p>您可以将<code>@ResponseBody</code>与reactive类型一起使用。 有关更多详细信息，请参阅<a href="#mvc-ann-async">异步请求</a>和<a href="#mvc-ann-async-reactive-types">Reactive 类型</a>。</p>
<p>您可以使用<a href="#mvc-config">MVC Config</a>的 <a href="#mvc-config-message-converters">Message Converters</a>选项来配置或自定义消息转换。</p>
<p>您可以将<code>@ResponseBody</code>方法与JSON序列化视图结合使用。 有关详细信息，请参阅<a href="#mvc-ann-jackson">Jackson JSON</a>。</p>
<p><a id="mvc-ann-responseentity"></a></p>
<h5><a href="#mvc-ann-responseentity"></a>ResponseEntity</h5>
<p><a href="web-reactive.html#webflux-ann-responseentity">Same as in Spring WebFlux</a></p>
<p><code>ResponseEntity</code>与 <a href="#mvc-ann-responsebody"><code>@ResponseBody</code></a> 类似，但具有状态和响应头。 例如:</p>
<pre><code class="language-java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/something"</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity&lt;String&gt; <span class="hljs-title">handle</span><span class="hljs-params">()</span> </span>{
    String body = ... ;
    String etag = ... ;
    <span class="hljs-keyword">return</span> ResponseEntity.ok().eTag(etag).build(body);
}
</code></pre>
<p>Spring MVC支持使用单值<a href="#mvc-ann-async-reactive-types">reactive type</a>异步生成 <code>ResponseEntity</code>，and/or 主体的单值和多值reactive类型。</p>
<p><a id="mvc-ann-jackson"></a></p>
<h5><a href="#mvc-ann-jackson"></a>Jackson JSON</h5>
<p>Spring为Jackson JSON库提供支持。</p>
<p><a id="mvc-ann-jsonview"></a></p>
<h6><a href="#mvc-ann-jsonview"></a>Jackson 序列化视图</h6>
<p><a href="web-reactive.html#webflux-ann-jsonview">Same as in Spring WebFlux</a></p>
<p>Spring MVC为<a href="http://wiki.fasterxml.com/JacksonJsonViews">Jackson的序列化视图</a>提供内置支持，允许仅渲染Object中所有字段的子集。 为了与<code>@ResponseBody</code>控制器方法或者返回<code>ResponseEntity</code>的控制器方法一起使用，可以简单地将<code>@JsonView</code>注解放在参数上，指定需要使用的视图类或接口即可。如以下示例所示：</p>
<pre><code class="language-java"><span class="hljs-meta">@RestController</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>{

    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/user"</span>)
    <span class="hljs-meta">@JsonView</span>(User.WithoutPasswordView<span class="hljs-class">.<span class="hljs-keyword">class</span>)
    <span class="hljs-title">public</span> <span class="hljs-title">User</span> <span class="hljs-title">getUser</span>() </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User(<span class="hljs-string">"eric"</span>, <span class="hljs-string">"7!jd#h23"</span>);
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>{

    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">WithoutPasswordView</span> </span>{};
    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">WithPasswordView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WithoutPasswordView</span> </span>{};

    <span class="hljs-keyword">private</span> String username;
    <span class="hljs-keyword">private</span> String password;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">()</span> </span>{
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(String username, String password)</span> </span>{
        <span class="hljs-keyword">this</span>.username = username;
        <span class="hljs-keyword">this</span>.password = password;
    }

    <span class="hljs-meta">@JsonView</span>(WithoutPasswordView<span class="hljs-class">.<span class="hljs-keyword">class</span>)
    <span class="hljs-title">public</span> <span class="hljs-title">String</span> <span class="hljs-title">getUsername</span>() </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.username;
    }

    <span class="hljs-meta">@JsonView</span>(WithPasswordView<span class="hljs-class">.<span class="hljs-keyword">class</span>)
    <span class="hljs-title">public</span> <span class="hljs-title">String</span> <span class="hljs-title">getPassword</span>() </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.password;
    }
}
</code></pre>
<p><code>@JsonView</code>允许一组视图类，但每个控制器方法只能指定一个。 如果需要激活多个视图，可以使用复合接口。</p>
<p>对于依赖视图的控制器，只需将序列化视图类添加到model中即可。如以下示例所示：</p>
<pre><code class="language-java"><span class="hljs-meta">@Controller</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractController</span> </span>{

    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/user"</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUser</span><span class="hljs-params">(Model model)</span> </span>{
        model.addAttribute(<span class="hljs-string">"user"</span>, <span class="hljs-keyword">new</span> User(<span class="hljs-string">"eric"</span>, <span class="hljs-string">"7!jd#h23"</span>));
        model.addAttribute(JsonView<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getName</span>(), <span class="hljs-title">User</span>.<span class="hljs-title">WithoutPasswordView</span>.<span class="hljs-title">class</span>)</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-string">"userView"</span>;
    }
}
</code></pre>
<p><a id="mvc-ann-modelattrib-methods"></a></p>
<h4><a href="#mvc-ann-modelattrib-methods"></a>1.3.4. Model</h4>
<p><a href="web-reactive.html#webflux-ann-modelattrib-methods">Same as in Spring WebFlux</a></p>
<p>您可以使用<code>@ModelAttribute</code> 注解：</p>
<ul>
<li>
<p>在<code>@RequestMapping</code>方法中的<a href="#mvc-ann-modelattrib-method-args">方法参数</a>方法参数，用于从model创建或访问Object并通过<code>WebDataBinder</code>将其绑定到请求。</p>
</li>
<li>
<p>作为 <code>@Controller</code>或<code>@ControllerAdvice</code> 类中的方法级注解，有助于在任何 <code>@RequestMapping</code>方法调用之前初始化模型。</p>
</li>
<li>
<p>在<code>@RequestMapping</code>方法上标记其返回值是一个模型属性。</p>
</li>
</ul>
<p>本节讨论<code>@ModelAttribute</code>注解可被应用在方法或方法参数上 - 前面列表中的第二项。控制器可以包含任意数量的 <code>@ModelAttribute</code>方法。 在同一控制器中的<code>@RequestMapping</code>方法之前调用所有这些方法。 <code>@ModelAttribute</code>方法也可以通过<code>@ControllerAdvice</code>在控制器之间共享。 有关更多详细信息，请参阅<a href="#mvc-ann-controller-advice">控制器上的通知</a> 部分。</p>
<p><code>@ModelAttribute</code>方法具有灵活的方法签名。 除了与<code>@ModelAttribute</code>本身或请求体相关的任何内容外，它们支持许多与<code>@RequestMapping</code>方法相同的参数。</p>
<p>以下示例显示了<code>@ModelAttribute</code> 方法：</p>
<pre><code class="language-java"><span class="hljs-meta">@ModelAttribute</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">populateModel</span><span class="hljs-params">(@RequestParam String number, Model model)</span> </span>{
    model.addAttribute(accountRepository.findAccount(number));
    <span class="hljs-comment">// add more ...</span>
}
</code></pre>
<p>以下示例仅添加一个属性:</p>
<pre><code class="language-java"><span class="hljs-meta">@ModelAttribute</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> Account <span class="hljs-title">addAccount</span><span class="hljs-params">(@RequestParam String number)</span> </span>{
    <span class="hljs-keyword">return</span> accountRepository.findAccount(number);
}
</code></pre>
<p>如果未明确指定名称，框架将根据属性的类型给予一个默认名称，如<a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/core/Conventions.html"><code>Conventions</code></a>的javadoc中所述。 你可以通过设置<code>@ModelAttribute</code>注解的值来改变默认值。当向Model中直接添加属性时，请使用合适的重载方法<code>addAttribute</code>。</p>
<p><code>@ModelAttribute</code> 注解也可以被用在<code>@RequestMapping</code>方法上，这种情况下，<code>@RequestMapping</code>方法的返回值将会被解释为model的一个属性，而非一个视图名。 此时视图名将以视图命名约定来方式来决议，与返回值为void的方法所采用的处理方法类似。<code>@ModelAttribute</code> 还可以自定义模型属性名称，如以下示例所示：</p>
<pre><code class="language-java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/accounts/{id}"</span>)
<span class="hljs-meta">@ModelAttribute</span>(<span class="hljs-string">"myAccount"</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> Account <span class="hljs-title">handle</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// ...</span>
    <span class="hljs-keyword">return</span> account;
}
</code></pre>
<p><a id="mvc-ann-initbinder"></a></p>
<h4><a href="#mvc-ann-initbinder"></a>1.3.5. <code>数据绑定</code></h4>
<p><a href="web-reactive.html#webflux-ann-initbinder">Same as in Spring WebFlux</a></p>
<p><code>@Controller</code>或<code>@ControllerAdvice</code>类可以使用<code>@InitBinder</code> 方法初始化<code>WebDataBinder</code>的实例，而这些方法又可以：</p>
<ul>
<li>
<p>将请求参数（即表单或查询数据）绑定到模型对象。</p>
</li>
<li>
<p>将基于字符串的请求值（例如请求参数，路径变量，请求头，cookie等）转换为目标类型的控制器方法参数。</p>
</li>
<li>
<p>在呈现HTML表单时将模型对象值格式化为<code>String</code>值。</p>
</li>
</ul>
<p><code>@InitBinder</code>方法可以注册特定于控制器的<code>java.bean.PropertyEditor</code>或Spring <code>Converter</code>和<code>Formatter</code>组件。 此外，您可以使用<a href="#mvc-config-conversion">MVC config</a>在全局共享的<code>FormattingConversionService</code>中注册<code>Converter</code>和<code>Formatter</code>类型。</p>
<p><code>@InitBinder</code> 方法支持许多与<code>@RequestMapping</code>方法相同的参数，但<code>@ModelAttribute</code>（命令对象）参数除外。 通常，它们使用<code>WebDataBinder</code>参数（用于注册）和void返回值进行声明。 以下清单显示了一个示例:</p>
<pre><code class="language-java"><span class="hljs-meta">@Controller</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FormController</span> </span>{

    <span class="hljs-meta">@InitBinder</span> (<span class="hljs-number">1</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initBinder</span><span class="hljs-params">(WebDataBinder binder)</span> </span>{
        SimpleDateFormat dateFormat = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">"yyyy-MM-dd"</span>);
        dateFormat.setLenient(<span class="hljs-keyword">false</span>);
        binder.registerCustomEditor(Date<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">new</span> <span class="hljs-title">CustomDateEditor</span>(<span class="hljs-title">dateFormat</span>, <span class="hljs-title">false</span>))</span>;
    }

    <span class="hljs-comment">// ...</span>
}
</code></pre>
<p><strong>1</strong>、Defining an <code>@InitBinder</code> method.</p>
<p>或者，当使用基于Formatter的设置时，您可以通过共享的<code>FormattingConversionService</code>重复使用相同的方法并注册特定于控制器的 <code>Formatter</code> 实现，如以下示例所示:</p>
<pre><code class="language-java"><span class="hljs-meta">@Controller</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FormController</span> </span>{

    <span class="hljs-meta">@InitBinder</span> (<span class="hljs-number">1</span>)
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initBinder</span><span class="hljs-params">(WebDataBinder binder)</span> </span>{
        binder.addCustomFormatter(<span class="hljs-keyword">new</span> DateFormatter(<span class="hljs-string">"yyyy-MM-dd"</span>));
    }

    <span class="hljs-comment">// ...</span>
}
</code></pre>
<p><strong>1</strong>、Defining an <code>@InitBinder</code> method on a custom formatter.</p>
<p><a id="mvc-ann-exceptionhandler"></a></p>
<h4><a href="#mvc-ann-exceptionhandler"></a>1.3.6. 异常</h4>
<p><a href="web-reactive.html#webflux-ann-controller-exceptions">Same as in Spring WebFlux</a></p>
<p><code>@Controller</code> 和 <a href="#mvc-ann-controller-advice">@ControllerAdvice</a>可以使用<code>@ExceptionHandler</code>方法来处理来自控制器方法的异常，如下例所示：</p>
<pre><code class="language-java"><span class="hljs-meta">@Controller</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleController</span> </span>{

    <span class="hljs-comment">// ...</span>

    <span class="hljs-meta">@ExceptionHandler</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity&lt;String&gt; <span class="hljs-title">handle</span><span class="hljs-params">(IOException ex)</span> </span>{
        <span class="hljs-comment">// ...</span>
    }
}
</code></pre>
<p>该异常可能与顶级异常（即抛出直接<code>IOException</code>）或顶级包装器中的异常（例如，包含在 <code>IllegalStateException</code>内的<code>IOException</code>）相匹配。</p>
<p>对于匹配的异常类型，最好将目标异常声明为方法参数，如前面的示例所示。当多个异常方法匹配时，根(root)异常匹配通常优先于原因(cause )异常匹配。 更具体地说，<code>ExceptionDepthComparator</code> 用于根据抛出的异常类型的深度对异常进行排序。</p>
<p>注解声明可以缩小要匹配的异常类型，如以下示例所示：</p>
<pre><code class="language-java"><span class="hljs-meta">@ExceptionHandler</span>({FileSystemException<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">RemoteException</span>.<span class="hljs-title">class</span>})
<span class="hljs-title">public</span> <span class="hljs-title">ResponseEntity</span>&lt;<span class="hljs-title">String</span>&gt; <span class="hljs-title">handle</span>(<span class="hljs-title">IOException</span> <span class="hljs-title">ex</span>) </span>{
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>您甚至可以使用特定异常类型列表中的非常通用的参数签名，如以下示例所示：:</p>
<pre><code class="language-java"><span class="hljs-meta">@ExceptionHandler</span>({FileSystemException<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">RemoteException</span>.<span class="hljs-title">class</span>})
<span class="hljs-title">public</span> <span class="hljs-title">ResponseEntity</span>&lt;<span class="hljs-title">String</span>&gt; <span class="hljs-title">handle</span>(<span class="hljs-title">Exception</span> <span class="hljs-title">ex</span>) </span>{
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>根(root)和原因(cause )异常匹配之间的区别可能是令人惊讶的。</p>
<p>在前面显示的<code>IOException</code>变体中，通常使用实际的<code>FileSystemException</code>或<code>RemoteException</code>实例作为参数调用该方法，因为它们都是从<code>IOException</code>扩展的。 但是，如果任何此类异常在包装器内传播，而该异常本身就是<code>IOException</code>，则传入的异常实例就是包装器异常。</p>
<p>在<code>handle(Exception)</code>变体中，行为更简单。 这总是在包装场景中使用包装器异常调用，在这种情况下可以通过 <code>ex.getCause()</code>找到实际匹配的异常。 传入的异常仅在实际的<code>FileSystemException</code>或<code>RemoteException</code>实例被抛出为顶级异常时才会发生。</p>
<p>我们通常建议您在参数签名中尽可能具体，减少root和cause异常类型之间不匹配的可能性。 考虑将多匹配方法分解为单独的<code>@ExceptionHandler</code>方法，每个方法通过其签名匹配单个特定异常类型。</p>
<p>在具有多个<code>@ControllerAdvice</code>组成中，我们建议在<code>@ControllerAdvice</code>上声明根异常映射，并使用相应的顺序进行优先级排序。 虽然根异常匹配优先于某个原因，但这是在给定控制器或 <code>@ControllerAdvice</code>类的方法中定义的。 这意味着优先级较高的 <code>@ControllerAdvice</code> bean上的原因匹配优先于较低优先级的 <code>@ControllerAdvice</code> bean上的任何匹配（例如，root）。</p>
<p>最后但同样重要的是， 可以通过<code>@ExceptionHandler</code>方法的实现，讲异常以原始的形式重新抛出，并提供给特定的异常实例。 这在您仅对根级别匹配或在特定上下文中无法静态确定的匹配中感兴趣的情况下非常有用。 重新抛出的异常通过后续的解析链传播，就好像给定的<code>@ExceptionHandler</code>方法首先不匹配一样。</p>
<p>Spring MVC中对<code>@ExceptionHandler</code>方法的支持是基于<code>DispatcherServlet</code>级别的<a href="#mvc-exceptionhandlers">HandlerExceptionResolver</a>机制构建的。</p>
<p><a id="mvc-ann-exceptionhandler-args"></a></p>
<h5><a href="#mvc-ann-exceptionhandler-args"></a>方法参数</h5>
<p><code>@ExceptionHandler</code> 方法支持以下参数：</p>
<table>
<thead>
<tr>
<th>方法 参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Exception type</td>
<td>用于访问引发的异常。</td>
</tr>
<tr>
<td><code>HandlerMethod</code></td>
<td>访问控制器方法引发的异常</td>
</tr>
<tr>
<td><code>WebRequest</code>, <code>NativeWebRequest</code></td>
<td>无需直接使用Servlet API即可访问请求参数以及请求和会话属性。</td>
</tr>
<tr>
<td><code>javax.servlet.ServletRequest</code>, <code>javax.servlet.ServletResponse</code></td>
<td>选择任何特定的请求或响应类型（例如，<code>ServletRequest</code> or <code>HttpServletRequest</code> or or Spring’s <code>MultipartRequest</code> or <code>MultipartHttpServletRequest</code>).</td>
</tr>
<tr>
<td><code>javax.servlet.http.HttpSession</code></td>
<td>强制进行会话。 因此，这样的结果永远不会是<code>null</code>的。请注意，会话访问不是线程安全的。 如果允许多个请求同时访问会话，请考虑将<code>RequestMappingHandlerAdapter</code>实例的<code>synchronizeOnSession</code>标志设置为<code>true</code>。</td>
</tr>
<tr>
<td><code>java.security.Principal</code></td>
<td>当前经过身份验证的用户 - 如果已知，可能是特定的 <code>Principal</code>实现类。</td>
</tr>
<tr>
<td><code>HttpMethod</code></td>
<td>请求的HTTP方法。</td>
</tr>
<tr>
<td><code>java.util.Locale</code></td>
<td>当前请求区域设置，由最可用的 <code>LocaleResolver</code>（实际上是已配置的 <code>LocaleResolver</code>或<code>LocaleContextResolver</code>）确定。</td>
</tr>
<tr>
<td><code>java.util.TimeZone</code>, <code>java.time.ZoneId</code></td>
<td>与当前请求关联的时区，由<code>LocaleContextResolver</code>确定。</td>
</tr>
<tr>
<td><code>java.io.OutputStream</code>, <code>java.io.Writer</code></td>
<td>用于访问Servlet API公开的原始响应主体。</td>
</tr>
<tr>
<td><code>java.util.Map</code>, <code>org.springframework.ui.Model</code>, <code>org.springframework.ui.ModelMap</code></td>
<td>用于访问模型以获取错误响应。 总是为空.</td>
</tr>
<tr>
<td><code>RedirectAttributes</code></td>
<td>指定在重定向的情况下使用的属性 - （将附加到查询字符串）和临时存储的flash属性，直到重定向后的请求为止。 请参阅<a href="#mvc-redirecting-passing-data">Redirect 属性</a>和<a href="#mvc-flash-attributes">Flash 属性</a>。</td>
</tr>
<tr>
<td><code>@SessionAttribute</code></td>
<td>用于访问任何会话属性，与由于类级别<code>@SessionAttributes</code>声明的结束形成对比。 有关更多详细信息，请参阅<a href="#mvc-ann-sessionattribute"><code>@SessionAttribute</code></a>。</td>
</tr>
<tr>
<td><code>@RequestAttribute</code></td>
<td>用于访问请求属性。 有关更多详细信息，请参阅<a href="#mvc-ann-requestattrib"><code>@RequestAttribute</code></a>。</td>
</tr>
</tbody>
</table>
<p><a id="mvc-ann-exceptionhandler-return-values"></a></p>
<h5><a href="#mvc-ann-exceptionhandler-return-values"></a>返回值</h5>
<p><code>@ExceptionHandler</code>方法支持以下返回值:</p>
<table>
<thead>
<tr>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>@ResponseBody</code></td>
<td>返回值通过<code>HttpMessageConverter</code>实现转换并写入响应。 请参阅<a href="#mvc-ann-responsebody"><code>@ResponseBody</code></a>。</td>
</tr>
<tr>
<td><code>HttpEntity&lt;B&gt;</code>, <code>ResponseEntity&lt;B&gt;</code></td>
<td>指定完整响应（包括HTTP头和主体）的返回值将通过 <code>HttpMessageConverter</code>实现转换并写入响应。 请参阅<a href="#mvc-ann-responseentity">ResponseEntity</a>。</td>
</tr>
<tr>
<td><code>String</code></td>
<td>要使用<code>ViewResolver</code>实现解析的视图名称，并与隐式模型一起使用 - 通过命令对象和 <code>@ModelAttribute</code>方法确定。 处理程序方法还可以通过声明 <code>Model</code>参数以编程方式丰富模型（请参阅 <a href="#mvc-ann-requestmapping-registration">显式注册</a>）。</td>
</tr>
<tr>
<td><code>View</code></td>
<td>用于与隐式模型一起呈现的<code>View</code>实例 - 通过命令对象和<code>@ModelAttribute</code>方法确定。 处理程序方法还可以通过声明<code>Model</code>参数以编程方式丰富模型（请参阅 <a href="#mvc-ann-requestmapping-registration">显式注册</a>）。</td>
</tr>
<tr>
<td><code>java.util.Map</code>, <code>org.springframework.ui.Model</code></td>
<td>要添加到隐式模型的属性，通过<code>RequestToViewNameTranslator</code>隐式确定视图名称。</td>
</tr>
<tr>
<td><code>@ModelAttribute</code></td>
<td>要添加到模型的属性，通过隐式确定视图名称。请注意，<code>@ModelAttribute</code>是可选的。 请参阅本表末尾的“任何其他返回值”。</td>
</tr>
<tr>
<td><code>ModelAndView</code> object</td>
<td>要使用的视图和模型属性，以及（可选）响应状态。</td>
</tr>
<tr>
<td><code>void</code></td>
<td>如果具有<code>void</code>返回类型（或返回值为 <code>null</code> ）的方法，如果它还具有<code>ServletResponse</code>，<code>OutputStream</code>参数或<code>@ResponseStatus</code>注解， 则认为已完全处理该响应。 如果控制器已进行正<code>ETag</code>或<code>lastModified</code> 时间戳检查，则也是如此（有关详细信息，请参阅<a href="#mvc-caching-etag-lastmodified">Controllers</a>）。 如果以上都不是真的，则<code>void</code>返回类型也可以指示REST控制器的“无响应主体”或HTML控制器的默认视图名称选择。</td>
</tr>
<tr>
<td>Any other return value</td>
<td>任何与此表中任何早期值不匹配且返回值为<code>String</code> 或<code>void</code>的返回值都被视为视图名称（通过<code>RequestToViewNameTranslator</code>应用默认视图名称选择）， 前提是它不是简单类型，由 <a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-">BeanUtils#isSimpleProperty</a>确定，简单类型的值仍未解决。</td>
</tr>
</tbody>
</table>
<p><a id="mvc-ann-rest-exceptions"></a></p>
<h5><a href="#mvc-ann-rest-exceptions"></a>REST API 异常</h5>
<p><a href="web-reactive.html#webflux-ann-rest-exceptions">Same as in Spring WebFlux</a></p>
<p>REST服务的一个常见要求是在响应正文中包含错误详细信息。 Spring Framework不会自动执行此操作，因为响应正文中的错误详细信息的表示是特定于应用程序的。 但是，<code>@RestController</code>可以使用带有ResponseEntity返回值的<code>@ExceptionHandler</code>方法来设置响应的状态和正文。 这些方法也可以在<code>@ControllerAdvice</code>类中声明，以全局应用它们。</p>
<p>在响应主体中实现具有错误详细信息的全局异常处理的应用程序应考虑扩展<a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/servlet/mvc/method/annotation/ResponseEntityExceptionHandler.html"><code>ResponseEntityExceptionHandler</code></a>， 它提供对Spring MVC引发的异常的处理，并提供钩子来定制响应主体。要使用它，请创建<code>ResponseEntityExceptionHandler</code>的子类，使用<code>@ControllerAdvice</code>注解它，覆盖必要的方法，并将其声明为Spring bean。</p>
<p><a id="mvc-ann-controller-advice"></a></p>
<h4><a href="#mvc-ann-controller-advice"></a>1.3.7. 控制器通知</h4>
<p><a href="web-reactive.html#webflux-ann-controller-advice">Same as in Spring WebFlux</a></p>
<p>通常，在<code>@Controller</code>类上声明<code>@ExceptionHandler</code>, <code>@InitBinder</code>, 和 <code>@ModelAttribute</code>注解。 如果您希望此类方法更全局地应用（跨控制器），则可以在标有<code>@ControllerAdvice</code> 或 <code>@RestControllerAdvice</code>的类中声明它们。</p>
<p><code>@ControllerAdvice``@Component</code>标记，这意味着可以通过<a href="core.html#beans-java-instantiating-container-scan">组件扫描</a>将这些类注册为Spring bean。 <code>@RestControllerAdvice</code>也是一个用<code>@ControllerAdvice</code>和<code>@ResponseBody</code>标记的元注解，这实际上意味着 <code>@ExceptionHandler</code> 方法通过消息转换（与视图分辨率或模板渲染相对）呈现给响应主体。</p>
<p>在启动时， <code>@RequestMapping</code>和<code>@ExceptionHandler</code>方法的基础结构类检测 <code>@ControllerAdvice</code> 类型的Spring bean，然后在运行时应用它们的方法。 全局<code>@ExceptionHandler</code>方法（来自<code>@ControllerAdvice</code>）在本地方法之后（来自 <code>@Controller</code>）应用。 相比之下，全局<code>@ModelAttribute</code>和<code>@InitBinder</code>方法在本地方法之前应用。</p>
<p>默认情况下，<code>@ControllerAdvice</code>方法适用于每个请求（即所有控制器），但您可以通过使用注解上的属性将其缩小到控制器的子集，如以下示例所示：</p>
<pre><code class="language-java"><span class="hljs-comment">// Target all Controllers annotated with @RestController</span>
<span class="hljs-meta">@ControllerAdvice</span>(annotations = RestController<span class="hljs-class">.<span class="hljs-keyword">class</span>)
<span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">ExampleAdvice1</span> </span>{}

<span class="hljs-comment">// Target all Controllers within specific packages</span>
<span class="hljs-meta">@ControllerAdvice</span>(<span class="hljs-string">"org.example.controllers"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleAdvice2</span> </span>{}

<span class="hljs-comment">// Target all Controllers assignable to specific classes</span>
<span class="hljs-meta">@ControllerAdvice</span>(assignableTypes = {ControllerInterface<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">AbstractController</span>.<span class="hljs-title">class</span>})
<span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">ExampleAdvice3</span> </span>{}
</code></pre>
<p>前面示例中的选择器在运行时进行评估，如果广泛使用，可能会对性能产生负面影响。 有关更多详细信息，请参阅<a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/bind/annotation/ControllerAdvice.html"><code>@ControllerAdvice</code></a> javadoc 。</p>
<p><a id="mvc-uri-building"></a></p>
<h3><a href="#mvc-uri-building"></a>1.4. URI 链接</h3>
<p><a href="web-reactive.html#webflux-uri-building">Same as in Spring WebFlux</a></p>
<p>本节介绍Spring Framework中可用于处理URI的各种选项。</p>
<p><a id="web-uricomponents"></a></p>
<h4><a href="#web-uricomponents"></a>1.4.1. UriComponents</h4>
<p>Spring MVC和Spring WebFlux</p>
<p><code>UriComponentsBuilder</code> 有助于从URI模板变量构建URI。 如下例所示:</p>
<pre><code class="language-java">UriComponents uriComponents = UriComponentsBuilder
        .fromUriString(<span class="hljs-string">"http://example.com/hotels/{hotel}"</span>)  (<span class="hljs-number">1</span>)
        .queryParam(<span class="hljs-string">"q"</span>, <span class="hljs-string">"{q}"</span>)  (<span class="hljs-number">2</span>)
        .encode() (<span class="hljs-number">3</span>)
        .build(); (<span class="hljs-number">4</span>)

URI uri = uriComponents.expand(<span class="hljs-string">"Westin"</span>, <span class="hljs-string">"123"</span>).toUri();  (<span class="hljs-number">5</span>)
</code></pre>
<p><strong>1</strong>、带有URI模板的静态工厂方法。</p>
<p><strong>2</strong>、添加或替换URI组件。</p>
<p><strong>3</strong>、请求编码URI模板和URI变量。</p>
<p><strong>4</strong>、构建一个<code>UriComponents</code>.</p>
<p><strong>5</strong>、暴露变量并获取<code>URI</code>.</p>
<p>前面的示例可以合并到一个链中，并使用<code>buildAndExpand</code>缩短，如下例所示:</p>
<pre><code class="language-java">URI uri = UriComponentsBuilder
        .fromUriString(<span class="hljs-string">"http://example.com/hotels/{hotel}"</span>)
        .queryParam(<span class="hljs-string">"q"</span>, <span class="hljs-string">"{q}"</span>)
        .encode()
        .buildAndExpand(<span class="hljs-string">"Westin"</span>, <span class="hljs-string">"123"</span>)
        .toUri();
</code></pre>
<p>您可以通过直接转到URI（这意味着编码）来进一步缩短它，如下例所示：</p>
<pre><code class="language-java">URI uri = UriComponentsBuilder
        .fromUriString(<span class="hljs-string">"http://example.com/hotels/{hotel}"</span>)
        .queryParam(<span class="hljs-string">"q"</span>, <span class="hljs-string">"{q}"</span>)
        .build(<span class="hljs-string">"Westin"</span>, <span class="hljs-string">"123"</span>);
</code></pre>
<p>您使用完整的URI模板进一步缩短它，如下例所示：</p>
<pre><code class="language-java">URI uri = UriComponentsBuilder
        .fromUriString(<span class="hljs-string">"http://example.com/hotels/{hotel}?q={q}"</span>)
        .build(<span class="hljs-string">"Westin"</span>, <span class="hljs-string">"123"</span>);
</code></pre>
<p><a id="web-uribuilder"></a></p>
<h4><a href="#web-uribuilder"></a>1.4.2. UriBuilder</h4>
<p>Spring MVC和Spring WebFlux</p>
<p><a href="#web-uricomponents"><code>UriComponentsBuilder</code></a> 实现了 <code>UriBuilder</code>。 您可以使用<code>UriBuilderFactory</code>创建一个 <code>UriBuilder</code>。 <code>UriBuilderFactory</code>和<code>UriBuilder</code>一起提供了一种可插入机制，可以根据共享配置（例如基本URL，编码首选项和其他详细信息）从URI模板构建URI。</p>
<p>您可以使用UriBuilderFactory配置<code>RestTemplate</code>和<code>WebClient</code>。为自定义URI做准备。<code>DefaultUriBuilderFactory</code> 是<code>UriBuilderFactory</code> 的默认实现，它在内部使用<code>UriComponentsBuilder</code>并公开共享配置选项。</p>
<p>以下示例显示如何配置<code>RestTemplate</code>:</p>
<pre><code class="language-java"><span class="hljs-comment">// import org.springframework.web.util.DefaultUriBuilderFactory.EncodingMode;</span>

String baseUrl = <span class="hljs-string">"http://example.org"</span>;
DefaultUriBuilderFactory factory = <span class="hljs-keyword">new</span> DefaultUriBuilderFactory(baseUrl);
factory.setEncodingMode(EncodingMode.TEMPLATE_AND_VARIABLES);

RestTemplate restTemplate = <span class="hljs-keyword">new</span> RestTemplate();
restTemplate.setUriTemplateHandler(factory);
</code></pre>
<p>以下示例配置<code>WebClient</code>:</p>
<pre><code class="language-java"><span class="hljs-comment">// import org.springframework.web.util.DefaultUriBuilderFactory.EncodingMode;</span>

String baseUrl = <span class="hljs-string">"http://example.org"</span>;
DefaultUriBuilderFactory factory = <span class="hljs-keyword">new</span> DefaultUriBuilderFactory(baseUrl);
factory.setEncodingMode(EncodingMode.TEMPLATE_AND_VARIABLES);

WebClient client = WebClient.builder().uriBuilderFactory(factory).build();
</code></pre>
<p>此外，您还可以直接使用 <code>DefaultUriBuilderFactory</code> 。 它类似于使用<code>UriComponentsBuilder</code> ，但它不是静态工厂方法，而是一个保存配置和首选项的实际实例，如下例所示：</p>
<pre><code class="language-java">String baseUrl = <span class="hljs-string">"http://example.com"</span>;
DefaultUriBuilderFactory uriBuilderFactory = <span class="hljs-keyword">new</span> DefaultUriBuilderFactory(baseUrl);

URI uri = uriBuilderFactory.uriString(<span class="hljs-string">"/hotels/{hotel}"</span>)
        .queryParam(<span class="hljs-string">"q"</span>, <span class="hljs-string">"{q}"</span>)
        .build(<span class="hljs-string">"Westin"</span>, <span class="hljs-string">"123"</span>);
</code></pre>
<p><a id="web-uri-encoding"></a></p>
<h4><a href="#web-uri-encoding"></a>1.4.3. URI 编码</h4>
<p>Spring MVC 和 Spring WebFlux</p>
<p><code>UriComponentsBuilder</code>在两个级别公开编码选项：</p>
<ul>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/util/UriComponentsBuilder.html#encode--">UriComponentsBuilder#encode()</a>: 首先对URI模板进行预编码，然后在扩展时严格编码URI变量。.</p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/util/UriComponents.html#encode--">UriComponents#encode()</a>: 扩展URI变量后对URI组件进行编码。</p>
</li>
</ul>
<p>这两个选项都使用转义的八位字节替换非ASCII和非法字符。 但是，第一个选项还会替换出现在URI变量中的保留含义的字符。</p>
<p>考虑&quot;;&quot;，这在路径中是合法的但具有保留意义。第一个选项取代&quot;;&quot;在URI变量中使用&quot;%3B&quot;但在URI模板中没有。 相比之下，第二个选项永远不会替换“;”，因为它是路径中的合法字符。</p>
<p>对于大多数情况，第一个选项可能会给出预期结果，因为它将URI变量视为完全编码的不透明数据，而选项2仅在URI变量故意包含保留字符时才有用。</p>
<p>以下示例使用第一个选项:</p>
<pre><code class="language-java">URI uri = UriComponentsBuilder.fromPath(<span class="hljs-string">"/hotel list/{city}"</span>)
            .queryParam(<span class="hljs-string">"q"</span>, <span class="hljs-string">"{q}"</span>)
            .encode()
            .buildAndExpand(<span class="hljs-string">"New York"</span>, <span class="hljs-string">"foo+bar"</span>)
            .toUri();

    <span class="hljs-comment">// Result is "/hotel%20list/New%20York?q=foo%2Bbar"</span>
</code></pre>
<p>您可以通过直接转到URI（这意味着编码）来缩短前面的示例，如以下示例所示：</p>
<pre><code class="language-java">URI uri = UriComponentsBuilder.fromPath(<span class="hljs-string">"/hotel list/{city}"</span>)
            .queryParam(<span class="hljs-string">"q"</span>, <span class="hljs-string">"{q}"</span>)
            .build(<span class="hljs-string">"New York"</span>, <span class="hljs-string">"foo+bar"</span>)
</code></pre>
<p>您可以使用完整的URI模板进一步缩短它，如以下示例所示：</p>
<pre><code class="language-java">URI uri = UriComponentsBuilder.fromPath(<span class="hljs-string">"/hotel list/{city}?q={q}"</span>)
            .build(<span class="hljs-string">"New York"</span>, <span class="hljs-string">"foo+bar"</span>)
</code></pre>
<p><code>WebClient</code>和<code>RestTemplate</code>通过 <code>UriBuilderFactory</code>策略在内部展开和编码URI模板。 两者都可以配置自定义策略。 如下例所示：</p>
<pre><code class="language-java">String baseUrl = <span class="hljs-string">"http://example.com"</span>;
DefaultUriBuilderFactory factory = <span class="hljs-keyword">new</span> DefaultUriBuilderFactory(baseUrl)
factory.setEncodingMode(EncodingMode.TEMPLATE_AND_VALUES);

<span class="hljs-comment">// Customize the RestTemplate..</span>
RestTemplate restTemplate = <span class="hljs-keyword">new</span> RestTemplate();
restTemplate.setUriTemplateHandler(factory);

<span class="hljs-comment">// Customize the WebClient..</span>
WebClient client = WebClient.builder().uriBuilderFactory(factory).build();
</code></pre>
<p><code>DefaultUriBuilderFactory</code>实现在内部使用<code>UriComponentsBuilder</code>来展开和编码URI模板。 作为工厂，它提供了一个单独的位置来配置编码方法，基于以下编码模式之一：</p>
<ul>
<li>
<p><code>TEMPLATE_AND_VALUES</code>: 使用<code>UriComponentsBuilder#encode()</code>（对应于前面列表中的第一个选项）对URI模板进行预编码，并在展开时严格编码URI变量。</p>
</li>
<li>
<p><code>VALUES_ONLY</code>: 不对URI模板进行编码，而是在将URI变量展开到模板之前，通过<code>UriUtils#encodeUriUriVariables</code>对URI变量严格编码。</p>
</li>
<li>
<p><code>URI_COMPONENTS</code>: 使用<code>UriComponents#encode()</code>（对应于前面列表中的第二个选项），在URI变量展开后对URI组件值进行编码。</p>
</li>
<li>
<p><code>NONE</code>: 没有应用编码。</p>
</li>
</ul>
<p>出于历史原因和向后兼容性，<code>RestTemplate</code>设置为 <code>EncodingMode.URI_COMPONENTS</code>。<code>WebClient</code> 依赖于<code>DefaultUriBuilderFactory</code>中的默认值， 该值已从5.0.x中的 <code>EncodingMode.URI_COMPONENTS</code>更改为5.1中的 <code>EncodingMode.TEMPLATE_AND_VALUES</code>。</p>
<p><a id="mvc-servleturicomponentsbuilder"></a></p>
<h4><a href="#mvc-servleturicomponentsbuilder"></a>1.4.4. 相对请求</h4>
<p>您可以使用<code>ServletUriComponentsBuilder</code>创建相对于当前请求的URI，如以下示例所示：</p>
<pre><code class="language-java">HttpServletRequest request = ...

<span class="hljs-comment">// Re-uses host, scheme, port, path and query string...</span>

ServletUriComponentsBuilder ucb = ServletUriComponentsBuilder.fromRequest(request)
        .replaceQueryParam(<span class="hljs-string">"accountId"</span>, <span class="hljs-string">"{id}"</span>).build()
        .expand(<span class="hljs-string">"123"</span>)
        .encode();
</code></pre>
<p>您可以创建相对于上下文路径的URI，如以下示例所示:</p>
<pre><code class="language-java"><span class="hljs-comment">// Re-uses host, port and context path...</span>

ServletUriComponentsBuilder ucb = ServletUriComponentsBuilder.fromContextPath(request)
        .path(<span class="hljs-string">"/accounts"</span>).build()
</code></pre>
<p>您可以创建相对于Servlet的URI（例如，<code>/main/*</code>），如以下示例所示:</p>
<pre><code class="language-java"><span class="hljs-comment">// Re-uses host, port, context path, and Servlet prefix...</span>

ServletUriComponentsBuilder ucb = ServletUriComponentsBuilder.fromServletMapping(request)
        .path(<span class="hljs-string">"/accounts"</span>).build()
</code></pre>
<p>从5.1开始，<code>ServletUriComponentsBuilder</code>忽略来自<code>Forwarded</code>和<code>X-Forwarded-*</code>头部的信息，这些头部信息指定了客户端发起的地址。 考虑使用<a href="#filters-forwarded-headers"><code>ForwardedHeaderFilter</code></a>来提取和使用或丢弃此类请求头。</p>
<p><a id="mvc-links-to-controllers"></a></p>
<h4><a href="#mvc-links-to-controllers"></a>1.4.5. 控制器链接</h4>
<p>Spring MVC也提供了构造指定控制器方法链接的机制。 例如，以下MVC控制器允许创建链接：</p>
<pre><code class="language-java"><span class="hljs-meta">@Controller</span>
<span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/hotels/{hotel}"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookingController</span> </span>{

    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/bookings/{booking}"</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">getBooking</span><span class="hljs-params">(@PathVariable Long booking)</span> </span>{
        <span class="hljs-comment">// ...</span>
    }
}
</code></pre>
<p>您可以通过引用方法名字的办法来准备一个链接，如以下示例所示：</p>
<pre><code class="language-java">UriComponents uriComponents = MvcUriComponentsBuilder
    .fromMethodName(BookingController.class, "getBooking", 21).buildAndExpand(42);

URI uri = uriComponents.encode().toUri();
</code></pre>
<p>在前面的示例中，为方法参数准备了填充值（在本例中，long值： <code>21</code>），以用于填充路径变量并插入到URL中。此外，我们提供了值42，来填充任何剩余的URI变量，比如从类层级的请求映射中继承来的hotel变量。 如果方法还有更多的参数，你可以为那些不需要参与URL构造的变量赋予null值。 通常，只有<code>@PathVariable</code>和<code>@RequestParam</code>参数与构造URL相关。</p>
<p>还有其他方法可以使用<code>MvcUriComponentsBuilder</code>。 例如，例如可以通过类似mock掉测试对象的方法，用代理来避免直接通过名字引用一个控制，如以下示例所示（该示例假设静态导入<code>MvcUriComponentsBuilder.on</code>）：</p>
<pre><code class="language-java">UriComponents uriComponents = MvcUriComponentsBuilder
    .fromMethodCall(on(BookingController<span class="hljs-class">.<span class="hljs-keyword">class</span>).<span class="hljs-title">getBooking</span>(21)).<span class="hljs-title">buildAndExpand</span>(42)</span>;

URI uri = uriComponents.encode().toUri();
</code></pre>
<p>Controller method signatures are limited in their design when they are supposed to be usable for link creation with <code>fromMethodCall</code>. Aside from needing a proper parameter signature, there is a technical limitation on the return type (namely, generating a runtime proxy for link builder invocations), so the return type must not be <code>final</code>. In particular, the common <code>String</code> return type for view names does not work here. You should use <code>ModelAndView</code> or even plain <code>Object</code> (with a <code>String</code> return value) instead.</p>
<p>上面的代码例子中使用了<code>MvcUriComponentsBuilder</code>类的静态方法，内部实现中，它依赖于<code>ServletUriComponentsBuilder</code>来从当前请求中抽取schema、主机名、端口号、context路径和Servlet路径， 并准备一个基本URL。大多数情况下它能良好工作，但有时还不行，比如，在准备链接时你可能在当前请求的上下文（context）之外（比如，执行一个准备链接links的批处理），或你可能需要为路径插入一个前缀（比如一个地区性前缀，它从请求中被移除，然后又重新被插入到链接中去）。</p>
<p>对于上面所提的场景，开发者可以使用重载过的静态方法<code>fromXxx</code>，它接收一个<code>UriComponentsBuilder</code>参数，然后从中获取基本URL以便使用，或你也可以使用一个基本URL创建一个<code>MvcUriComponentsBuilder</code>对象， 然后使用实例对象的<code>withXxx</code>方法。以下列表使用 <code>withMethodCall</code>:</p>
<pre><code class="language-java">UriComponentsBuilder base = ServletUriComponentsBuilder.fromCurrentContextPath().path(<span class="hljs-string">"/en"</span>);
MvcUriComponentsBuilder builder = MvcUriComponentsBuilder.relativeTo(base);
builder.withMethodCall(on(BookingController<span class="hljs-class">.<span class="hljs-keyword">class</span>).<span class="hljs-title">getBooking</span>(21)).<span class="hljs-title">buildAndExpand</span>(42)</span>;

URI uri = uriComponents.encode().toUri();
</code></pre>
<p>从5.1开始，<code>MvcUriComponentsBuilder</code>忽略来自<code>Forwarded</code> 和<code>X-Forwarded-*</code>头的信息，这些头指定了客户端发起的地址。 考虑使用ForwardedHeaderFilter来提取和使用或丢弃此类标头。</p>
<p><a id="mvc-links-to-controllers-from-views"></a></p>
<h4><a href="#mvc-links-to-controllers-from-views"></a>1.4.6. 视图链接</h4>
<p>在Thymeleaf，FreeMarker或JSP等视图中，您可以通过引用每个请求映射的隐式或显式指定名称来构建指向带注解控制器的链接。</p>
<p>请考虑以下示例：</p>
<pre><code class="language-java"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/people/{id}/addresses"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonAddressController</span> </span>{

    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/{country}"</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> HttpEntity <span class="hljs-title">getAddress</span><span class="hljs-params">(@PathVariable String country)</span> </span>{ ... }
}
</code></pre>
<p>给定前面的控制器，可以按照以下方式准备来自JSP的链接，如下所示：</p>
<pre><code class="language-jsp">&lt;%@ taglib uri="http://www.springframework.org/tags" prefix="s" %&gt;
...
&lt;a href="${s:mvcUrl('PAC#getAddress').arg(0,'US').buildAndExpand('123')}"&gt;Get Address&lt;/a&gt;
</code></pre>
<p>前面的示例依赖于Spring标签库中声明的<code>mvcUrl</code>函数（即 META-INF/spring.tld），但可以很容易地定义自定义函数或使用自定义标记文件。</p>
<p>这是如何工作的，在启动时，每个<code>@RequestMapping</code> 都通过<code>HandlerMethodMappingNamingStrategy</code>分配一个默认名称，其默认实现使用类的大写字母和方法名称（例如， <code>ThingController</code>中的<code>getThing</code>方法变为&quot;TC#getThing&quot;）。如果存在名称冲突，则可以使用<code>@RequestMapping(name=&quot;..&quot;)</code>分配显式名称或实现自己的<code>HandlerMethodMappingNamingStrategy</code>。</p>
<p><a id="mvc-ann-async"></a></p>
<h3><a href="#mvc-ann-async"></a>1.5. 异步请求</h3>
<p><a href="#mvc-ann-async-vs-webflux">Compared to WebFlux</a></p>
<p>Spring MVC与Servlet 3.0异步请求<a href="#mvc-ann-async-processing">处理</a>有广泛的集成：</p>
<ul>
<li>
<p>在控制器方法中返回<a href="#mvc-ann-async-deferredresult"><code>DeferredResult</code></a>和<a href="#mvc-ann-async-callable"><code>Callable</code></a>，并为单个异步返回值提供基本支持。</p>
</li>
<li>
<p>控制器可以<a href="#mvc-ann-async-http-streaming">stream</a>多个值，包括<a href="#mvc-ann-async-sse">SSE</a> 和<a href="#mvc-ann-async-output-stream">raw data</a>。</p>
</li>
<li>
<p>控制器可以使用reactive clients 并返回<a href="#mvc-ann-async-reactive-types">reactive types</a>以进行响应处理。</p>
</li>
</ul>
<p><a id="mvc-ann-async-deferredresult"></a></p>
<h4><a href="#mvc-ann-async-deferredresult"></a>1.5.1. <code>DeferredResult</code></h4>
<p><a href="#mvc-ann-async-vs-webflux">Compared to WebFlux</a></p>
<p>一旦在Servlet容器中<a href="#mvc-ann-async-configuration">启用</a> 了异步请求处理功能，控制器方法就可以使用 <code>DeferredResult</code>包装任何支持的控制器方法返回值，如以下示例所示：</p>
<pre><code class="language-java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/quotes"</span>)
<span class="hljs-meta">@ResponseBody</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> DeferredResult&lt;String&gt; <span class="hljs-title">quotes</span><span class="hljs-params">()</span> </span>{
    DeferredResult&lt;String&gt; deferredResult = <span class="hljs-keyword">new</span> DeferredResult&lt;String&gt;();
    <span class="hljs-comment">// Save the deferredResult somewhere..</span>
    <span class="hljs-keyword">return</span> deferredResult;
}

<span class="hljs-comment">// From some other thread...</span>
deferredResult.setResult(data);
</code></pre>
<p>控制器可以从不同的线程异步生成返回值 - 例如，响应外部事件（JMS消息），计划任务或其他事件。</p>
<p><a id="mvc-ann-async-callable"></a></p>
<h4><a href="#mvc-ann-async-callable"></a>1.5.2. <code>Callable</code></h4>
<p><a href="#mvc-ann-async-vs-webflux">Compared to WebFlux</a></p>
<p>控制器可以使用 <code>java.util.concurrent.Callable</code>包装任何支持的返回值，如以下示例所示：</p>
<pre><code class="language-java"><span class="hljs-meta">@PostMapping</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> Callable&lt;String&gt; <span class="hljs-title">processUpload</span><span class="hljs-params">(<span class="hljs-keyword">final</span> MultipartFile file)</span> </span>{

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Callable&lt;String&gt;() {
        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{
            <span class="hljs-comment">// ...</span>
            <span class="hljs-keyword">return</span> <span class="hljs-string">"someView"</span>;
        }
    };

}
</code></pre>
<p>然后可以通过配置的<a href="#mvc-ann-async-configuration-spring-mvc">configured</a> <code>TaskExecutor</code>运行给定任务来获取返回值。</p>
<p><a id="mvc-ann-async-processing"></a></p>
<h4><a href="#mvc-ann-async-processing"></a>1.5.3. 处理过程</h4>
<p><a href="#mvc-ann-async-vs-webflux">Compared to WebFlux</a></p>
<p>以下是Servlet异步请求处理的简要概述:</p>
<ul>
<li>
<p>Servlet请求<code>ServletRequest</code>可以通过调用 <code>request.startAsync()</code>方法而进入异步模式。这样做的主要结果就是该Servlet以及所有的过滤器都可以结束，但其响应（response）会留待异步处理结束后再返回调用。</p>
</li>
<li>
<p><code>request.startAsync()</code> 方法会返回一个<code>AsyncContext</code>对象 ，可用它对异步处理进行进一步的控制和操作。比如说它也提供了一个与转向（forward）很相似的<code>dispatch</code>方法，只不过它允许应用恢复Servlet容器的请求处理进程。</p>
</li>
<li>
<p><code>ServletRequest</code> 提供了获取当前<code>DispatcherType</code>的方式，后者可以用来区别当前处理的是原始请求、异步分发请求、转向、或是其他类型的请求分发类型。</p>
</li>
</ul>
<p><code>DeferredResult</code> 处理的工作方式如下：</p>
<ul>
<li>
<p>控制器先返回一个<code>DeferredResult</code>对象，并把它存取在内存（队列或列表等）中以便存取。</p>
</li>
<li>
<p>Spring MVC调用<code>request.startAsync()</code>方法，开始进行异步处理。</p>
</li>
<li>
<p><code>DispatcherServlet</code>和所有过滤器都退出Servlet容器线程，但此时方法的响应对象仍未返回。</p>
</li>
<li>
<p>由处理该请求的线程对<code>DeferredResult</code>进行设值，然后SpringM VC会重新把请求分派回Servlet容器，恢复处理。</p>
</li>
<li>
<p><code>DispatcherServlet</code>再次被调用, 恢复对该异步返回结果的处理。</p>
</li>
</ul>
<p><code>Callable</code>处理的工作方式如下：</p>
<ul>
<li>
<p>控制器先返回一个<code>Callable</code>对象.</p>
</li>
<li>
<p>Spring MVC调用 <code>request.startAsync()</code>方法，开始进行异步处理，并把该<code>Callable</code>对象提交给另一个独立线程的执行器 <code>TaskExecutor</code>处理。</p>
</li>
<li>
<p><code>DispatcherServlet</code>和所有过滤器都退出Servlet容器线程，但此时方法的响应对象仍未返回。</p>
</li>
<li>
<p><code>Callable</code>对象最终产生一个返回结果，此时Spring MVC会重新把请求分派回Servlet容器，恢复处理。</p>
</li>
<li>
<p><code>DispatcherServlet</code>再次被调用,恢复对<code>Callable</code>异步处理所返回结果的处理。</p>
</li>
</ul>
<p>关于引入异步请求处理的背景和原因，以及什么时候使用它，为什么使用异步请求处理等问题。可以阅读这个系列的<a href="https://spring.io/blog/2012/05/07/spring-mvc-3-2-preview-introducing-servlet-3-async-support">博客文章</a> 。</p>
<p><a id="mvc-ann-async-exceptions"></a></p>
<h5><a href="#mvc-ann-async-exceptions"></a>异常处理</h5>
<p>若方法返回的是一个<code>DeferredResult</code>对象，你可以选择调Exception实例的<code>setResult</code>方法还是<code>setErrorResult</code>方法。在这两种情况下，Spring MVC都会将请求发送回Servlet容器以完成处理。 然后将其视为控制器方法返回给定值或者就好像它产生了给定的异常一样。 然后异常通过常规异常处理机制（例如，调用<code>@ExceptionHandler</code>方法）。更具体地说呢，当Callable抛出异常时，Spring MVC会把一个Exception对象分派给Servlet容器进行处理，而不是正常返回方法的返回值，然后容器恢复对此异步请求异常的处理。</p>
<p>当您使用<code>Callable</code>时，会出现类似的处理逻辑，主要区别在于从<code>Callable</code>返回结果，或者由它引发异常。</p>
<p><a id="mvc-ann-async-interception"></a></p>
<h5><a href="#mvc-ann-async-interception"></a>拦截异步请求</h5>
<p>处理器拦截器<code>HandlerInterceptor</code>可以实现<code>AsyncHandlerInterceptor</code>接口拦截异步请求，因为在异步请求开始时，被调用的回调方法是该接口的<code>afterConcurrentHandlingStarted</code>方法，而非一般的<code>postHandle</code>和<code>afterCompletion</code>方法。</p>
<p>如果需要与异步请求处理的生命流程有更深入的集成，比如需要处理timeout的事件等。则<code>HandlerInterceptor</code>需要注册<code>CallableProcessingInterceptor</code>或<code>DeferredResultProcessingInterceptor</code>拦截器， 具体的细节可以参考 <a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/servlet/AsyncHandlerInterceptor.html"><code>AsyncHandlerInterceptor</code></a>类的Java文档</p>
<p><code>DeferredResult</code>类还提供了<code>onTimeout(Runnable)</code> 和 <code>onCompletion(Runnable)</code> 等回调， 具体的细节可以参考<a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/context/request/async/DeferredResult.html"><code>DeferredResult</code></a>类的Java文档 <code>Callable</code>可以替代<code>WebAsyncTask</code>，它公开了超时和完成回调的其他方法。</p>
<p><a id="mvc-ann-async-vs-webflux"></a></p>
<h5><a href="#mvc-ann-async-vs-webflux"></a>Compared to WebFlux</h5>
<p>The Servlet API was originally built for making a single pass through the Filter-Servlet chain. Asynchronous request processing, added in Servlet 3.0, lets applications exit the Filter-Servlet chain but leave the response open for further processing. The Spring MVC asynchronous support is built around that mechanism. When a controller returns a <code>DeferredResult</code>, the Filter-Servlet chain is exited, and the Servlet container thread is released. Later, when the <code>DeferredResult</code> is set, an <code>ASYNC</code> dispatch (to the same URL) is made, during which the controller is mapped again but, rather than invoking it, the <code>DeferredResult</code> value is used (as if the controller returned it) to resume processing.</p>
<p>By contrast, Spring WebFlux is neither built on the Servlet API, nor does it need such an asynchronous request processing feature, because it is asynchronous by design. Asynchronous handling is built into all framework contracts and is intrinsically supported through all stages of request processing.</p>
<p>From a programming model perspective, both Spring MVC and Spring WebFlux support asynchronous and <a href="#mvc-ann-async-reactive-types">Reactive Types</a> as return values in controller methods. Spring MVC even supports streaming, including reactive back pressure. However, individual writes to the response remain blocking (and are performed on a separate thread), unlike WebFlux, which relies on non-blocking I/O and does not need an extra thread for each write.</p>
<p>Another fundamental difference is that Spring MVC does not support asynchronous or reactive types in controller method arguments (for example, <code>@RequestBody</code>, <code>@RequestPart</code>, and others), nor does it have any explicit support for asynchronous and reactive types as model attributes. Spring WebFlux does support all that.</p>
<p><a id="mvc-ann-async-http-streaming"></a></p>
<h4><a href="#mvc-ann-async-http-streaming"></a>1.5.4. HTTP 流</h4>
<p><a href="web-reactive.html#webflux-codecs-streaming">Same as in Spring WebFlux</a></p>
<p>您可以将<code>DeferredResult</code>和<code>Callable</code>用于单个异步返回值。 如果要生成多个异步值并将其写入响应，该怎么办？ 本节介绍如何执行此操作。</p>
<p><a id="mvc-ann-async-objects"></a></p>
<h5><a href="#mvc-ann-async-objects"></a>Objects</h5>
<p>您可以使用<code>ResponseBodyEmitter</code>返回值来生成对象流，其中每个对象都使用 <a href="integration.html#rest-message-conversion"><code>HttpMessageConverter</code></a>进行序列化并写入响应，如以下示例所示：</p>
<pre><code class="language-java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/events"</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> ResponseBodyEmitter <span class="hljs-title">handle</span><span class="hljs-params">()</span> </span>{
    ResponseBodyEmitter emitter = <span class="hljs-keyword">new</span> ResponseBodyEmitter();
    <span class="hljs-comment">// Save the emitter somewhere..</span>
    <span class="hljs-keyword">return</span> emitter;
}

<span class="hljs-comment">// In some other thread</span>
emitter.send(<span class="hljs-string">"Hello once"</span>);

<span class="hljs-comment">// and again later on</span>
emitter.send(<span class="hljs-string">"Hello again"</span>);

<span class="hljs-comment">// and done at some point</span>
emitter.complete();
</code></pre>
<p><code>ResponseBodyEmitter</code>也可以被放到<code>ResponseEntity</code>体里面使用，这可以对响应状态和响应头做一些定制。</p>
<p>当<code>emitter</code> 抛出<code>IOException</code>时（例如，如果远程客户端消失），应用程序不负责清理连接，不应调用<code>emitter.complete</code>或<code>emitter.completeWithError</code>。 相反，servlet容器会自动启动<code>AsyncListener</code> 错误通知，其中Spring MVC进行 <code>completeWithError</code>调用。 反过来，此调用会对应用程序执行一次最终<code>ASYNC</code> 调度，在此期间，Spring MVC将调用已配置的异常解析程序并完成请求。</p>
<p><a id="mvc-ann-async-sse"></a></p>
<h5><a href="#mvc-ann-async-sse"></a>SSE</h5>
<p><code>SseEmitter</code> （<code>ResponseBodyEmitter</code>的子类）为<a href="https://www.w3.org/TR/eventsource/">Server-Sent Events</a>,提供支持，其中从服务器发送的事件根据W3C SSE规范进行格式化。 要从控制器生成SSE流，请返回<code>SseEmitter</code>，如以下示例所示：</p>
<pre><code class="language-java"><span class="hljs-meta">@GetMapping</span>(path=<span class="hljs-string">"/events"</span>, produces=MediaType.TEXT_EVENT_STREAM_VALUE)
<span class="hljs-function"><span class="hljs-keyword">public</span> SseEmitter <span class="hljs-title">handle</span><span class="hljs-params">()</span> </span>{
    SseEmitter emitter = <span class="hljs-keyword">new</span> SseEmitter();
    <span class="hljs-comment">// Save the emitter somewhere..</span>
    <span class="hljs-keyword">return</span> emitter;
}

<span class="hljs-comment">// In some other thread</span>
emitter.send(<span class="hljs-string">"Hello once"</span>);

<span class="hljs-comment">// and again later on</span>
emitter.send(<span class="hljs-string">"Hello again"</span>);

<span class="hljs-comment">// and done at some point</span>
emitter.complete();
</code></pre>
<p>虽然SSE是流式传输到浏览器的主要选项，但请注意Internet Explorer不支持Server-Sent Events。 考虑将Spring的<a href="#websocket">WebSocket messaging</a>传递与针对各种浏览器的 <a href="#websocket-fallback">SockJS fallback</a> 传输（包括SSE）一起使用。</p>
<p>有关异常处理的说明，另请参见<a href="#mvc-ann-async-objects">上一节</a> 。</p>
<p><a id="mvc-ann-async-output-stream"></a></p>
<h5><a href="#mvc-ann-async-output-stream"></a>Raw Data</h5>
<p>有时，跳过消息转换的阶段，直接把数据写回响应的输出流<code>OutputStream</code>可能更有效，比如文件下载这样的场景，这可以通过返回一个<code>StreamingResponseBody</code>类型的对象来实现，如以下示例所示：</p>
<pre><code class="language-java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/download"</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> StreamingResponseBody <span class="hljs-title">handle</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> StreamingResponseBody() {
        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeTo</span><span class="hljs-params">(OutputStream outputStream)</span> <span class="hljs-keyword">throws</span> IOException </span>{
            <span class="hljs-comment">// write...</span>
        }
    };
}
</code></pre>
<p><code>StreamingResponseBody</code>也可以被放到<code>ResponseEntity</code> 体里面使用，这可以对响应状态和响应头做一些定制。</p>
<p><a id="mvc-ann-async-reactive-types"></a></p>
<h4><a href="#mvc-ann-async-reactive-types"></a>1.5.5. Reactive Types（响应式类型）</h4>
<p><a href="web-reactive.html#webflux-codecs-streaming">Same as in Spring WebFlux</a></p>
<p>如果使用<code>spring-webflux</code>中的响应式<code>WebClient</code>，或其他客户端（也可以阅读WebFlux部分中的<a href="web-reactive.html#webflux-reactive-libraries">Reactive Libraries</a>），又或者是带响应式支持的数据存储，开发者可以直接从Spring MVC控制器方法返回响应式类型。 p&gt;</p>
<p>Reactive 返回值的处理方式如下:</p>
<ul>
<li>
<p>如果返回类型有single-value流的语义，如Reactor<code>Mono</code>或RxJava <code>Single</code>，那么它是适配并等效于 <code>DeferredResult</code>。</p>
</li>
<li>
<p>如果返回类型有multi-value流的语义，如Reactor <code>Flux</code>或RxJava <code>Observable</code>，并且如果媒体类型也表示为流，（例如，<code>application/stream+json</code>或<code>text/event-stream</code>）。 则它是适配并等效于使用<code>ResponseBodyEmitter</code>或 <code>SseEmitter</code>。还可以返回<code>Flux&lt;ServerSentEvent&gt;</code>或 <code>Observable&lt;ServerSentEvent&gt;</code>。</p>
</li>
<li>
<p>如果返回类型multi-value流的语义，但媒体类型并不表示为流。例如<code>application/json</code>，则它是适配并等效于使用<code>DeferredResult&lt;List&lt;?&gt;&gt;</code>。</p>
</li>
</ul>
<p>Spring MVC对使用中的响应式库进行了适配 – 例如，预计有多少值，这是在<code>spring-core</code>包的<a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/core/ReactiveAdapterRegistry.html"><code>ReactiveAdapterRegistry</code></a> 的帮助下完成的。 它为响应式和异步类型提供可插拔的支持。注册表内置了对RxJava的支持，但其他可以注册。</p>
<p>对于流式传输到响应，支持响应式响应，但是对响应的写入仍然是阻塞的，并且通过<a href="#mvc-ann-async-configuration-spring-mvc">配置</a> 的<code>TaskExecutor</code>在单独的线程上执行， 以避免阻塞上游源（例如从<code>WebClient</code>返回的<code>Flux</code>）。 默认情况下，<code>SimpleAsyncTaskExecutor</code>用于阻塞写入，但在加载时不适用。 如果计划使用响应类型进行流式处理，则应使用MVC配置来配置任务执行程序。</p>
<p><a id="mvc-ann-async-disconnects"></a></p>
<h4><a href="#mvc-ann-async-disconnects"></a>1.5.6. 断开</h4>
<p><a href="web-reactive.html#webflux-codecs-streaming">Same as in Spring WebFlux</a></p>
<p>当远程客户端消失时，Servlet API不提供任何通知。 因此，在通过stream传输到响应时，无论是通过<a href="#mvc-ann-async-sse">SseEmitter</a>还是&lt;&lt;mvc-ann-async-reactive-types,reactive types&gt;，定期发送数据都很重要， 因为如果客户端断开连接，写入将失败。 发送可以采用空（仅限注解）SSE事件或另一方必须解释为心跳并忽略的任何其他数据的形式。</p>
<p>或者，考虑使用具有内置心跳机制的Web消息传递解决方案（例如基于WebSocket的<a href="#websocket-stomp">STOMP</a>或具有<a href="#websocket-fallback">SockJS</a>的WebSocket）。</p>
<p><a id="mvc-ann-async-configuration"></a></p>
<h4><a href="#mvc-ann-async-configuration"></a>1.5.7. 配置</h4>
<p><a href="#mvc-ann-async-vs-webflux">Compared to WebFlux</a></p>
<p>必须在Servlet容器级别启用异步请求处理功能。 MVC配置还公开了异步请求的几个选项。</p>
<p><a id="mvc-ann-async-configuration-servlet3"></a></p>
<h5><a href="#mvc-ann-async-configuration-servlet3"></a>Servlet 容器</h5>
<p>Filter和Servlet声明具有<code>asyncSupported</code>标志，需要将其设置为<code>true</code>以启用异步请求处理。 此外，应声明Filter映射以处理<code>ASYNC</code> <code>javax.servlet.DispatchType</code>。</p>
<p>在Java配置中，当您使用<code>AbstractAnnotationConfigDispatcherServletInitializer</code>初始化Servlet容器时，这将自动完成。</p>
<p>在<code>web.xml</code> 配置中，您可以将<code>&lt;async-supported&gt;true&lt;/async-supported&gt;</code> 添加到<code>DispatcherServlet</code>和<code>Filter</code>声明，并添加<code>&lt;dispatcher&gt;ASYNC&lt;/dispatcher&gt;</code>以过滤映射。</p>
<p><a id="mvc-ann-async-configuration-spring-mvc"></a></p>
<h5><a href="#mvc-ann-async-configuration-spring-mvc"></a>Spring MVC</h5>
<p>MVC配置公开以下与异步请求处理相关的选项：</p>
<ul>
<li>
<p>Java configuration:在<code>WebMvcConfigurer</code>上使用<code>configureAsyncSupport</code>回调。</p>
</li>
<li>
<p>XML namespace:使用 <code>&lt;mvc:annotation-driven&gt;</code>下的<code>&lt;async-support&gt;</code>元素。</p>
</li>
</ul>
<p>您可以配置以下内容：</p>
<ul>
<li>
<p>异步请求的默认超时值（如果未设置）取决于底层Servlet容器（例如，Tomcat上的10秒）。</p>
</li>
<li>
<p><code>AsyncTaskExecutor</code>用于在使用<a href="#mvc-ann-async-reactive-types">Reactive Types</a>进行流式处理时阻止写入，以及用于执行从控制器方法返回的<code>Callable</code>实例。 如果您使用reactive types进行流式传输或者具有返回<code>Callable</code>的控制器方法， 我们强烈建议您配置此属性，因为默认情况下，它是<code>SimpleAsyncTaskExecutor</code>。</p>
</li>
<li>
<p><code>DeferredResultProcessingInterceptor</code>实现和<code>CallableProcessingInterceptor</code>实现。</p>
</li>
</ul>
<p>请注意，您还可以在<code>DeferredResult</code>， <code>ResponseBodyEmitter</code>和<code>SseEmitter</code>上设置默认超时值。 对于<code>Callable</code>，您可以使用<code>WebAsyncTask</code> 来提供超时值。</p>
<p><a id="mvc-cors"></a></p>
<h3><a href="#mvc-cors"></a>1.6. CORS</h3>
<p><a href="web-reactive.html#webflux-cors">Same as in Spring WebFlux</a></p>
<p>Spring MVC允许您处理CORS（跨源资源共享）。 本节介绍如何执行此操作。</p>
<p><a id="mvc-cors-intro"></a></p>
<h4><a href="#mvc-cors-intro"></a>1.6.1. 简介</h4>
<p><a href="web-reactive.html#webflux-cors-intro">Same as in Spring WebFlux</a></p>
<p>出于安全原因，浏览器禁止对当前源外的资源进行AJAX调用。 例如，您可以将您的银行帐户放在一个标签页中，将evil.com放在另一个标签页中。 来自evil.com的脚本不应该使用您的凭据向您的银行API发出AJAX请求 - 例如从您的帐户中提取资金！</p>
<p>Cross-Origin Resource Sharing (CORS) 是<a href="https://caniuse.com/#feat=cors">大多数浏览器</a> 实现的<a href="https://www.w3.org/TR/cors/">W3C规范</a>，它允许以灵活的方式指定哪些类型的跨域请求被授权， 而不是使用一些安全程度较低、功能较差的实现(如IFRAME或JSONP)。</p>
<p><a id="mvc-cors-processing"></a></p>
<h4><a href="#mvc-cors-processing"></a>1.6.2. 处理</h4>
<p><a href="web-reactive.html#webflux-cors-processing">Same as in Spring WebFlux</a></p>
<p>CORS规范区分了预检查，简单和实际请求。 要了解CORS的工作原理，您可以<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">&gt;阅读本文</a>以及其他许多内容，或者查看规范以获取更多详细信息。</p>
<p>Spring MVC <code>HandlerMapping</code>为实现CORS提供内置支持。成功将请求映射到处理程序后，<code>HandlerMapping</code> 实现检查给定请求和处理程序的CORS配置并采取进一步操作。 直接处理预检查请求，同时拦截，验证简单和实际的CORS请求，并设置所需的CORS响应头。</p>
<p>为了启用跨源请求（即，存在<code>Origin</code>头并且与请求的主机不同），您需要具有一些显式声明的CORS配置。 如果未找到匹配的CORS配置，则拒绝预检请求。 没有CORS头添加到简单和实际CORS请求的响应中，因此浏览器拒绝它们。</p>
<p>可以使用基于URL模式的<code>CorsConfiguration</code>映射单独 <a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/servlet/handler/AbstractHandlerMapping.html#setCorsConfigurations-java.util.Map-">配置</a>每个<code>HandlerMapping</code>。 在大多数情况下，应用程序使用MVC Java配置或XML命名空间来声明此类映射，这会导致将单个全局映射传递给所有<code>HandlerMappping</code> 实例。</p>
<p>您可以将<code>HandlerMapping</code>级别的全局CORS配置与更细粒度的处理程序级CORS配置相结合。 例如，带注解的控制器可以使用类或方法级别的<code>@CrossOrigin</code>注解（其他处理程序可以实现<code>CorsConfigurationSource</code>）。</p>
<p>组合全局和本地配置的规则通常是附加的 - 例如，所有全局和所有本地源。 对于只能接受单个值的属性（例如 <code>allowCredentials</code> 和 <code>maxAge</code>）， 本地会覆盖全局值。 有关详细信息，请参阅 <a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/cors/CorsConfiguration.html#combine-org.springframework.web.cors.CorsConfiguration-"><code>CorsConfiguration#combine(CorsConfiguration)</code></a>。</p>
<p>要从source中了解更多信息或进行高级自定义，请查看后面的代码:</p>
<ul>
<li>
<p><code>CorsConfiguration</code></p>
</li>
<li>
<p><code>CorsProcessor</code>, <code>DefaultCorsProcessor</code></p>
</li>
<li>
<p><code>AbstractHandlerMapping</code></p>
</li>
</ul>
<p><a id="mvc-cors-controller"></a></p>
<h4><a href="#mvc-cors-controller"></a>1.6.3. <code>@CrossOrigin</code></h4>
<p><a href="web-reactive.html#webflux-cors-controller">Same as in Spring WebFlux</a></p>
<p>在带注解的控制器方法上使用<a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/bind/annotation/CrossOrigin.html"><code>@CrossOrigin</code></a>注解启用跨源请求，如以下示例所示：</p>
<pre><code class="language-java"><span class="hljs-meta">@RestController</span>
<span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/account"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountController</span> </span>{

    <span class="hljs-meta">@CrossOrigin</span>
    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/{id}"</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> Account <span class="hljs-title">retrieve</span><span class="hljs-params">(@PathVariable Long id)</span> </span>{
        <span class="hljs-comment">// ...</span>
    }

    <span class="hljs-meta">@DeleteMapping</span>(<span class="hljs-string">"/{id}"</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(@PathVariable Long id)</span> </span>{
        <span class="hljs-comment">// ...</span>
    }
}
</code></pre>
<p>默认情况下，<code>@CrossOrigin</code>允许：</p>
<ul>
<li>
<p>All origins.</p>
</li>
<li>
<p>All headers.</p>
</li>
<li>
<p>All HTTP methods（可以映射到控制器的方法）</p>
</li>
</ul>
<p>默认情况下不启用<code>allowedCredentials</code>，因为它建立了一个信任级别，该信任级别公开敏感的用户特定信息（例如cookie和CSRF令牌），并且只应在适当的地方使用。</p>
<p><code>maxAge</code> 设置为30 分钟.</p>
<p><code>@CrossOrigin</code>在类级别也受支持，并且由所有方法继承，如以下示例所示：</p>
<pre><code class="language-java"><span class="hljs-meta">@CrossOrigin</span>(origins = <span class="hljs-string">"http://domain2.com"</span>, maxAge = <span class="hljs-number">3600</span>)
<span class="hljs-meta">@RestController</span>
<span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/account"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountController</span> </span>{

    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/{id}"</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> Account <span class="hljs-title">retrieve</span><span class="hljs-params">(@PathVariable Long id)</span> </span>{
        <span class="hljs-comment">// ...</span>
    }

    <span class="hljs-meta">@DeleteMapping</span>(<span class="hljs-string">"/{id}"</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(@PathVariable Long id)</span> </span>{
        <span class="hljs-comment">// ...</span>
    }
}
</code></pre>
<p>您可以在类级别和方法级别使用<code>@CrossOrigin</code> ，如以下示例所示:</p>
<pre><code class="language-java"><span class="hljs-meta">@CrossOrigin</span>(maxAge = <span class="hljs-number">3600</span>)
<span class="hljs-meta">@RestController</span>
<span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/account"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountController</span> </span>{

    <span class="hljs-meta">@CrossOrigin</span>(<span class="hljs-string">"http://domain2.com"</span>)
    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/{id}"</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> Account <span class="hljs-title">retrieve</span><span class="hljs-params">(@PathVariable Long id)</span> </span>{
        <span class="hljs-comment">// ...</span>
    }

    <span class="hljs-meta">@DeleteMapping</span>(<span class="hljs-string">"/{id}"</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(@PathVariable Long id)</span> </span>{
        <span class="hljs-comment">// ...</span>
    }
}
</code></pre>
<p><a id="mvc-cors-global"></a></p>
<h4><a href="#mvc-cors-global"></a>1.6.4. 全局配置</h4>
<p><a href="web-reactive.html#webflux-cors-global">Same as in Spring WebFlux</a></p>
<p>除了细粒度，基于注解的配置以外，您可能还希望定义一些全局CORS配置。您可以在任何<code>HandlerMapping</code>上单独设置基于URL的 <code>CorsConfiguration</code>映射。 但是，大多数应用程序使用MVC Java配置或MVC XNM命名空间来执行此操作。</p>
<p>默认情况下，全局配置启用以下内容：</p>
<ul>
<li>
<p>All origins.</p>
</li>
<li>
<p>All headers.</p>
</li>
<li>
<p><code>GET</code>, <code>HEAD</code>, and <code>POST</code> methods.</p>
</li>
</ul>
<p>默认情况下不启用<code>allowedCredentials</code>，因为它建立了一个信任级别，该信任级别公开敏感的用户特定信息（例如cookie和CSRF令牌），并且只应在适当的地方使用。</p>
<p><code>maxAge</code> 设置为30分钟.</p>
<p><a id="mvc-cors-global-java"></a></p>
<h5><a href="#mvc-cors-global-java"></a>Java 配置</h5>
<p><a href="web-reactive.html#webflux-cors-global">Same as in Spring WebFlux</a></p>
<p>要在MVC Java配置中启用CORS，可以使用<code>CorsRegistry</code>回调，如以下示例所示:</p>
<pre><code class="language-java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@EnableWebMvc</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>{

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addCorsMappings</span><span class="hljs-params">(CorsRegistry registry)</span> </span>{

        registry.addMapping(<span class="hljs-string">"/api/**"</span>)
            .allowedOrigins(<span class="hljs-string">"http://domain2.com"</span>)
            .allowedMethods(<span class="hljs-string">"PUT"</span>, <span class="hljs-string">"DELETE"</span>)
            .allowedHeaders(<span class="hljs-string">"header1"</span>, <span class="hljs-string">"header2"</span>, <span class="hljs-string">"header3"</span>)
            .exposedHeaders(<span class="hljs-string">"header1"</span>, <span class="hljs-string">"header2"</span>)
            .allowCredentials(<span class="hljs-keyword">true</span>).maxAge(<span class="hljs-number">3600</span>);

        <span class="hljs-comment">// Add more mappings...</span>
    }
}
</code></pre>
<p><a id="mvc-cors-global-xml"></a></p>
<h5><a href="#mvc-cors-global-xml"></a>XML 配置</h5>
<p>要在XML命名空间中启用CORS，可以使用<code>&lt;mvc:cors&gt;</code>元素，如以下示例所示:</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:cors</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/api/**"</span>
        <span class="hljs-attr">allowed-origins</span>=<span class="hljs-string">"http://domain1.com, http://domain2.com"</span>
        <span class="hljs-attr">allowed-methods</span>=<span class="hljs-string">"GET, PUT"</span>
        <span class="hljs-attr">allowed-headers</span>=<span class="hljs-string">"header1, header2, header3"</span>
        <span class="hljs-attr">exposed-headers</span>=<span class="hljs-string">"header1, header2"</span> <span class="hljs-attr">allow-credentials</span>=<span class="hljs-string">"true"</span>
        <span class="hljs-attr">max-age</span>=<span class="hljs-string">"123"</span> /&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/resources/**"</span>
        <span class="hljs-attr">allowed-origins</span>=<span class="hljs-string">"http://domain1.com"</span> /&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">mvc:cors</span>&gt;</span>
</code></pre>
<p><a id="mvc-cors-filter"></a></p>
<h4><a href="#mvc-cors-filter"></a>1.6.5. CORS 过滤器</h4>
<p><a href="web-reactive.html#webflux-cors-webfilter">Same as in Spring WebFlux</a></p>
<p>您可以通过内置的 <a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/filter/CorsFilter.html"><code>CorsFilter</code></a>应用CORS支持。</p>
<p>如果您尝试将<code>CorsFilter</code> 与Spring Security一起使用，请记住Spring Security<a href="https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#cors">内置了对CORS的支持</a>。</p>
<p>要配置过滤器，请将<code>CorsConfigurationSource</code>传递给其构造函数，如以下示例所示:</p>
<pre><code class="language-java">CorsConfiguration config = <span class="hljs-keyword">new</span> CorsConfiguration();

<span class="hljs-comment">// Possibly...</span>
<span class="hljs-comment">// config.applyPermitDefaultValues()</span>

config.setAllowCredentials(<span class="hljs-keyword">true</span>);
config.addAllowedOrigin(<span class="hljs-string">"http://domain1.com"</span>);
config.addAllowedHeader(<span class="hljs-string">"*"</span>);
config.addAllowedMethod(<span class="hljs-string">"*"</span>);

UrlBasedCorsConfigurationSource source = <span class="hljs-keyword">new</span> UrlBasedCorsConfigurationSource();
source.registerCorsConfiguration(<span class="hljs-string">"/**"</span>, config);

CorsFilter filter = <span class="hljs-keyword">new</span> CorsFilter(source);
</code></pre>
<p><a id="mvc-web-security"></a></p>
<h3><a href="#mvc-web-security"></a>1.7. Web 安全</h3>
<p><a href="web-reactive.html#webflux-web-security">Same as in Spring WebFlux</a></p>
<p>Spring Security项目为保护Web应用程序免受恶意攻击提供支持。 请参阅<a href="https://projects.spring.io/spring-security/">Spring Security</a>参考文档，包括：</p>
<ul>
<li>
<p><a href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/#mvc">Spring MVC Security</a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/#test-mockmvc">Spring MVC Test Support</a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/#csrf">CSRF protection</a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/#headers">Security Response Headers</a></p>
</li>
</ul>
<p><a href="http://hdiv.org/">HDIV</a> 是另一个与Spring MVC集成的Web安全框架。</p>
<p><a id="mvc-caching"></a></p>
<h3><a href="#mvc-caching"></a>1.8. HTTP 缓存</h3>
<p><a href="web-reactive.html#webflux-caching">Same as in Spring WebFlux</a></p>
<p>HTTP缓存可以显着提高Web应用程序的性能。HTTP缓存围绕 <code>Cache-Control</code> 响应头，随后是条件请求头（例如<code>Last-Modified</code>和<code>ETag</code>）。 HTTP的响应头<code>Cache-Control</code>主要帮助私有缓存（比如浏览器端缓存）和公共缓存（比如代理端缓存）了解它们应该如果缓存HTTP响应。如果内容未更改，则<code>ETag</code>头用于生成条件请求， 该条件请求可能导致304（NOT_MODIFIED）没有正文。可以认为它是<code>Last-Modified</code>头的一个更精细的后续版本。</p>
<p>本节介绍Spring Web MVC中可用的与HTTP缓存相关的选项。</p>
<p><a id="mvc-caching-cachecontrol"></a></p>
<h4><a href="#mvc-caching-cachecontrol"></a>1.8.1. <code>CacheControl</code></h4>
<p><a href="web-reactive.html#webflux-caching-cachecontrol">Same as in Spring WebFlux</a></p>
<p><a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/http/CacheControl.html"><code>CacheControl</code></a>支持配置与<code>Cache-Control</code>标头相关的设置，并在许多地方被接受为参数：</p>
<ul>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/servlet/mvc/WebContentInterceptor.html"><code>WebContentInterceptor</code></a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/servlet/support/WebContentGenerator.html"><code>WebContentGenerator</code></a></p>
</li>
<li>
<p><a href="#mvc-caching-etag-lastmodified">Controllers</a></p>
</li>
<li>
<p><a href="#mvc-caching-static-resources">Static Resources</a></p>
</li>
</ul>
<p>虽然<a href="https://tools.ietf.org/html/rfc7234#section-5.2.2">RFC 7234</a>描述了<code>Cache-Control</code>响应头的所有可能的指令，但<code>CacheControl</code>类型采用面向用例的方法，该方法侧重于常见场景：</p>
<pre><code class="language-java"><span class="hljs-comment">// Cache for an hour - "Cache-Control: max-age=3600"</span>
CacheControl ccCacheOneHour = CacheControl.maxAge(<span class="hljs-number">1</span>, TimeUnit.HOURS);

<span class="hljs-comment">// Prevent caching - "Cache-Control: no-store"</span>
CacheControl ccNoStore = CacheControl.noStore();

<span class="hljs-comment">// Cache for ten days in public and private caches,</span>
<span class="hljs-comment">// public caches should not transform the response</span>
<span class="hljs-comment">// "Cache-Control: max-age=864000, public, no-transform"</span>
CacheControl ccCustom = CacheControl.maxAge(<span class="hljs-number">10</span>, TimeUnit.DAYS).noTransform().cachePublic();
</code></pre>
<p><code>WebContentGenerator</code>还接受一个更简单的<code>cachePeriod</code>属性（以秒为单位定义），其工作方式如下：</p>
<ul>
<li>
<p>A <code>-1</code> 值不会生成<code>Cache-Control</code> 的响应头。</p>
</li>
<li>
<p>A <code>0</code>值将防止缓存使用<code>'Cache-Control: no-store'</code> 指令.</p>
</li>
<li>
<p>An <code>n &gt; 0</code> 一个大于0的值将缓存给定的响应在<code>n</code>秒使用<code>'Cache-Control: max-age=n'</code></p>
</li>
</ul>
<p><a id="mvc-caching-etag-lastmodified"></a></p>
<h4><a href="#mvc-caching-etag-lastmodified"></a>1.8.2. Controllers</h4>
<p><a href="web-reactive.html#webflux-caching-etag-lastmodified">Same as in Spring WebFlux</a></p>
<p>控制器可以添加对HTTP缓存的显式支持。 我们建议这样做，因为资源的<code>lastModified</code>或<code>ETag</code>值需要先计算才能与条件请求头进行比较。 控制器可以向<code>ResponseEntity</code>添加<code>ETag</code>头和<code>Cache-Control</code>设置，如以下示例所示：</p>
<pre><code class="language-java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/book/{id}"</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity&lt;Book&gt; <span class="hljs-title">showBook</span><span class="hljs-params">(@PathVariable Long id)</span> </span>{

    Book book = findBook(id);
    String version = book.getVersion();

    <span class="hljs-keyword">return</span> ResponseEntity
            .ok()
            .cacheControl(CacheControl.maxAge(<span class="hljs-number">30</span>, TimeUnit.DAYS))
            .eTag(version) <span class="hljs-comment">// lastModified is also available</span>
            .body(book);
}
</code></pre>
<p>如果与条件请求头的比较表明内容未更改，则前面的示例发送带有空响应体的304（NOT_MODIFIED）响应。 否则，<code>ETag</code> 和<code>Cache-Control</code>标头将添加到响应中。</p>
<p>您还可以对控制器中的条件请求头进行检查，如以下示例所示：</p>
<pre><code class="language-java"><span class="hljs-meta">@RequestMapping</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">myHandleMethod</span><span class="hljs-params">(WebRequest webRequest, Model model)</span> </span>{

    <span class="hljs-keyword">long</span> eTag = ... (<span class="hljs-number">1</span>)

    <span class="hljs-keyword">if</span> (request.checkNotModified(eTag)) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>; (<span class="hljs-number">2</span>)
    }

    model.addAttribute(...); (<span class="hljs-number">3</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-string">"myViewName"</span>;
}
</code></pre>
<p><strong>1</strong>、特定于应用的计算。</p>
<p><strong>2</strong>、响应已设置为304（NOT_MODIFIED） - 无需进一步处理。</p>
<p><strong>3</strong>、继续请求处理。</p>
<p>有三种变体可用于检查针对<code>eTag</code>值，<code>lastModified</code>值或两者的条件请求。 对于条件<code>GET</code>和<code>HEAD</code>请求， 您可以将响应设置为304（NOT_MODIFIED）。对于<code>POST</code>, <code>PUT</code>, and <code>DELETE</code>，您可以将响应设置为409（PRECONDITION_FAILED），以防止并发修改。</p>
<p><a id="mvc-caching-static-resources"></a></p>
<h4><a href="#mvc-caching-static-resources"></a>1.8.3. 静态资源</h4>
<p><a href="web-reactive.html#webflux-caching-static-resources">Same as in Spring WebFlux</a></p>
<p>您应该使用<code>Cache-Control</code> 和条件响应头来提供静态资源，以获得最佳性能。 请参阅有关配置<a href="#mvc-config-static-resources">静态资源</a>的部分。</p>
<p><a id="mvc-httpcaching-shallowetag"></a></p>
<h4><a href="#mvc-httpcaching-shallowetag"></a>1.8.4. <code>ETag</code> 过滤器</h4>
<p>您可以使用<code>ShallowEtagHeaderFilter</code>添加从响应内容计算的“shallow” eTag值，从而节省带宽但不节省CPU时间。 见 <a href="#filters-shallow-etag">Shallow ETag</a>。</p>
<p><a id="mvc-view"></a></p>
<h3><a href="#mvc-view"></a>1.9. 视图技术</h3>
<p><a href="web-reactive.html#webflux-view">Same as in Spring WebFlux</a></p>
<p>无论您决定使用Thymeleaf，Groovy标记模板，JSP还是其他技术，Spring MVC中视图技术的使用都是可插拔的， 主要是配置更改的问题。 本章介绍了与Spring MVC集成的视图技术。 我们假设您已经熟悉<a href="#mvc-viewresolver">解析视图</a>。</p>
<p><a id="mvc-view-thymeleaf"></a></p>
<h4><a href="#mvc-view-thymeleaf"></a>1.9.1. Thymeleaf</h4>
<p><a href="web-reactive.html#webflux-view-thymeleaf">Same as in Spring WebFlux</a></p>
<p>Thymeleaf是一个现代服务器端Java模板引擎，它强调可以通过双击在浏览器中预览的自然HTML模板，这对于UI模板的独立工作（例如，由设计人员）非常有用，而无需运行服务器。 如果您想要替换JSP，Thymeleaf提供了一组最广泛的功能，使这种转换更容易。 Thymeleaf积极开发和维护。 有关更完整的介绍，请参阅<a href="http://www.thymeleaf.org/">Thymeleaf</a>项目主页。</p>
<p>Thymeleaf与Spring MVC的集成由Thymeleaf项目管理。 配置涉及一些bean声明， 例如<code>ServletContextTemplateResolver</code>, <code>SpringTemplateEngine</code>, 和 <code>ThymeleafViewResolver</code>.。 有关详细信息，请参阅<a href="http://www.thymeleaf.org/documentation.html">Thymeleaf+Spring</a>。</p>
<p><a id="mvc-view-freemarker"></a></p>
<h4><a href="#mvc-view-freemarker"></a>1.9.2. FreeMarker</h4>
<p><a href="web-reactive.html#webflux-view-freemarker">Same as in Spring WebFlux</a></p>
<p><a href="http://www.freemarker.org">Apache FreeMarker</a> 是一个模板引擎，用于生成从HTML到电子邮件和其他的任何类型的文本输出。 Spring Framework有一个内置的集成，可以将Spring MVC与FreeMarker模板结合使用。</p>
<p><a id="mvc-view-freemarker-contextconfig"></a></p>
<h5><a href="#mvc-view-freemarker-contextconfig"></a>视图配置</h5>
<p><a href="web-reactive.html#webflux-view-freemarker-contextconfig">Same as in Spring WebFlux</a></p>
<p>以下示例显示如何将FreeMarker配置为视图技术：</p>
<pre><code class="language-java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@EnableWebMvc</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>{

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configureViewResolvers</span><span class="hljs-params">(ViewResolverRegistry registry)</span> </span>{
        registry.freemarker();
    }

    <span class="hljs-comment">// Configure FreeMarker...</span>

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> FreeMarkerConfigurer <span class="hljs-title">freeMarkerConfigurer</span><span class="hljs-params">()</span> </span>{
        FreeMarkerConfigurer configurer = <span class="hljs-keyword">new</span> FreeMarkerConfigurer();
        configurer.setTemplateLoaderPath(<span class="hljs-string">"/WEB-INF/freemarker"</span>);
        <span class="hljs-keyword">return</span> configurer;
    }
}
</code></pre>
<p>以下示例显示如何在XML中配置相同的内容：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>/&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">mvc:view-resolvers</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:freemarker</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mvc:view-resolvers</span>&gt;</span>

<span class="hljs-comment">&lt;!-- Configure FreeMarker... --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mvc:freemarker-configurer</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:template-loader-path</span> <span class="hljs-attr">location</span>=<span class="hljs-string">"/WEB-INF/freemarker"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mvc:freemarker-configurer</span>&gt;</span>
</code></pre>
<p>或者，您也可以声明<code>FreeMarkerConfigurer</code> bean以完全控制所有属性，如以下示例所示：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"freemarkerConfig"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"templateLoaderPath"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"/WEB-INF/freemarker/"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>
</code></pre>
<p>模板需要存储在上面所示的FreeMarkerConfigurer指定的目录中，根据前面的配置，如果您的控制器返回<code>welcome</code>视图名称，解析器将查找<code>/WEB-INF/freemarker/welcome.ftl</code>模板。</p>
<p><a id="mvc-views-freemarker"></a></p>
<h5><a href="#mvc-views-freemarker"></a>FreeMarker 配置</h5>
<p><a href="web-reactive.html#webflux-views-freemarker">Same as in Spring WebFlux</a></p>
<p>通过设置<code>FreeMarkerConfigurer</code> bean可以将FreeMarker的'Settings' 和 'SharedVariables' 值直接传递Spring管理的FreeMarker对象。 <code>freemarkerSettings</code>属性需要<code>java.util.Properties</code>对象。 而<code>freemarkerVariables</code>属性需要<code>java.util.Map</code>。以下示例显示了如何执行此操作：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"freemarkerConfig"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"templateLoaderPath"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"/WEB-INF/freemarker/"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"freemarkerVariables"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">map</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"xml_escape"</span> <span class="hljs-attr">value-ref</span>=<span class="hljs-string">"fmXmlEscape"</span>/&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"fmXmlEscape"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"freemarker.template.utility.XmlEscape"</span>/&gt;</span>
</code></pre>
<p>有关更多的Configuration内容的<code>设置</code>和变量可以查看FreeMarker文档</p>
<p><a id="mvc-view-freemarker-forms"></a></p>
<h5><a href="#mvc-view-freemarker-forms"></a>表单处理</h5>
<p>Spring本身提供了用于JSP的标签库，其中包含（当然还有很多）<code>&lt;spring:bind/&gt;</code>标签，这个标签用来展示从Web上的<code>验证器</code>或业务层抛出的失败验证表单。 Spring还支持FreeMarker中的相同功能，并提供了方便的宏来生成表单输入元素。</p>
<p><a id="mvc-view-bind-macros"></a></p>
<h6><a href="#mvc-view-bind-macros"></a>绑定宏命令</h6>
<p><code>spring-webmvc.jar</code> 包文件包含Velocity和FreeMarker的一组标准宏，因此两者都适用。</p>
<p>Spring库中定义的某些宏被认为是内部的(私有的），但在宏定义中不存在这样的范围，其实所有宏都可以在调用代码和用户模板时看到。以下各节仅集中于需要从模板中直接调用的宏， 如果希望直接查看宏代码， 那么可以看文件<code>spring.ftl</code>，定义在<code>org.springframework.web.servlet.view.freemarker</code>包中。</p>
<p><a id="mvc-view-simple-binding"></a></p>
<h6><a href="#mvc-view-simple-binding"></a>简单的绑定</h6>
<p>HTML表单(vm或ftl模板),充当了Spring MVC控制器的表单视图,可以使用类似下面的代码绑定字段值,也可以类似JSP那样在每个输入字段后面添加错误信息. 以下示例显示了之前配置的personForm视图：</p>
<pre><code class="language-html"><span class="hljs-comment">&lt;!-- freemarker macros have to be imported into a namespace. We strongly
recommend sticking to 'spring' --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">#import</span> "/<span class="hljs-attr">spring.ftl</span>" <span class="hljs-attr">as</span> <span class="hljs-attr">spring</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
    ...
    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">""</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"POST"</span>&gt;</span>
        Name:
        <span class="hljs-tag">&lt;<span class="hljs-name">@spring.bind</span> "<span class="hljs-attr">myModelObject.name</span>"/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span>
            <span class="hljs-attr">name</span>=<span class="hljs-string">"${spring.status.expression}"</span>
            <span class="hljs-attr">value</span>=<span class="hljs-string">"${spring.status.value?html}"</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">#list</span> <span class="hljs-attr">spring.status.errorMessages</span> <span class="hljs-attr">as</span> <span class="hljs-attr">error</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>${error}<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">#list</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>
        ...
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"submit"</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
    ...
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<p><code>&lt;@spring.bind&gt;</code>需要一个包含命令对象的 'path' 参数（默认是'command',除非在<code>FormController</code>属性中被改变了），后面跟着写需要绑定到命令对象上的字段名. 可以使用嵌套字段,例如 <code>command.address.street</code>,绑定宏可以在<code>web.xml</code>中设置ServletContext的参数<code>defaultHtmlEscape</code>，用于定义HTML的转义行为。</p>
<p><code>&lt;@spring.bindEscaped&gt;</code> 宏命令是可选的，它接收第二个参数并显式地指定是否应在状态错误消息或值中使用HTML转义。按需设置为<code>true</code>或<code>false</code>，还有很多其它的宏，它们将在下一节中介绍。</p>
<p><a id="mvc-views-form-macros"></a></p>
<h6><a href="#mvc-views-form-macros"></a>输入宏命令</h6>
<p>Velocity和FreeMarker都使用宏简化了绑定和表单的生成（包括验证错误的显示），没有必要使用这些宏来生成表单输入字段，实际上他们都可以直接绑定在简单的HTML中，并且可混合使用。</p>
<p>下表中的可用宏显示了FTL定义和每个参数列表：</p>
<p>Table 6. 宏命令定义表</p>
<table>
<thead>
<tr>
<th>宏命令</th>
<th>FTL 定义表</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>message</code>（根据代码参数从资源包中输出字符串）</td>
<td>&lt;@spring.message code/&gt;</td>
</tr>
<tr>
<td><code>messageText</code> （根据代码参数从资源包中输出一个字符串，失败则使用默认参数的值）</td>
<td>&lt;@spring.messageText code, text/&gt;</td>
</tr>
<tr>
<td><code>url</code>（使用应用程序的上下文根作为相对URL的前缀）</td>
<td>&lt;@spring.url relativeUrl/&gt;</td>
</tr>
<tr>
<td><code>formInput</code> (标准输入域用户收集用户信息)</td>
<td>&lt;@spring.formInput path, attributes, fieldType/&gt;</td>
</tr>
<tr>
<td><code>formHiddenInput</code> (用于提交肥输入域的隐藏字段)</td>
<td>&lt;@spring.formHiddenInput path, attributes/&gt;</td>
</tr>
<tr>
<td><code>formPasswordInput</code> (用户收集密码的标准输入字段，请注意，此类型的字段中不会填充任何值)</td>
<td>&lt;@spring.formPasswordInput path, attributes/&gt;</td>
</tr>
<tr>
<td><code>formTextarea</code> (大文本域，用于收集大而自由的文本输入)</td>
<td>&lt;@spring.formTextarea path, attributes/&gt;</td>
</tr>
<tr>
<td><code>formSingleSelect</code> (下拉选项框，可以选择一个必需的值)</td>
<td>&lt;@spring.formSingleSelect path, options, attributes/&gt;</td>
</tr>
<tr>
<td><code>formMultiSelect</code> (一个选项列表框，允许用户选择0或更多值)</td>
<td>&lt;@spring.formMultiSelect path, options, attributes/&gt;</td>
</tr>
<tr>
<td><code>formRadioButtons</code> (单选按钮，可以从可用选项中进行单个选择)</td>
<td>&lt;@spring.formRadioButtons path, options separator, attributes/&gt;</td>
</tr>
<tr>
<td><code>formCheckboxes</code> (一组允许选择0或更多值的复选框)</td>
<td>&lt;@spring.formCheckboxes path, options, separator, attributes/&gt;</td>
</tr>
<tr>
<td><code>formCheckbox</code> (单个复选框)</td>
<td>&lt;@spring.formCheckbox path, attributes/&gt;</td>
</tr>
<tr>
<td><code>showErrors</code> (简化绑定字段的验证错误显示)</td>
<td>&lt;@spring.showErrors separator, classOrStyle/&gt;</td>
</tr>
</tbody>
</table>
<ul>
<li>在FTL（FreeMarker）中, <code>formHiddenInput</code> 和 <code>formPasswordInput</code> 这两个宏实际上并不需要，因为可以使用普通的 <code>formInput</code>宏。将<code>hidden</code> 或 <code>password</code>指定为<code>fieldType</code> 参数的值</li>
</ul>
<p>上述任何宏的参数都具有一致的含义</p>
<ul>
<li>
<p><code>路径</code>: 要绑定到的字段的名称（例如 &quot;<a href="http://command.name">command.name</a>&quot;）</p>
</li>
<li>
<p><code>选项</code>: 可从输入字段中选择的所有可用值的映射，map的键表示从表单POST后得到的对象的值（已绑定的），Map对象保存这些键用于返回值后能在表单上显示出来。 通常这样map由控制器提供数据，任何map都可以实现按需使用，可以使用<code>SortedMap</code>，例如 <code>TreeMap</code>和适当的<code>Comparator</code>为所有的值排序，使用来自<code>commons-collections</code>包中的 <code>LinkedHashMap</code> 或 <code>LinkedMap</code>也是相同的原理。</p>
</li>
<li>
<p><code>分隔符</code>:多个选项可以作为元素（单选按钮或复选框）可以使用标签对字符序列进行分隔（例如<code>&lt;br&gt;</code>）。</p>
</li>
<li>
<p><code>属性</code>: HTML标签本身中可以包含任意标签或文本的附加字符串。字符串与上面的宏分别对应，例如，在一个文本字段提供属性'rows=&quot;5&quot; cols=&quot;60&quot;'字段， 也可以添加css，例如'style=&quot;border:1px solid silver&quot;'。</p>
</li>
<li>
<p><code>classOrStyle</code>: 对于<code>showErrors</code> 宏, 可以使用<code>span</code>标签包装每个错误的CSS类的名称。如果未提供任何信息 (或该值为空），则错误将包含在<code>&lt;b&gt;&lt;/b&gt;</code> 标签中</p>
</li>
</ul>
<p>以下部分概述了宏的示例（一些在FTL中，一些在VTL中）。 如果两种语言之间存在使用差异，则会在说明中对其进行说明。</p>
<p><a id="mvc-views-form-macros-input"></a></p>
<p><a href="#mvc-views-form-macros-input"></a>输入域</p>
<p><code>formInput</code>宏采用 <code>path</code> 参数（<code>command.name</code>）和附加属性参数（在下一个示例中为空）。宏与所有其他表单生成宏一起在path参数上执行隐式Spring绑定。在出现新绑定之前， 前一个绑定仍然有效，因此<code>showErrors</code> 宏不需要再次传递path参数，它只对上次为其创建绑定的任何字段进行操作。</p>
<p><code>showErrors</code>宏采用分隔符参数(将用于分隔给定字段上的多个错误的字符，同时还接受第二个参数：类名或样式属性。请注意，FreeMarker能够为属性参数指定默认值，这与Velocity不同， 以下示例显示如何使用 <code>formInput</code>和 <code>showWErrors</code>宏：：</p>
<pre><code>&lt;@spring.formInput &quot;command.name&quot;/&gt;
&lt;@spring.showErrors &quot;&lt;br&gt;&quot;/&gt;
</code></pre>
<p>下一个示例显示表单片段的输出，生成名称字段并在提交表单后在字段中没有值时显示验证错误。 验证通过Spring的验证框架进行。</p>
<p>生成的HTML类似于以下示例：</p>
<pre><code class="language-html">Name:
<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">""</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>required<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>
</code></pre>
<p><code>formTextarea</code> 宏类似于<code>formInput</code>宏，连接收的参数都是相同的。通常，第二个参数（属性）将被使用用于传递格式信息或<code>rows</code>和<code>cols</code> 的属性。</p>
<p><a id="mvc-views-form-macros-select"></a></p>
<p><a href="#mvc-views-form-macros-select"></a>选择字段</p>
<p>有四个字段宏可以用于生产HTML表单中的公共UI值作为选择的输入：</p>
<ul>
<li>
<p><code>formSingleSelect</code></p>
</li>
<li>
<p><code>formMultiSelect</code></p>
</li>
<li>
<p><code>formRadioButtons</code></p>
</li>
<li>
<p><code>formCheckboxes</code></p>
</li>
</ul>
<p>这四个宏都可以从表单字段中接收<code>Map</code>，其实需要的就是标签的值。当然值和标签是可以取相同的名。</p>
<p>下一个例子是FTL中的单选按钮。表单使用'London'作为这个字段的默认值，因此不需用进行验证。当渲染表单时，要选择的整个城市列表都在'cityMap'中，cityMap是数据模型。以下清单显示了该示例：</p>
<pre><code>...
Town:
&lt;@spring.formRadioButtons &quot;command.address.town&quot;, cityMap, &quot;&quot;/&gt;&lt;br&gt;&lt;br&gt;
</code></pre>
<p>前面的列表呈现一行单选按钮，一个用于<code>cityMap</code>中的每个值，并使用分隔符<code>&quot;&quot;</code>。没有提供其他属性（缺少宏的最后一个参数）。cityMap对Map中的每个键值对使用相同的<code>String</code>。 映射的键是表单实际提交为POSTed请求参数的键。 map值是用户看到的标签。 在前面的示例中，给定一个包含三个众所周知的城市的列表以及表单支持对象中的默认值，HTML类似于以下内容：</p>
<pre><code class="language-html">Town:
<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"radio"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"address.town"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"London"</span>&gt;</span>London<span class="hljs-tag">&lt;/<span class="hljs-name">input</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"radio"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"address.town"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Paris"</span> <span class="hljs-attr">checked</span>=<span class="hljs-string">"checked"</span>&gt;</span>Paris<span class="hljs-tag">&lt;/<span class="hljs-name">input</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"radio"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"address.town"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"New York"</span>&gt;</span>New York<span class="hljs-tag">&lt;/<span class="hljs-name">input</span>&gt;</span>
</code></pre>
<p>如果您的应用程序希望通过内部代码来处理城市，可以写一个name为cityMap的Map传递给模板，如下面的例子：</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Map&lt;String, String&gt; <span class="hljs-title">referenceData</span><span class="hljs-params">(HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> Exception </span>{
    Map&lt;String, String&gt; cityMap = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;();
    cityMap.put(<span class="hljs-string">"LDN"</span>, <span class="hljs-string">"London"</span>);
    cityMap.put(<span class="hljs-string">"PRS"</span>, <span class="hljs-string">"Paris"</span>);
    cityMap.put(<span class="hljs-string">"NYC"</span>, <span class="hljs-string">"New York"</span>);

    Map&lt;String, String&gt; model = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
    model.put(<span class="hljs-string">"cityMap"</span>, cityMap);
    <span class="hljs-keyword">return</span> model;
}
</code></pre>
<p>代码将按你的设置输出，可以看到更多的城市名字。</p>
<pre><code class="language-html">Town:
<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"radio"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"address.town"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"LDN"</span>&gt;</span>London<span class="hljs-tag">&lt;/<span class="hljs-name">input</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"radio"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"address.town"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"PRS"</span> <span class="hljs-attr">checked</span>=<span class="hljs-string">"checked"</span>&gt;</span>Paris<span class="hljs-tag">&lt;/<span class="hljs-name">input</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"radio"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"address.town"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"NYC"</span>&gt;</span>New York<span class="hljs-tag">&lt;/<span class="hljs-name">input</span>&gt;</span>
</code></pre>
<p><a id="mvc-views-form-macros-html-escaping"></a></p>
<h6><a href="#mvc-views-form-macros-html-escaping"></a>HTML 转义</h6>
<p>由于HTML的版本问题，上面的表单宏在HTML的4.01版本中需要使用到转义，转义可以在<code>web.xml</code>中通过Spring的绑定来定义。为了使标签遵守XHTML的规定以及覆盖默认的HTML转义值， 可以在模板中定义两个变量（或者使你的模型设置为模板可见形式）。在模板中指定的优点是：它们可以在模板处理后更改为不同的值，以便为表单中的不同字段提供不同的行为。</p>
<p>要切换为标记的XHTML合规性，请为名为<code>xhtmlCompliant</code>的模型或上下文变量指定值<code>true</code> ，如以下示例所示：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">#--</span> <span class="hljs-attr">for</span> <span class="hljs-attr">FreeMarker</span> <span class="hljs-attr">--</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">#assign</span> <span class="hljs-attr">xhtmlCompliant</span> = <span class="hljs-string">true</span>&gt;</span>
</code></pre>
<p>处理完该指令后，Spring宏生成的任何元素现在都符合XHTML标准。</p>
<p>以类似的方式，您可以指定每个字段的HTML转义，如以下示例所示：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">#--</span> <span class="hljs-attr">until</span> <span class="hljs-attr">this</span> <span class="hljs-attr">point</span>, <span class="hljs-attr">default</span> <span class="hljs-attr">HTML</span> <span class="hljs-attr">escaping</span> <span class="hljs-attr">is</span> <span class="hljs-attr">used</span> <span class="hljs-attr">--</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">#assign</span> <span class="hljs-attr">htmlEscape</span> = <span class="hljs-string">true</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">#--</span> <span class="hljs-attr">next</span> <span class="hljs-attr">field</span> <span class="hljs-attr">will</span> <span class="hljs-attr">use</span> <span class="hljs-attr">HTML</span> <span class="hljs-attr">escaping</span> <span class="hljs-attr">--</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">@spring.formInput</span> "<span class="hljs-attr">command.name</span>"/&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">#assign</span> <span class="hljs-attr">htmlEscape</span> = <span class="hljs-string">false</span> <span class="hljs-attr">in</span> <span class="hljs-attr">spring</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">#--</span> <span class="hljs-attr">all</span> <span class="hljs-attr">future</span> <span class="hljs-attr">fields</span> <span class="hljs-attr">will</span> <span class="hljs-attr">be</span> <span class="hljs-attr">bound</span> <span class="hljs-attr">with</span> <span class="hljs-attr">HTML</span> <span class="hljs-attr">escaping</span> <span class="hljs-attr">off</span> <span class="hljs-attr">--</span>&gt;</span>
</code></pre>
<p><a id="mvc-view-groovymarkup"></a></p>
<h4><a href="#mvc-view-groovymarkup"></a>1.9.3. Groovy Markup</h4>
<p><a href="http://groovy-lang.org/templating.html#_the_markuptemplateengine">Groovy标记模板引擎</a>主要用于生成类似XML的标记（XML，XHTML，HTML5等），但您可以使用它来生成任何基于文本的内容。 Spring Framework有一个内置的集成，可以将Spring MVC与Groovy Markup结合使用。</p>
<p>目前要求使用Groovy 2.3.1+的版本.</p>
<p><a id="mvc-view-groovymarkup-configuration"></a></p>
<h5><a href="#mvc-view-groovymarkup-configuration"></a>配置</h5>
<p>以下示例显示如何配置Groovy标记模板引擎：</p>
<pre><code class="language-java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@EnableWebMvc</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>{

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configureViewResolvers</span><span class="hljs-params">(ViewResolverRegistry registry)</span> </span>{
        registry.groovy();
    }

    <span class="hljs-comment">// Configure the Groovy Markup Template Engine...</span>

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> GroovyMarkupConfigurer <span class="hljs-title">groovyMarkupConfigurer</span><span class="hljs-params">()</span> </span>{
        GroovyMarkupConfigurer configurer = <span class="hljs-keyword">new</span> GroovyMarkupConfigurer();
        configurer.setResourceLoaderPath(<span class="hljs-string">"/WEB-INF/"</span>);
        <span class="hljs-keyword">return</span> configurer;
    }
}
</code></pre>
<p>以下示例显示如何在XML中配置相同的内容：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>/&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">mvc:view-resolvers</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:groovy</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mvc:view-resolvers</span>&gt;</span>

<span class="hljs-comment">&lt;!-- Configure the Groovy Markup Template Engine... --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mvc:groovy-configurer</span> <span class="hljs-attr">resource-loader-path</span>=<span class="hljs-string">"/WEB-INF/"</span>/&gt;</span>
</code></pre>
<p><a id="mvc-view-groovymarkup-example"></a></p>
<h5><a href="#mvc-view-groovymarkup-example"></a>例子</h5>
<p>与传统的模板引擎不同，Groovy是依赖于使用生成器语法的DSL。 以下示例显示了HTML页面的示例模板：</p>
<pre><code class="language-html">yieldUnescaped '<span class="hljs-meta">&lt;!DOCTYPE html&gt;</span>'
html(lang:'en') {
    head {
        meta('http-equiv':'"Content-Type" content="text/html; charset=utf-8"')
        title('My page')
    }
    body {
        p('This is an example of HTML contents')
    }
}
</code></pre>
<p><a id="mvc-view-script"></a></p>
<h4><a href="#mvc-view-script"></a>1.9.4. 脚本视图</h4>
<p><a href="web-reactive.html#webflux-view-script">Same as in Spring WebFlux</a></p>
<p>Spring Framework有一个内置的集成，可以将Spring MVC与任何可以在<a href="https://www.jcp.org/en/jsr/detail?id=223">JSR-223</a> Java脚本引擎之上运行的模板库一起使用。 我们在不同的脚本引擎上测试了以下模板库：:</p>
<p>Scripting Library</p>
<p>Scripting Engine</p>
<p><a href="http://handlebarsjs.com/">Handlebars</a></p>
<p><a href="http://openjdk.java.net/projects/nashorn/">Nashorn</a></p>
<p><a href="https://mustache.github.io/">Mustache</a></p>
<p><a href="http://openjdk.java.net/projects/nashorn/">Nashorn</a></p>
<p><a href="https://facebook.github.io/react/">React</a></p>
<p><a href="http://openjdk.java.net/projects/nashorn/">Nashorn</a></p>
<p><a href="http://www.embeddedjs.com/">EJS</a></p>
<p><a href="http://openjdk.java.net/projects/nashorn/">Nashorn</a></p>
<p><a href="http://www.stuartellis.eu/articles/erb/">ERB</a></p>
<p><a href="http://jruby.org">JRuby</a></p>
<p><a href="https://docs.python.org/2/library/string.html#template-strings">String templates</a></p>
<p><a href="http://www.jython.org/">Jython</a></p>
<p><a href="https://github.com/sdeleuze/kotlin-script-templating">Kotlin Script templating</a></p>
<p><a href="https://kotlinlang.org/">Kotlin</a></p>
<p>集成任何其他脚本引擎的基本规则是它必须实现<code>ScriptEngine</code> 和<code>Invocable</code> 接口。</p>
<p><a id="mvc-view-script-dependencies"></a></p>
<h5><a href="#mvc-view-script-dependencies"></a>要求</h5>
<p><a href="web-reactive.html#webflux-view-script-dependencies">Same as in Spring WebFlux</a></p>
<p>您需要在类路径上安装脚本引擎，其详细信息因脚本引擎而异:</p>
<ul>
<li>
<p>The <a href="http://openjdk.java.net/projects/nashorn/">Nashorn</a> Javascript引擎提供了内置的Java 8+。强烈建议使用最新的可用更新版本。</p>
</li>
<li>
<p>为了获得<a href="http://jruby.org">JRuby</a> 支持，应添加JRuby依赖性</p>
</li>
<li>
<p>为了获得<a href="http://www.jython.org">Jython</a>支持，应添加Jython依赖性。</p>
</li>
<li>
<p><code>org.jetbrains.kotlin:kotlin-script-util</code>依赖项和包含在 <code>META-INF/services/javax.script.ScriptEngineFactory</code>文件里的<code>org.jetbrains.kotlin.script.jsr223.KotlinJsr223JvmLocalScriptEngineFactory</code>行应添加到Kotlin脚本支持中。 有关详细信息，请参阅<a href="https://github.com/sdeleuze/kotlin-script-templating">此示例</a>。</p>
</li>
</ul>
<p>还需要为基于脚本的模板引擎添加依赖项。例如，对于javascript，可以使用<a href="http://www.webjars.org/">WebJars</a>。</p>
<p><a id="mvc-view-script-integrate"></a></p>
<h5><a href="#mvc-view-script-integrate"></a>脚本模板</h5>
<p><a href="web-reactive.html#webflux-script-integrate">Same as in Spring WebFlux</a></p>
<p>您可以声明<code>ScriptTemplateConfigurer</code>bean以指定要使用的脚本引擎，要加载的脚本文件，要调用以呈现模板的函数，等等。 以下示例使用Mustache模板和Nashorn JavaScript引擎：</p>
<pre><code class="language-java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@EnableWebMvc</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>{

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configureViewResolvers</span><span class="hljs-params">(ViewResolverRegistry registry)</span> </span>{
        registry.scriptTemplate();
    }

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> ScriptTemplateConfigurer <span class="hljs-title">configurer</span><span class="hljs-params">()</span> </span>{
        ScriptTemplateConfigurer configurer = <span class="hljs-keyword">new</span> ScriptTemplateConfigurer();
        configurer.setEngineName(<span class="hljs-string">"nashorn"</span>);
        configurer.setScripts(<span class="hljs-string">"mustache.js"</span>);
        configurer.setRenderObject(<span class="hljs-string">"Mustache"</span>);
        configurer.setRenderFunction(<span class="hljs-string">"render"</span>);
        <span class="hljs-keyword">return</span> configurer;
    }
}
</code></pre>
<p>以下示例显示了XML中的相同排列：:</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>/&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">mvc:view-resolvers</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:script-template</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mvc:view-resolvers</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">mvc:script-template-configurer</span> <span class="hljs-attr">engine-name</span>=<span class="hljs-string">"nashorn"</span> <span class="hljs-attr">render-object</span>=<span class="hljs-string">"Mustache"</span> <span class="hljs-attr">render-function</span>=<span class="hljs-string">"render"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:script</span> <span class="hljs-attr">location</span>=<span class="hljs-string">"mustache.js"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mvc:script-template-configurer</span>&gt;</span>
</code></pre>
<p>对于Java和XML配置，控制器看起来没有什么不同，如以下示例所示：</p>
<pre><code class="language-java"><span class="hljs-meta">@Controller</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SampleController</span> </span>{

    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/sample"</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">test</span><span class="hljs-params">(Model model)</span> </span>{
        model.addObject(<span class="hljs-string">"title"</span>, <span class="hljs-string">"Sample title"</span>);
        model.addObject(<span class="hljs-string">"body"</span>, <span class="hljs-string">"Sample body"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-string">"template"</span>;
    }
}
</code></pre>
<p>以下示例显示了Mustache模板：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>{{title}}<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{body}}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<p>使用以下参数调用render函数：</p>
<ul>
<li>
<p><code>String template</code>: 模板内容</p>
</li>
<li>
<p><code>Map model</code>: 视图模型</p>
</li>
<li>
<p><code>RenderingContext renderingContext</code>: <a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/servlet/view/script/RenderingContext.html"><code>RenderingContext</code></a>，提供对应用程序上下文，区域设置，模板加载器和URL的访问（自5.0起）。</p>
</li>
</ul>
<p><code>Mustache.render()</code> 方法会与本地兼容，因此可以直接调用。</p>
<p>如果模板化技术需要自定义，则可以提供实现自定义渲染函数的脚本。例如，<a href="http://handlebarsjs.com">Handlerbars</a>需要在使用模板之前进行编译，并且需要使用 <a href="https://en.wikipedia.org/wiki/Polyfill">polyfill</a>以模拟服务器端脚本引擎中不可用的某些浏览器功能。</p>
<p>以下示例显示了如何执行此操作：</p>
<pre><code class="language-java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@EnableWebMvc</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>{

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configureViewResolvers</span><span class="hljs-params">(ViewResolverRegistry registry)</span> </span>{
        registry.scriptTemplate();
    }

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> ScriptTemplateConfigurer <span class="hljs-title">configurer</span><span class="hljs-params">()</span> </span>{
        ScriptTemplateConfigurer configurer = <span class="hljs-keyword">new</span> ScriptTemplateConfigurer();
        configurer.setEngineName(<span class="hljs-string">"nashorn"</span>);
        configurer.setScripts(<span class="hljs-string">"polyfill.js"</span>, <span class="hljs-string">"handlebars.js"</span>, <span class="hljs-string">"render.js"</span>);
        configurer.setRenderFunction(<span class="hljs-string">"render"</span>);
        configurer.setSharedEngine(<span class="hljs-keyword">false</span>);
        <span class="hljs-keyword">return</span> configurer;
    }
}
</code></pre>
<p>当要求非线程安全地使用脚本引擎时，需要将<code>sharedEngine</code>的属性设置为 <code>false</code> ，因为模板库不是为了并发而设计的，具体可以看运行在Nashorn上的Handlerbars或react。据此，需要Java 8u60+的版本来修复这个 <a href="https://bugs.openjdk.java.net/browse/JDK-8076099">bug</a>。</p>
<p><code>polyfill.js</code> 只需定义一个window对象，就可以被Handlerbars运行，如下所示：</p>
<pre><code>var window = {};
</code></pre>
<p>脚本<code>render.js</code>会在使用该模板之前被编译，一个好的产品应当保存和重用模板（使用缓存的方法），这样高效些。这可以在脚本中完成，并且可以自定义它(例如管理模板引擎配置。以下示例显示了如何执行此操作：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span>(<span class="hljs-params">template, model</span>) </span>{
    <span class="hljs-keyword">var</span> compiledTemplate = Handlebars.compile(template);
    <span class="hljs-keyword">return</span> compiledTemplate(model);
}
</code></pre>
<p>有关更多配置示例，请查看Spring Framework单元测试，<a href="https://github.com/spring-projects/spring-framework/tree/master/spring-webmvc/src/test/java/org/springframework/web/servlet/view/script">Java</a>和<a href="https://github.com/spring-projects/spring-framework/tree/master/spring-webmvc/src/test/resources/org/springframework/web/servlet/view/script">resources</a>。</p>
<p><a id="mvc-view-jsp"></a></p>
<h4><a href="#mvc-view-jsp"></a>1.9.5. JSP 和 JSTL</h4>
<p>Spring为JSP和JSTL视图提供了一些现成的解决方案</p>
<p><a id="mvc-view-jsp-resolver"></a></p>
<h5><a href="#mvc-view-jsp-resolver"></a>视图解析</h5>
<p>使用JSP进行开发时，可以声明<code>InternalResourceViewResolver</code>或<code>ResourceBundleViewResolver</code> bean。</p>
<p><code>ResourceBundleViewResolver</code>依赖于属性文件来定义映射到类和URL的视图名称。使用<code>ResourceBundleViewResolver</code>，您可以通过仅使用一个解析器来混合不同类型的视图，如以下示例所示：</p>
<pre><code class="language-xml"><span class="hljs-comment">&lt;!-- the ResourceBundleViewResolver --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"viewResolver"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.web.servlet.view.ResourceBundleViewResolver"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"basename"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"views"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

# And a sample properties file is uses (views.properties in WEB-INF/classes):
welcome.(class)=org.springframework.web.servlet.view.JstlView
welcome.url=/WEB-INF/jsp/welcome.jsp

productList.(class)=org.springframework.web.servlet.view.JstlView
productList.url=/WEB-INF/jsp/productlist.jsp
</code></pre>
<p><code>InternalResourceBundleViewResolver</code>也可用于JSP。 作为最佳实践，我们强烈建议将JSP文件放在<code>'WEB-INF'</code>目录下的目录中，以便客户端无法直接访问。</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"viewResolver"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewClass"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"org.springframework.web.servlet.view.JstlView"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"prefix"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"/WEB-INF/jsp/"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"suffix"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">".jsp"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>
</code></pre>
<p><a id="mvc-view-jsp-jstl"></a></p>
<h5><a href="#mvc-view-jsp-jstl"></a>JSPs 和 JSTL</h5>
<p>当使用Java标准标记库时，必须使用特殊的视图类<code>JstlView</code>，因为JSTL需要一些准备工作，例如I18N功能。</p>
<p><a id="mvc-view-jsp-tags"></a></p>
<h5><a href="#mvc-view-jsp-tags"></a>Spring的JSP标签库</h5>
<p>Spring提供了请求参数与命令对象的数据绑定，如前面章节所述。为了方便开发JSP页面，结合这些数据绑定功能，Spring提供了一些使事情变得更容易的标记。所有的Spring标记都haveHTML转义功能以启用或禁用字符转义。</p>
<p>标签库描述符(TLD) 在<code>spring-webmvc.jar</code>包中。更多的信息，请浏览<a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/servlet/tags/package-summary.html#package.description">API参考</a>或查看标签库说明。</p>
<p><a id="mvc-view-jsp-formtaglib"></a></p>
<h5><a href="#mvc-view-jsp-formtaglib"></a>Spring的表单标签库</h5>
<p>从2.0版本开始, Spring在使用JSP和Spring Web MVC时为处理表单元素提供了一套完整的数据绑定识别标签。每个标签都支持其相应的HTML标签对应的属性集，使标签熟悉和直观地使用，标签生成的HTML 4.01/XHTML 1.0兼容。</p>
<p>不同于其他的表单或输入标签库，Spring的表单标签库是集成在Spring Web MVC中，标签可以使用控制器处理的命令对象和引用数据。因此在下面的例子中将会看到，表单标签使得JSP更加方便开发、阅读和维护。</p>
<p>让我们浏览一下表单标签，看看如何使用每个标签的例子。其中已经包括了生成的HTML片段，而某些标签需要进一步的讨论。</p>
<p><a id="mvc-view-jsp-formtaglib-configuration"></a></p>
<h6><a href="#mvc-view-jsp-formtaglib-configuration"></a>配置</h6>
<p>表单标签库捆绑在<code>spring-webmvc.jar</code>中. 库描述符名字为<code>spring-form.tld</code>.</p>
<p>如果需要使用到这些标签，在JSP页面的头部必须添加对应的标签库</p>
<pre><code class="language-jsp">&lt;%@ taglib prefix=<span class="hljs-string">"form"</span> uri=<span class="hljs-string">"http://www.springframework.org/tags/form"</span> %&gt;
</code></pre>
<p>其中 <code>form</code>是后面引用标签的前缀。</p>
<p><a id="mvc-view-jsp-formtaglib-formtag"></a></p>
<h6><a href="#mvc-view-jsp-formtaglib-formtag"></a>表单标签</h6>
<p>标签'form'绑定了引用库的内部标签，可以被HTML解析。它将命令对象放在<code>PageContext</code>中，以便可以通过内部标记访问命令对象。此库中的所有其他标记都是<code>form</code>标记的嵌套标记。</p>
<p>假设我们有一个名为 <code>User</code>的域对象。 它是一个JavaBean，具有<code>firstName</code>和<code>lastName</code>等属性。我们将使用它作为表单控制器的形式支持对象，输出给 <code>form.jsp</code>。以下示例显示了form.jsp的显示：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">form:form</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>First Name:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form:input</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"firstName"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Last Name:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form:input</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"lastName"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">"2"</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Save Changes"</span>/&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">form:form</span>&gt;</span>
</code></pre>
<p><code>firstName</code>和<code>lastName</code> 值会从页面控制器放置在<code>PageContext</code>的命令对象中查找。更多复杂的例子都是这样延伸的，重点就是内部标签是如何与表单标签一起使用的。</p>
<p>以下清单显示了生成的HTML，它看起来像标准格式：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"POST"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>First Name:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"firstName"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Harry"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Last Name:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"lastName"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Potter"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">"2"</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Save Changes"</span>/&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
</code></pre>
<p>之前的JSP假设表单的变量名是<code>command</code>。如果对象已经封装到另一个名称中了，表单也支持从自定义名称中绑定变量（这是最佳实践）。如以下示例所示：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">form:form</span> <span class="hljs-attr">modelAttribute</span>=<span class="hljs-string">"user"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>First Name:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form:input</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"firstName"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Last Name:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form:input</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"lastName"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">"2"</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Save Changes"</span>/&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">form:form</span>&gt;</span>
</code></pre>
<p><a id="mvc-view-jsp-formtaglib-inputtag"></a></p>
<h6><a href="#mvc-view-jsp-formtaglib-inputtag"></a>输入标签</h6>
<p>这个标签其实就是HTML的<code>input</code>标签（当然是解析后的），此标签或默认绑定值和 <code>type='text'</code>属性。有关此的示例，请参阅<a href="#mvc-view-jsp-formtaglib-formtag">表单标签</a>。 您还可以使用特定于HTML5的类型，例如<code>email</code>, <code>tel</code>, <code>date</code>等。</p>
<p><a id="mvc-view-jsp-formtaglib-checkboxtag"></a></p>
<h6><a href="#mvc-view-jsp-formtaglib-checkboxtag"></a>复选框标签</h6>
<p>复选框也会解析成HTML的输入标签。</p>
<p>假设<code>User</code>对象拥有新闻订阅和爱好列表属性，显示了<code>Preferences</code>类：</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Preferences</span> </span>{

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> receiveNewsletter;
    <span class="hljs-keyword">private</span> String[] interests;
    <span class="hljs-keyword">private</span> String favouriteWord;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isReceiveNewsletter</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> receiveNewsletter;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setReceiveNewsletter</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> receiveNewsletter)</span> </span>{
        <span class="hljs-keyword">this</span>.receiveNewsletter = receiveNewsletter;
    }

    <span class="hljs-keyword">public</span> String[] getInterests() {
        <span class="hljs-keyword">return</span> interests;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setInterests</span><span class="hljs-params">(String[] interests)</span> </span>{
        <span class="hljs-keyword">this</span>.interests = interests;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getFavouriteWord</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> favouriteWord;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFavouriteWord</span><span class="hljs-params">(String favouriteWord)</span> </span>{
        <span class="hljs-keyword">this</span>.favouriteWord = favouriteWord;
    }
}
</code></pre>
<p>相应的<code>form.jsp</code> 可能类似于以下内容：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">form:form</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Subscribe to newsletter?:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">%--</span> <span class="hljs-attr">Approach</span> <span class="hljs-attr">1:</span> <span class="hljs-attr">Property</span> <span class="hljs-attr">is</span> <span class="hljs-attr">of</span> <span class="hljs-attr">type</span> <span class="hljs-attr">java.lang.Boolean</span> <span class="hljs-attr">--</span>%&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form:checkbox</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"preferences.receiveNewsletter"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Interests:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">%--</span> <span class="hljs-attr">Approach</span> <span class="hljs-attr">2:</span> <span class="hljs-attr">Property</span> <span class="hljs-attr">is</span> <span class="hljs-attr">of</span> <span class="hljs-attr">an</span> <span class="hljs-attr">array</span> <span class="hljs-attr">or</span> <span class="hljs-attr">of</span> <span class="hljs-attr">type</span> <span class="hljs-attr">java.util.Collection</span> <span class="hljs-attr">--</span>%&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>
                Quidditch: <span class="hljs-tag">&lt;<span class="hljs-name">form:checkbox</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"preferences.interests"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Quidditch"</span>/&gt;</span>
                Herbology: <span class="hljs-tag">&lt;<span class="hljs-name">form:checkbox</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"preferences.interests"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Herbology"</span>/&gt;</span>
                Defence Against the Dark Arts: <span class="hljs-tag">&lt;<span class="hljs-name">form:checkbox</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"preferences.interests"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Defence Against the Dark Arts"</span>/&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Favourite Word:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">%--</span> <span class="hljs-attr">Approach</span> <span class="hljs-attr">3:</span> <span class="hljs-attr">Property</span> <span class="hljs-attr">is</span> <span class="hljs-attr">of</span> <span class="hljs-attr">type</span> <span class="hljs-attr">java.lang.Object</span> <span class="hljs-attr">--</span>%&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>
                Magic: <span class="hljs-tag">&lt;<span class="hljs-name">form:checkbox</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"preferences.favouriteWord"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Magic"</span>/&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">form:form</span>&gt;</span>
</code></pre>
<p>checkbox标签有三种方法，可满足您的所有复选框需求。</p>
<ul>
<li>
<p>方法一: 当绑定值为<code>java.lang.Boolean</code>,如果绑定值为 <code>true</code>。则<code>input(checkbox)</code>被标记为<code>checked</code> 。value属性对应于<code>setValue(Object)</code>的值（当然是解析后的）。</p>
</li>
<li>
<p>方法二: 当绑定值是<code>array</code> 或<code>java.util.Collection</code>,如果绑定集合中存在已配置的 <code>setValue(Object)</code> 则输入（复选框）将标记为已选中。。</p>
</li>
<li>
<p>方法三: 对于任何其他绑定值类型, 如果配置的<code>setValue(Object)</code>等于绑定值，则<code>input(checkbox)</code>被标记为已选中。</p>
</li>
</ul>
<p>请注意，无论采用何种方法，都会生成相同的HTML结构。 以下HTML代码段定义了一些复选框：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Interests:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>
        Quidditch: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"preferences.interests"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Quidditch"</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"hidden"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"1"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"_preferences.interests"</span>/&gt;</span>
        Herbology: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"preferences.interests"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Herbology"</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"hidden"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"1"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"_preferences.interests"</span>/&gt;</span>
        Defence Against the Dark Arts: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"preferences.interests"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Defence Against the Dark Arts"</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"hidden"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"1"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"_preferences.interests"</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
</code></pre>
<p>可能不希望看到的是每个复选框后都附加隐藏域，如果html页中的复选框一个都没有选中，则在提交表单后，它的值将不会作为HTTP请求参数的一部分发送到服务器，因此为了使Spring表单数据绑定工作。 需要在html中使用此奇怪的变通方法。复选框标记遵循现有的Spring约定，其中包括每个复选框都以下划线<code>_</code>为前缀的隐藏参数。通过这样做，可以有效地告诉Spring&quot;该复选框在表单中是可见的,并且希望将表单数据绑定到其上的对象能够反映复选框的状态&quot;.</p>
<p><a id="mvc-view-jsp-formtaglib-checkboxestag"></a></p>
<h6><a href="#mvc-view-jsp-formtaglib-checkboxestag"></a>复选框标签</h6>
<p>checkbox标签相当于多个HTML的input标签</p>
<p>上一个例子展示了复选框标签的生成。有时候，不希望在JSP页面中列出User的所有爱好。你更希望在运行提供可选的列表，并传递给复选框标签。这是复选框标记的用途。 可以传入一个数组、 一个列表或一个包含<code>items</code>属性中的可用选项的Map。绑定属性通常是一个集合，因此它可以保存用户选择的多个值。下面是使用此标签的JSP示例</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">form:form</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Interests:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">%--</span> <span class="hljs-attr">Property</span> <span class="hljs-attr">is</span> <span class="hljs-attr">of</span> <span class="hljs-attr">an</span> <span class="hljs-attr">array</span> <span class="hljs-attr">or</span> <span class="hljs-attr">of</span> <span class="hljs-attr">type</span> <span class="hljs-attr">java.util.Collection</span> <span class="hljs-attr">--</span>%&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">form:checkboxes</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"preferences.interests"</span> <span class="hljs-attr">items</span>=<span class="hljs-string">"${interestList}"</span>/&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">form:form</span>&gt;</span>
</code></pre>
<p>本实例假定<code>interestList</code>是一个模型的属性<code>List</code>，包含需要的字符串值。在使用MAP的情况下，Map的key将用作值，map的value将用作要显示的标签。还可以使用自定义对象，可以使用<code>itemValue</code>和使用<code>itemLabel</code>的标签作为该值提供属性名称。</p>
<p><a id="mvc-view-jsp-formtaglib-radiobuttontag"></a></p>
<h6><a href="#mvc-view-jsp-formtaglib-radiobuttontag"></a>单选框标签</h6>
<p>还有一个可以解析成HTMLinput标签的是radio标签</p>
<p>radio很简单，提供多个值，但是一次只能选其中一个。如以下示例所示：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Sex:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>
        Male: <span class="hljs-tag">&lt;<span class="hljs-name">form:radiobutton</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"sex"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"M"</span>/&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>
        Female: <span class="hljs-tag">&lt;<span class="hljs-name">form:radiobutton</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"sex"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"F"</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
</code></pre>
<p><a id="mvc-view-jsp-formtaglib-radiobuttonstag"></a></p>
<h6><a href="#mvc-view-jsp-formtaglib-radiobuttonstag"></a>单选标签 <code>radiobuttons</code></h6>
<p>这个形式的<code>radio</code>也可以解析成HTML的<code>input</code>标签，只是它是多个单选。</p>
<p>就像上面的<a href="#mvc-view-jsp-formtaglib-checkboxestag"><code>checkboxes</code> 标签</a>一样，可能希望将可用选项作为运行时变量传入。对于此用法，可以使用单选标签。可以传入一个数组、一个列表或一个包含 <code>items</code>属性的Map。如果使用map，map的key将使用作为值并且map的值将使用作为标签来显示。还可以使用自定义对象，可以使用<code>itemValue</code>和使用<code>itemLabel</code>的标签作为该值提供属性名称。</p>
<pre><code>&lt;tr&gt;
    &lt;td&gt;Sex:&lt;/td&gt;
    &lt;td&gt;&lt;form:radiobuttons path=&quot;sex&quot; items=&quot;${sexOptions}&quot;/&gt;&lt;/td&gt;
&lt;/tr&gt;
</code></pre>
<p><a id="mvc-view-jsp-formtaglib-passwordtag"></a></p>
<h6><a href="#mvc-view-jsp-formtaglib-passwordtag"></a>密码框标签</h6>
<p><code>password</code> 标签页会解析成HTML的<code>input</code>标签 只是它有自己的特性。</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Password:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">form:password</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"password"</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
</code></pre>
<p>请注意，密码值是不可见的。如果希望密码值可见，需要设置<code>showPassword</code>属性为<code>true</code>，如下所示：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Password:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">form:password</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"^76525bvHGq"</span> <span class="hljs-attr">showPassword</span>=<span class="hljs-string">"true"</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
</code></pre>
<p><a id="mvc-view-jsp-formtaglib-selecttag"></a></p>
<h6><a href="#mvc-view-jsp-formtaglib-selecttag"></a>选择标签</h6>
<p>T这个标签就是HTML的select元素。支持单层选项或嵌套选项的选择，数据利用项来绑定。</p>
<p>让我们假设<code>User</code>，他有一个技能列表如下:</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Skills:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form:select</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"skills"</span> <span class="hljs-attr">items</span>=<span class="hljs-string">"${skills}"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
</code></pre>
<p>如果User选中的技能是Herbology，那么这个Skills的HTML源代码是这样的：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Skills:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"skills"</span> <span class="hljs-attr">multiple</span>=<span class="hljs-string">"true"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Potions"</span>&gt;</span>Potions<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Herbology"</span> <span class="hljs-attr">selected</span>=<span class="hljs-string">"selected"</span>&gt;</span>Herbology<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Quidditch"</span>&gt;</span>Quidditch<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
</code></pre>
<p><a id="mvc-view-jsp-formtaglib-optiontag"></a></p>
<h6><a href="#mvc-view-jsp-formtaglib-optiontag"></a>选项标签</h6>
<p>这个标签就是HTML的option(配合select中）元素。它会对被绑定的值设置属性为selected，以下HTML显示了它的典型输出：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>House:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">form:select</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"house"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">form:option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Gryffindor"</span>/&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">form:option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Hufflepuff"</span>/&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">form:option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Ravenclaw"</span>/&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">form:option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Slytherin"</span>/&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">form:select</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
</code></pre>
<p>如果User的家是在Gryffindor，那么House的HTML源代码长这样：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>House:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"house"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Gryffindor"</span> <span class="hljs-attr">selected</span>=<span class="hljs-string">"selected"</span>&gt;</span>Gryffindor<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span> (1)
            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Hufflepuff"</span>&gt;</span>Hufflepuff<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Ravenclaw"</span>&gt;</span>Ravenclaw<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Slytherin"</span>&gt;</span>Slytherin<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
</code></pre>
<p><strong>1</strong>、请注意添加所选属性。</p>
<p><a id="mvc-view-jsp-formtaglib-optionstag"></a></p>
<h6><a href="#mvc-view-jsp-formtaglib-optionstag"></a>选项标签</h6>
<p>这个标签就是HTML的option(配合select中)元素,但是它处理的是一个列表，它会对被绑定的值设置属性为selected，如下所示：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Country:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">form:select</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"country"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">form:option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"-"</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"--Please Select"</span>/&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">form:options</span> <span class="hljs-attr">items</span>=<span class="hljs-string">"${countryList}"</span> <span class="hljs-attr">itemValue</span>=<span class="hljs-string">"code"</span> <span class="hljs-attr">itemLabel</span>=<span class="hljs-string">"name"</span>/&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">form:select</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
</code></pre>
<p>如果User住在UK，那么Country的HTML源代码长这这样:</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Country:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"country"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"-"</span>&gt;</span>--Please Select<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"AT"</span>&gt;</span>Austria<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"UK"</span> <span class="hljs-attr">selected</span>=<span class="hljs-string">"selected"</span>&gt;</span>United Kingdom<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span> (1)
            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"US"</span>&gt;</span>United States<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
</code></pre>
<p><strong>1</strong>、Note the addition of a <code>selected</code> attribute.</p>
<p>看上面的两个例子， <code>option</code>和<code>options</code>标签都生成了相同的标准的HTML，但允许你在JSP中显式地按需显示属性值，例如默认的字符串在例子中是&quot;-- Please Select&quot;（就是默认的，选择为空的那个，这个很有用）。</p>
<p><code>items</code>属性通常使用项对象的集合或数组填充， <code>itemValue</code>和<code>itemLabel</code>就是对应指定bean对象的属性，如果没有指定，对象将被转成字符串。或者， 可以定义一个Map的items，<code>Map</code>的key对应选项值，value对应选项标签。如果如果<code>itemValue</code>和<code>itemLabel</code>都被指定了，那么item值属性对应key，item标签属性对应value。</p>
<p><a id="mvc-view-jsp-formtaglib-textareatag"></a></p>
<h6><a href="#mvc-view-jsp-formtaglib-textareatag"></a>文本框标签</h6>
<p>这个标签解析成HTML中的<code>textarea</code>标签：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Notes:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form:textarea</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"notes"</span> <span class="hljs-attr">rows</span>=<span class="hljs-string">"3"</span> <span class="hljs-attr">cols</span>=<span class="hljs-string">"20"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form:errors</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"notes"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
</code></pre>
<p><a id="mvc-view-jsp-formtaglib-hiddeninputtag"></a></p>
<h6><a href="#mvc-view-jsp-formtaglib-hiddeninputtag"></a>隐藏标签</h6>
<p><code>hidden</code>标签解析为HTML的<code>hidden</code>，用在<code>input</code> 标签中用于暗中绑定值，目的很明显就是隐藏，如下</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">form:hidden</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"house"</span>/&gt;</span>
</code></pre>
<p>如果我们选择<code>house</code>值作为隐藏域提交, HTML长这样:</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"house"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"hidden"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Gryffindor"</span>/&gt;</span>
</code></pre>
<p><a id="mvc-view-jsp-formtaglib-errorstag"></a></p>
<h6><a href="#mvc-view-jsp-formtaglib-errorstag"></a>错误标签</h6>
<p>这个标签会在HTML的 <code>span</code>标签中展示错误，它提供对在控制器中创建的错误的访问，或对与控制器关联的任何验证程序创建的出错信息进行显示。</p>
<p>假设我们希望在提交表单后显示 <code>firstName</code> 和 <code>lastName</code>字段的所有错误信息，我们有一个验证器的实例的 <code>User</code> 类称为<code>UserValidator</code>。如下例所示：</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserValidator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Validator</span> </span>{

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(Class candidate)</span> </span>{
        <span class="hljs-keyword">return</span> User<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">isAssignableFrom</span>(<span class="hljs-title">candidate</span>)</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">validate</span><span class="hljs-params">(Object obj, Errors errors)</span> </span>{
        ValidationUtils.rejectIfEmptyOrWhitespace(errors, <span class="hljs-string">"firstName"</span>, <span class="hljs-string">"required"</span>, <span class="hljs-string">"Field is required."</span>);
        ValidationUtils.rejectIfEmptyOrWhitespace(errors, <span class="hljs-string">"lastName"</span>, <span class="hljs-string">"required"</span>, <span class="hljs-string">"Field is required."</span>);
    }
}
</code></pre>
<p>这个 <code>form.jsp</code>看起来是这样的:</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">form:form</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>First Name:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form:input</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"firstName"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">%--</span> <span class="hljs-attr">Show</span> <span class="hljs-attr">errors</span> <span class="hljs-attr">for</span> <span class="hljs-attr">firstName</span> <span class="hljs-attr">field</span> <span class="hljs-attr">--</span>%&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form:errors</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"firstName"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Last Name:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form:input</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"lastName"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">%--</span> <span class="hljs-attr">Show</span> <span class="hljs-attr">errors</span> <span class="hljs-attr">for</span> <span class="hljs-attr">lastName</span> <span class="hljs-attr">field</span> <span class="hljs-attr">--</span>%&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form:errors</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"lastName"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">"3"</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Save Changes"</span>/&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">form:form</span>&gt;</span>
</code></pre>
<p>如果我们将<code>firstName</code> 和 <code>lastName</code>的域设置空值并提交，则html看起来是这样的:</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"POST"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>First Name:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"firstName"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">""</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">%--</span> <span class="hljs-attr">Associated</span> <span class="hljs-attr">errors</span> <span class="hljs-attr">to</span> <span class="hljs-attr">firstName</span> <span class="hljs-attr">field</span> <span class="hljs-attr">displayed</span> <span class="hljs-attr">--</span>%&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"firstName.errors"</span>&gt;</span>Field is required.<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Last Name:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"lastName"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">""</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">%--</span> <span class="hljs-attr">Associated</span> <span class="hljs-attr">errors</span> <span class="hljs-attr">to</span> <span class="hljs-attr">lastName</span> <span class="hljs-attr">field</span> <span class="hljs-attr">displayed</span> <span class="hljs-attr">--</span>%&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"lastName.errors"</span>&gt;</span>Field is required.<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">"3"</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Save Changes"</span>/&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
</code></pre>
<p>如果我们要显示给定页面的整个错误列表，该怎么办？下面的示例显示了错误标记还支持一些基本的通用功能</p>
<ul>
<li>
<p><code>path=&quot;*&quot;</code>: 展示所有的错误.</p>
</li>
<li>
<p><code>path=&quot;lastName&quot;</code>: 展示<code>lastName</code>域的所有错误</p>
</li>
<li>
<p>如果 <code>path</code> 被省略，只会显示当前对象的错误。</p>
</li>
</ul>
<p>下面的示例将显示页面顶部的错误列表，后跟字段旁边的特定于字段的错误：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">form:form</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">form:errors</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"*"</span> <span class="hljs-attr">cssClass</span>=<span class="hljs-string">"errorBox"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>First Name:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form:input</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"firstName"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form:errors</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"firstName"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Last Name:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form:input</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"lastName"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form:errors</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"lastName"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">"3"</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Save Changes"</span>/&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">form:form</span>&gt;</span>
</code></pre>
<p>html看起来是这样的：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"POST"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"*.errors"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"errorBox"</span>&gt;</span>Field is required.<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>Field is required.<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>First Name:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"firstName"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">""</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"firstName.errors"</span>&gt;</span>Field is required.<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Last Name:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"lastName"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">""</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"lastName.errors"</span>&gt;</span>Field is required.<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">"3"</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Save Changes"</span>/&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
</code></pre>
<p>The <code>spring-form.tld</code> tag library descriptor (TLD) is included in the <code>spring-webmvc.jar</code>. For a comprehensive reference on individual tags, browse the <a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/servlet/tags/form/package-summary.html#package.description">API reference</a> or see the tag library description.</p>
<p><a id="mvc-rest-method-conversion"></a></p>
<h6><a href="#mvc-rest-method-conversion"></a>HTTP方法转换</h6>
<p>REST的一个关键原则是使用统一的接口。这意味着所有资源(URL)都可以使用相同的四种HTTP方法进行操作GET, PUT, POST,和 DELETE。对于每个方法，HTTP规范都定义了精确的语义。例如， GET应该始终是一个安全的操作，这意味着它对服务器的数据没有任何影响。而PUT或DELETE应该是幂等的，这意味着可以反复重复这些操作，其最终结果应该是相同的。虽然HTTP定义了这四种方法，但是HTML只支持两个：GET和POST， 幸运的是，有两种可能的解决方法：1，可以使用JavaScript来执行PUT或DELETE。或者2，简单地用“real”的方式作为附加参数(作为HTML表单中的隐藏输入字段)进行POST。后者是使用Spring的<code>HiddenHttpMethodFilter</code>做的。 这个过滤器是一个简单的Servlet过滤器，因此它可以与任何Web框架(不仅仅是Spring MVC)结合使用，只需将此筛选器添加到 web.xml,并将具有隐藏域<code>_method</code>参数转换为相应的HTTP方法请求。</p>
<p>为了支持HTTP方法转换，Spring MVC表单标签被重新设计来支持设置HTTP方法。例如，更新后的Petclinic示例有以下判断：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">form:form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"delete"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"submit"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Delete Pet"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">form:form</span>&gt;</span>
</code></pre>
<p>实际上它就是一个HTTP POST，DELETE方法只是隐藏在请求参数中的假正经方法而已，这个DELETE将被定义在web.xml的 <code>HiddenHttpMethodFilter</code>来处理,如以下示例所示：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>httpMethodFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>org.springframework.web.filter.HiddenHttpMethodFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>httpMethodFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>petclinic<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span>
</code></pre>
<p>以下示例显示了相应的<code>@Controller</code>方法：</p>
<pre><code class="language-java"><span class="hljs-meta">@RequestMapping</span>(method = RequestMethod.DELETE)
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">deletePet</span><span class="hljs-params">(@PathVariable <span class="hljs-keyword">int</span> ownerId, @PathVariable <span class="hljs-keyword">int</span> petId)</span> </span>{
    <span class="hljs-keyword">this</span>.clinic.deletePet(petId);
    <span class="hljs-keyword">return</span> <span class="hljs-string">"redirect:/owners/"</span> + ownerId;
}
</code></pre>
<p><a id="mvc-view-jsp-formtaglib-html5"></a></p>
<h6><a href="#mvc-view-jsp-formtaglib-html5"></a>HTML5标签</h6>
<p>表单标签库允许输入动态属性，这意味着您可以输入任何HTML5的特定属性。</p>
<p>表单<code>input</code>标签支持输入文本以外的类型属性。 他允许HTML5定义输入类型，例如<code>email</code>, <code>date</code>,<code>range</code>等。 请注意，因为text是默认类型，因此不需要输入<code>type='text'</code></p>
<p><a id="mvc-view-tiles"></a></p>
<h4><a href="#mvc-view-tiles"></a>1.9.6. Tiles</h4>
<p>Spring Web应用还可以集成Tiles，就像其它视图技术一样。下面将描述怎样集成。</p>
<p>本节重点介绍Spring在<code>org.springframework.web.servlet.view.tiles3</code>包中对Tiles版本3的支持。</p>
<p><a id="mvc-view-tiles-dependencies"></a></p>
<h5><a href="#mvc-view-tiles-dependencies"></a>依赖</h5>
<p>为了能够使用Tiles，您必须在Tiles 3.0.1或更高版本上添加依赖项及其对项目的<a href="https://tiles.apache.org/framework/dependency-management.html">传递依赖性</a>。</p>
<p><a id="mvc-view-tiles-integrate"></a></p>
<h5><a href="#mvc-view-tiles-integrate"></a>配置</h5>
<p>为了能够使用Tiles，您必须使用包含定义的文件对其进行配置（有关定义和其他Tiles概念的基本信息，请参阅<a href="https://tiles.apache.org">http://tiles.apache.org</a>）。 在Spring中，这是通过使用 <code>TilesConfigurer</code>完成的。 以下示例<code>ApplicationContext</code>配置显示了如何执行此操作：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"tilesConfigurer"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.web.servlet.view.tiles3.TilesConfigurer"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"definitions"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>/WEB-INF/defs/general.xml<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>/WEB-INF/defs/widgets.xml<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>/WEB-INF/defs/administrator.xml<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>/WEB-INF/defs/customer.xml<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>/WEB-INF/defs/templates.xml<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>
</code></pre>
<p>这里的Tiles定义了五个文件，都位于<code>WEB-INF/defs</code> 文件夹中。在初始化<code>WebApplicationContext</code>时 ，文件将被加载，定义工厂将被初始化。完成此操作之后，在Spring Web应用程序中，定义文件中包含的Tiles可以用作视图。 之后Spring使用Tiles与使用其他视图是一样的：通过<code>ViewResolver</code>解析，<code>ViewResolver</code>可以选择<code>UrlBasedViewResolver</code>或<code>ResourceBundleViewResolver</code>。</p>
<p>您可以通过添加下划线然后添加区域设置来指定特定于区域设置的Tiles定义，如以下示例所示：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"tilesConfigurer"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.web.servlet.view.tiles3.TilesConfigurer"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"definitions"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>/WEB-INF/defs/tiles.xml<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>/WEB-INF/defs/tiles_fr_FR.xml<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>
</code></pre>
<p>使用上述配置，<code>tiles_fr_FR.xml</code>用于具有 <code>fr_FR</code>语言环境的请求，默认情况下使用<code>tiles.xml</code>。</p>
<p>由于下划线用于表示区域设置，因此我们建议不要在Tiles定义的文件名中使用它们。</p>
<p><a id="mvc-view-tiles-url"></a></p>
<h6><a href="#mvc-view-tiles-url"></a><code>UrlBasedViewResolver</code></h6>
<p><code>UrlBasedViewResolver</code>对给定的<code>viewClass</code>进行实例化，即会解析所有的视图。 以下bean定义了<code>UrlBasedViewResolver</code>：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"viewResolver"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.web.servlet.view.UrlBasedViewResolver"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewClass"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"org.springframework.web.servlet.view.tiles3.TilesView"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>
</code></pre>
<p><a id="mvc-view-tiles-resource"></a></p>
<h6><a href="#mvc-view-tiles-resource"></a><code>ResourceBundleViewResolver</code></h6>
<p><code>ResourceBundleViewResolver</code>必须提供一个包含viewnames和viewclasses的属性文件。以下示例显示了<code>ResourceBundleViewResolver</code>的bean定义以及相应的视图名称和视图类（取自Pet Clinic示例）：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"viewResolver"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.web.servlet.view.ResourceBundleViewResolver"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"basename"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"views"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

...
welcomeView.(class)=org.springframework.web.servlet.view.tiles3.TilesView
welcomeView.url=welcome (this is the name of a Tiles definition)

vetsView.(class)=org.springframework.web.servlet.view.tiles3.TilesView
vetsView.url=vetsView (again, this is the name of a Tiles definition)

findOwnersForm.(class)=org.springframework.web.servlet.view.JstlView
findOwnersForm.url=/WEB-INF/jsp/findOwners.jsp
...
</code></pre>
<p>使用<code>ResourceBundleViewResolver</code>时，可以轻松混合使用不同的视图技术。</p>
<p>请注意， <code>TilesView</code> 类支持JSTL（JSP标准标记库）。</p>
<p><a id="mvc-view-tiles-preparer"></a></p>
<h6><a href="#mvc-view-tiles-preparer"></a><code>SimpleSpringPreparerFactory</code> 和 <code>SpringBeanPreparerFactory</code></h6>
<p>作为一个高级功能，Spring还支持两个特殊的Tiles <code>PreparerFactory</code>实现，有关如何在Tiles定义文件中使用<code>ViewPreparer</code>引用的详细信息，请参阅Tiles文档。</p>
<p>您可以指定SimpleSpringPreparerFactory以基于指定的preparer类自动装配ViewPreparer实例，应用Spring的容器回调以及应用已配置的Spring BeanPostProcessors。 如果已激活Spring的上下文范围注释配置，则会自动检测并应用ViewPreparer类中的注释。 请注意，这需要Tiles定义文件中的preparer类，作为默认的PreparerFactory。</p>
<p>您可以指定<code>SpringBeanPreparerFactory</code>来操作指定的preparer名称（而不是类），从DispatcherServlet的应用程序上下文中获取相应的Spring bean。在这种情况下，完整的bean创建过程控制着Spring应用程序上下文，允许使用显式依赖项注入配置，作用域bean等。 请注意，您需要为每个preparer名称定义一个Spring bean定义（在Tiles定义中使用）。 以下示例显示如何在<code>TilesConfigurer</code>上定义一个 <code>SpringBeanPreparerFactory</code>属性集：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"tilesConfigurer"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.web.servlet.view.tiles3.TilesConfigurer"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"definitions"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>/WEB-INF/defs/general.xml<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>/WEB-INF/defs/widgets.xml<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>/WEB-INF/defs/administrator.xml<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>/WEB-INF/defs/customer.xml<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>/WEB-INF/defs/templates.xml<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- resolving preparer names as Spring bean definition names --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"preparerFactoryClass"</span>
            <span class="hljs-attr">value</span>=<span class="hljs-string">"org.springframework.web.servlet.view.tiles3.SpringBeanPreparerFactory"</span>/&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>
</code></pre>
<p><a id="mvc-view-feeds"></a></p>
<h4><a href="#mvc-view-feeds"></a>1.9.7. RSS 和 Atom</h4>
<p><code>AbstractAtomFeedView</code>和<code>AbstractRssFeedView</code>都继承自<code>AbstractFeedView</code>基类，分别用于提供Atom和RSS Feed视图。 它们基于java.net的<a href="https://rome.dev.java.net">ROME</a>项目，位于<code>org.springframework.web.servlet.view.feed</code>包中。</p>
<p><code>AbstractAtomFeedView</code> 要求实现<code>buildFeedEntries()</code> 方法，并可选择重写 <code>buildFeedMetadata()</code> 方法(默认实现为空).以下示例显示了如何执行此操作：</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SampleContentAtomView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractAtomFeedView</span> </span>{

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildFeedMetadata</span><span class="hljs-params">(Map&lt;String, Object&gt; model,
            Feed feed, HttpServletRequest request)</span> </span>{
        <span class="hljs-comment">// implementation omitted</span>
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> List&lt;Entry&gt; <span class="hljs-title">buildFeedEntries</span><span class="hljs-params">(Map&lt;String, Object&gt; model,
            HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>{
        <span class="hljs-comment">// implementation omitted</span>
    }

}
</code></pre>
<p>类似的要求适用于实现<code>AbstractRssFeedView</code>，如以下示例所示：</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SampleContentAtomView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractRssFeedView</span> </span>{

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildFeedMetadata</span><span class="hljs-params">(Map&lt;String, Object&gt; model,
            Channel feed, HttpServletRequest request)</span> </span>{
        <span class="hljs-comment">// implementation omitted</span>
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> List&lt;Item&gt; <span class="hljs-title">buildFeedItems</span><span class="hljs-params">(Map&lt;String, Object&gt; model,
            HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>{
        <span class="hljs-comment">// implementation omitted</span>
    }
}
</code></pre>
<p><code>buildFeedItems()</code> 和 <code>buildFeedEntries()</code>方法在HTTP请求中传递，以防需要访问区域设置。仅为cookie或其他http头的设置传递http响应。该feed将在方法返回后自动写入响应对象。</p>
<p>有关创建Atom视图的示例，请参阅Alef Arendsen的Spring Team Blog <a href="https://spring.io/blog/2009/03/16/adding-an-atom-view-to-an-application-using-spring-s-rest-support">条目</a>.</p>
<p><a id="mvc-view-document"></a></p>
<h4><a href="#mvc-view-document"></a>1.9.8. PDF 和 Excel</h4>
<p>Spring提供了返回HTML以外的输出的方法，包括PDF和Excel电子表格。 本节介绍如何使用这些功能。</p>
<p><a id="mvc-view-document-intro"></a></p>
<h5><a href="#mvc-view-document-intro"></a>文档视图简介</h5>
<p>返回HTML页并不总是用户查看模型输出的最佳方式，Spring让开发者可以从模型数据动态生成PDF文档或Excel电子表格。该文档是视图，将从具有正确内容类型的服务器流式传输到HTML，使客户端PC能够运行其电子表格或PDF查看器应用程序以进行响应。</p>
<p>要使用Excel视图，需要将Apache POI库添加到类路径中。对于PDF生成，您需要添加（最好）OpenPDF库。</p>
<p>如果可能，您应该使用最新版本的基础文档生成库。 特别是，我们强烈建议使用OpenPDF（例如，OpenPDF 1.0.5）而不是过时的原始iText 2.1.7，因为OpenPDF是主动维护的，并修复了不受信任的PDF内容的重要漏洞。</p>
<p><a id="mvc-view-document-pdf"></a></p>
<h5><a href="#mvc-view-document-pdf"></a>PDF 视图</h5>
<p>单词列表的简单PDF视图可以扩展<code>org.springframework.web.servlet.view.document.AbstractPdfView</code>并实现<code>buildPdfDocument()</code> 方法，如以下示例所示：</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PdfWordList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractPdfView</span> </span>{

    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildPdfDocument</span><span class="hljs-params">(Map&lt;String, Object&gt; model, Document doc, PdfWriter writer,
            HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>{

        List&lt;String&gt; words = (List&lt;String&gt;) model.get(<span class="hljs-string">"wordList"</span>);
        <span class="hljs-keyword">for</span> (String word : words) {
            doc.add(<span class="hljs-keyword">new</span> Paragraph(word));
        }
    }
}
</code></pre>
<p>控制器可以从外部视图定义（通过名称引用它）返回这样的视图，也可以从处理程序方法返回<code>View</code>实例。</p>
<p><a id="mvc-view-document-excel"></a></p>
<h5><a href="#mvc-view-document-excel"></a>Excel 视图</h5>
<p>从Spring Framework 4.2开始，<code>org.springframework.web.servlet.view.document.AbstractXlsView</code> 作为Excel视图的基类提供。 它基于Apache POI，具有专门的子类（<code>AbstractXlsxStreamingView</code>和<code>AbstractExcelView</code>），取代了过时的<code>AbstractXlsxView</code>类。</p>
<p>编程模型类似于 <code>AbstractPdfView</code>，<code>buildExcelDocument()</code>作为核心模板方法，控制器能够从外部定义（通过名称）返回这样的视图，或者从处理程序方法返回<code>View</code>实例。</p>
<p><a id="mvc-view-jackson"></a></p>
<h4><a href="#mvc-view-jackson"></a>1.9.9. Jackson</h4>
<p><a href="web-reactive.html#webflux-view-httpmessagewriter">Same as in Spring WebFlux</a></p>
<p>Spring为Jackson JSON库提供支持。</p>
<p><a id="mvc-view-json-mapping"></a></p>
<h5><a href="#mvc-view-json-mapping"></a>基于Jackson 的JSON 视图</h5>
<p><a href="web-reactive.html#webflux-view-httpmessagewriter">Same as in Spring WebFlux</a></p>
<p><code>MappingJackson2JsonView</code>使用Jackson库的<code>ObjectMapper</code>将响应内容呈现为JSON。 默认情况下，模型映射的全部内容（特定于框架的类除外）都编码为JSON。 对于需要过滤Map内容的情况，您可以使用<code>modelKeys</code>属性指定要编码的特定模型属性集。 您还可以使用 <code>extractValueFromSingleKeyModel</code>属性将single-key模型中的值直接提取和序列化，而不是作为模型属性的映射。</p>
<p>您可以使用Jackson提供的注解根据需要自定义JSON映射。 当您需要进一步控制时，可以通过 <code>ObjectMapper</code>属性注入自定义<code>ObjectMapper</code>，以用于需要为特定类型提供自定义JSON序列化程序和反序列化程序的情况。</p>
<p><a id="mvc-view-xml-mapping"></a></p>
<h5><a href="#mvc-view-xml-mapping"></a>基于Jackson的XML视图</h5>
<p><a href="web-reactive.html#webflux-view-httpmessagewriter">Same as in Spring WebFlux</a></p>
<p><code>MappingJackson2XmlView</code>使用<a href="https://github.com/FasterXML/jackson-dataformat-xml">Jackson XML扩展的</a> <code>XmlMapper</code>将响应内容呈现为XML。 如果模型包含多个条目，则应使用<code>modelKey</code>bean属性显式设置要序列化的对象。 如果模型包含单个条目，则会自动序列化。</p>
<p>您可以使用JAXB或Jackson提供的注解根据需要自定义XML映射。 当您需要进一步控制时，可以通过<code>ObjectMapper</code>属性注入自定义<code>XmlMapper</code>，以便自定义XML需要为特定类型提供序列化程序和反序列化程序。</p>
<p><a id="mvc-view-xml-marshalling"></a></p>
<h4><a href="#mvc-view-xml-marshalling"></a>1.9.10. XML编组</h4>
<p><code>MarshallingView</code>使用XML <code>Marshaller</code>（在<code>org.springframework.oxm</code>包中定义）将响应内容呈现为XML。 您可以使用 <code>MarshallingView</code> 实例的 <code>modelKey</code> bean属性显式设置要编组的对象。 或者，视图会迭代所有模型属性，并封送<code>Marshaller</code>支持的第一种类型。 有关<code>org.springframework.oxm</code>包中功能的更多信息，请参阅使用 <a href="data-access.html#oxm">Marshalling XML using O/X Mappers</a>。</p>
<p><a id="mvc-view-xslt"></a></p>
<h4><a href="#mvc-view-xslt"></a>1.9.11. XSLT视图</h4>
<p>XSLT是一个用于转换XML的语言,能够在web的视图技术中使用.如果应用需要处理XML（或者将模型转换为XML），那么XSLT是一个很适合的视图技术。以下部分显示如何将XML文档生成为模型数据，并在Spring Web MVC应用程序中使用XSLT进行转换。</p>
<p>这个例子是一个简单的Spring应用程序，它在Controller中创建一个单词列表并将它们添加到模型映射中。该映射与使用的XSLT视图名称一起返回。有关Spring Web MVC控制器接口的详细信息， 请参阅<a href="#mvc-controller">带注解的控制器</a>。 XSLT控制器将单词列表转换为准备转换的简单XML文档。</p>
<p><a id="mvc-view-xslt-beandefs"></a></p>
<h5><a href="#mvc-view-xslt-beandefs"></a>Beans</h5>
<p>Configuration配置是Spring应用程序的标配，MVC配置必须定义<code>XsltViewResolver</code> bean和常规MVC注解配置，以下示例显示了如何执行此操作：</p>
<pre><code class="language-java"><span class="hljs-meta">@EnableWebMvc</span>
<span class="hljs-meta">@ComponentScan</span>
<span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>{

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> XsltViewResolver <span class="hljs-title">xsltViewResolver</span><span class="hljs-params">()</span> </span>{
        XsltViewResolver viewResolver = <span class="hljs-keyword">new</span> XsltViewResolver();
        viewResolver.setPrefix(<span class="hljs-string">"/WEB-INF/xsl/"</span>);
        viewResolver.setSuffix(<span class="hljs-string">".xslt"</span>);
        <span class="hljs-keyword">return</span> viewResolver;
    }
}
</code></pre>
<p><a id="mvc-view-xslt-controllercode"></a></p>
<h5><a href="#mvc-view-xslt-controllercode"></a>控制器</h5>
<p>并且我们需要一个控制器，用来处理单词的生成逻辑。</p>
<p>控制器逻辑封装在<code>@Controller</code> 类中，处理程序方法定义如下：</p>
<pre><code class="language-java"><span class="hljs-meta">@Controller</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XsltController</span> </span>{

    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/"</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">home</span><span class="hljs-params">(Model model)</span> <span class="hljs-keyword">throws</span> Exception </span>{
        Document document = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();
        Element root = document.createElement(<span class="hljs-string">"wordList"</span>);

        List&lt;String&gt; words = Arrays.asList(<span class="hljs-string">"Hello"</span>, <span class="hljs-string">"Spring"</span>, <span class="hljs-string">"Framework"</span>);
        <span class="hljs-keyword">for</span> (String word : words) {
            Element wordNode = document.createElement(<span class="hljs-string">"word"</span>);
            Text textNode = document.createTextNode(word);
            wordNode.appendChild(textNode);
            root.appendChild(wordNode);
        }

        model.addAttribute(<span class="hljs-string">"wordList"</span>, root);
        <span class="hljs-keyword">return</span> <span class="hljs-string">"home"</span>;
    }
}
</code></pre>
<p>到目前为止，我们只创建了一个DOM文档并将其添加到模型映射中。 请注意，您还可以将XML文件作为<code>Resource</code> 加载，并使用它而不是自定义DOM文档。</p>
<p>当然，有软件包可以自动 'domify'对象图，在Spring中，您可以完全灵活地以您选择的任何方式从模型中创建DOM。这可以防止XML在模型数据的结构中扮演太大的角色，这在使用工具管理DOM化过程时是一种危险。。</p>
<p><a id="mvc-view-xslt-transforming"></a></p>
<h5><a href="#mvc-view-xslt-transforming"></a>转换</h5>
<p>最后, <code>XsltViewResolver</code> 将解析“home” XSLT 模板文件，并将DOM文档合并到其中以生成所需视图。例如<code>XsltViewResolver</code>配置所示，XSLT模板在<code>WEB-INF/xsl</code>目录中的<code>war</code>文件中， 并以<code>xslt</code>文件扩展名结束。</p>
<p>以下示例显示了XSLT转换：</p>
<pre><code class="language-xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">xsl:stylesheet</span> <span class="hljs-attr">version</span>=<span class="hljs-string">"1.0"</span> <span class="hljs-attr">xmlns:xsl</span>=<span class="hljs-string">"http://www.w3.org/1999/XSL/Transform"</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">xsl:output</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"html"</span> <span class="hljs-attr">omit-xml-declaration</span>=<span class="hljs-string">"yes"</span>/&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">xsl:template</span> <span class="hljs-attr">match</span>=<span class="hljs-string">"/"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Hello!<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>My First Words<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">xsl:apply-templates</span>/&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">xsl:template</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">xsl:template</span> <span class="hljs-attr">match</span>=<span class="hljs-string">"word"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">xsl:value-of</span> <span class="hljs-attr">select</span>=<span class="hljs-string">"."</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">xsl:template</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">xsl:stylesheet</span>&gt;</span>
</code></pre>
<p>上述转换呈现为以下HTML：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">META</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"Content-Type"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"text/html; charset=UTF-8"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Hello!<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>My First Words<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Hello<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Spring<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Framework<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<p><a id="mvc-config"></a></p>
<h3><a href="#mvc-config"></a>1.10. MVC 配置</h3>
<p><a href="web-reactive.html#webflux-config">Same as in Spring WebFlux</a></p>
<p>MVC Java配置和MVC命名空间提供了适用于大多数应用程序的默认配置以及配置API来对其进行自定义。</p>
<p>有关配置API中没有的高级自定义设置请参阅<a href="#mvc-config-advanced-java">高级 Java 配置</a> 和 <a href="#mvc-config-advanced-xml">高级 XML 配置</a>.</p>
<p>您无需了解MVC Java配置和MVC命名空间创建的基础bean。 如果您想了解更多信息，请参阅特殊Bean类型和Web MVC配置。<a href="#mvc-servlet-special-bean-types">特殊Bean类型</a> 和 <a href="#mvc-servlet-config">Web MVC配置</a>.</p>
<p><a id="mvc-config-enable"></a></p>
<h4><a href="#mvc-config-enable"></a>1.10.1. 启用 MVC 配置</h4>
<p><a href="web-reactive.html#webflux-config-enable">Same as in Spring WebFlux</a></p>
<p>在Java配置中，您可以使用<code>@EnableWebMvc</code> 注解启用MVC配置，如以下示例所示:</p>
<pre><code>@Configuration
@EnableWebMvc
public class WebConfig {
}
</code></pre>
<p>在XML配置中，您可以使用<code>&lt;mvc:annotation-driven&gt;</code> 元素来启用MVC配置，如以下示例所示:</p>
<pre><code class="language-xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span>
    <span class="hljs-attr">xmlns:mvc</span>=<span class="hljs-string">"http://www.springframework.org/schema/mvc"</span>
    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/mvc
        http://www.springframework.org/schema/mvc/spring-mvc.xsd"</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>/&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span>
</code></pre>
<p>前面的示例注册了许多Spring MVC基础结构bean，并适应类路径上可用的依赖项（例如，JSON，XML等的有效负载转换器）。</p>
<p><a id="mvc-config-customize"></a></p>
<h4><a href="#mvc-config-customize"></a>1.10.2. MVC 配置 API</h4>
<p><a href="web-reactive.html#webflux-config-customize">Same as in Spring WebFlux</a></p>
<p>在Java配置中，您可以实现<code>WebMvcConfigurer</code>接口，如以下示例所示:</p>
<pre><code class="language-java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@EnableWebMvc</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>{

    <span class="hljs-comment">// Implement configuration methods...</span>
}
</code></pre>
<p>在XML中，您可以检查<code>&lt;mvc:annotation-driven/&gt;</code>的属性和子元素。 您可以查看<a href="https://schema.spring.io/mvc/spring-mvc.xsd">Spring MVC XML schema</a> 或使用IDE的代码完成功能来发现可用的属性和子元素。</p>
<p><a id="mvc-config-conversion"></a></p>
<h4><a href="#mvc-config-conversion"></a>1.10.3. 类型转换</h4>
<p><a href="web-reactive.html#webflux-config-conversion">Same as in Spring WebFlux</a></p>
<p>数字的 <code>Number</code>类型和日期<code>Date</code> 类型的格式化是默认安装了的，包括<code>@NumberFormat</code>注解和<code>@DateTimeFormat</code>注解，如果类路径中存在Joda-Time，则还会安装对Joda-Time格式库的完全支持。</p>
<p>在Java配置中，您可以注册自定义格式化程序和转换器，如以下示例所示：</p>
<pre><code class="language-java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@EnableWebMvc</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>{

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addFormatters</span><span class="hljs-params">(FormatterRegistry registry)</span> </span>{
        <span class="hljs-comment">// ...</span>
    }
}
</code></pre>
<p>以下示例显示如何在XML中实现相同的配置：</p>
<pre><code class="language-xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span>
    <span class="hljs-attr">xmlns:mvc</span>=<span class="hljs-string">"http://www.springframework.org/schema/mvc"</span>
    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/mvc
        http://www.springframework.org/schema/mvc/spring-mvc.xsd"</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span> <span class="hljs-attr">conversion-service</span>=<span class="hljs-string">"conversionService"</span>/&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"conversionService"</span>
            <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.format.support.FormattingConversionServiceFactoryBean"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"converters"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.example.MyConverter"</span>/&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"formatters"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.example.MyFormatter"</span>/&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.example.MyAnnotationFormatterFactory"</span>/&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"formatterRegistrars"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.example.MyFormatterRegistrar"</span>/&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span>
</code></pre>
<p>有关何时使用FormatterRegistrar实现的更多信息，请参阅 <a href="core.html#format-FormatterRegistrar-SPI"><code>FormatterRegistrar</code> SPI</a>和 <code>FormattingConversionServiceFactoryBean</code>。</p>
<p><a id="mvc-config-validation"></a></p>
<h4><a href="#mvc-config-validation"></a>1.10.4. 验证</h4>
<p><a href="web-reactive.html#webflux-config-validation">Same as in Spring WebFlux</a></p>
<p>默认情况下，如果类路径上存在<a href="core.html#validation-beanvalidation-overview">Bean Validation</a>(例如Hibernate Validator），则 <code>LocalValidatorFactoryBean</code>将注册为全局<a href="core.html#validator">Validator</a> 。 以便与 <code>@Valid</code> 和 <code>Validated</code> 一起使用并在控制器方法参数上进行验证。</p>
<p>在Java配置中，您可以自定义全局<code>Validator</code>实例，如以下示例所示：</p>
<pre><code class="language-java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@EnableWebMvc</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>{

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Validator <span class="hljs-title">getValidator</span><span class="hljs-params">()</span></span>; {
        <span class="hljs-comment">// ...</span>
    }
}
</code></pre>
<p>以下示例显示如何在XML中实现相同的配置:</p>
<pre><code class="language-xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span>
    <span class="hljs-attr">xmlns:mvc</span>=<span class="hljs-string">"http://www.springframework.org/schema/mvc"</span>
    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/mvc
        http://www.springframework.org/schema/mvc/spring-mvc.xsd"</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span> <span class="hljs-attr">validator</span>=<span class="hljs-string">"globalValidator"</span>/&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span>
</code></pre>
<p>请注意，您还可以在本地注册<code>Validator</code>实现，如以下示例所示：</p>
<pre><code class="language-java"><span class="hljs-meta">@Controller</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyController</span> </span>{

    <span class="hljs-meta">@InitBinder</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initBinder</span><span class="hljs-params">(WebDataBinder binder)</span> </span>{
        binder.addValidators(<span class="hljs-keyword">new</span> FooValidator());
    }

}
</code></pre>
<p>如果需要在某处注入<code>LocalValidatorFactoryBean</code>，请创建一个bean并使用<code>@Primary</code>标记它，以避免与MVC配置中声明的那个冲突。</p>
<p><a id="mvc-config-interceptors"></a></p>
<h4><a href="#mvc-config-interceptors"></a>1.10.5. 拦截器</h4>
<p>在Java配置中，注册拦截器应用于传入的请求。如以下示例所示：</p>
<pre><code class="language-java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@EnableWebMvc</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>{

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>{
        registry.addInterceptor(<span class="hljs-keyword">new</span> LocaleChangeInterceptor());
        registry.addInterceptor(<span class="hljs-keyword">new</span> ThemeChangeInterceptor()).addPathPatterns(<span class="hljs-string">"/**"</span>).excludePathPatterns(<span class="hljs-string">"/admin/**"</span>);
        registry.addInterceptor(<span class="hljs-keyword">new</span> SecurityInterceptor()).addPathPatterns(<span class="hljs-string">"/secure/*"</span>);
    }
}
</code></pre>
<p>以下示例显示如何在XML中实现相同的配置：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptors</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.web.servlet.i18n.LocaleChangeInterceptor"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptor</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">mvc:mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/**"</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">mvc:exclude-mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/admin/**"</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.web.servlet.theme.ThemeChangeInterceptor"</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptor</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptor</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">mvc:mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/secure/*"</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.example.SecurityInterceptor"</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptor</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptors</span>&gt;</span>
</code></pre>
<p><a id="mvc-config-content-negotiation"></a></p>
<h4><a href="#mvc-config-content-negotiation"></a>1.10.6. 内容类型</h4>
<p><a href="web-reactive.html#webflux-config-content-negotiation">Same as in Spring WebFlux</a></p>
<p>您可以配置Spring MVC如何根据请求确定所请求的媒体类型（例如，<code>Accept</code>头，URL路径扩展，查询参数等）。</p>
<p>默认情况下，首先检查URL路径扩展 - 将 <code>json</code>, <code>xml</code>, <code>rss</code>, 和 <code>atom</code>注册为已知扩展（取决于类路径依赖性）。 第二个检查 <code>Accept</code>头。</p>
<p>将这些默认值更改为只接受<code>Accept</code>头，并且如果必须使用基于内容类型解析，请考虑路径扩展上的查询参数策略。 有关更多详细信息，请参阅 <a href="#mvc-ann-requestmapping-suffix-pattern-match">后缀匹配</a> and <a href="#mvc-ann-requestmapping-rfd">后缀匹配以及RFD</a>。</p>
<p>在Java配置中，您可以自定义请求的内容类型解析，如以下示例所示：</p>
<pre><code class="language-java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@EnableWebMvc</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>{

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configureContentNegotiation</span><span class="hljs-params">(ContentNegotiationConfigurer configurer)</span> </span>{
        configurer.mediaType(<span class="hljs-string">"json"</span>, MediaType.APPLICATION_JSON);
        configurer.mediaType(<span class="hljs-string">"xml"</span>, MediaType.APPLICATION_XML);
    }
}
</code></pre>
<p>以下示例显示如何在XML中实现相同的配置：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span> <span class="hljs-attr">content-negotiation-manager</span>=<span class="hljs-string">"contentNegotiationManager"</span>/&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"contentNegotiationManager"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.web.accept.ContentNegotiationManagerFactoryBean"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"mediaTypes"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>
            json=application/json
            xml=application/xml
        <span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>
</code></pre>
<p><a id="mvc-config-message-converters"></a></p>
<h4><a href="#mvc-config-message-converters"></a>1.10.7. 消息转换</h4>
<p><a href="web-reactive.html#webflux-config-message-codecs">Same as in Spring WebFlux</a></p>
<p>使用MVC Java编程配置方式时，如果想替换Spring MVC提供的默认转换器，完全定制自己的<code>HttpMessageConverter</code> ，这可以通过覆写<a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/servlet/config/annotation/WebMvcConfigurer.html#configureMessageConverters-java.util.List-"><code>configureMessageConverters()</code></a>方法来实现。 如果只是想自定义，或者想在默认转换器之外再添加其他的转换器，那么可以通过覆写<a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/servlet/config/annotation/WebMvcConfigurer.html#extendMessageConverters-java.util.List-"><code>extendMessageConverters()</code></a>方法来实现。</p>
<p>以下示例使用自定义的<code>ObjectMapper</code>而不是默认的<code>ObjectMapper</code>添加XML和Jackson JSON转换器：</p>
<pre><code class="language-java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@EnableWebMvc</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebConfiguration</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>{

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configureMessageConverters</span><span class="hljs-params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> </span>{
        Jackson2ObjectMapperBuilder builder = <span class="hljs-keyword">new</span> Jackson2ObjectMapperBuilder()
                .indentOutput(<span class="hljs-keyword">true</span>)
                .dateFormat(<span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">"yyyy-MM-dd"</span>))
                .modulesToInstall(<span class="hljs-keyword">new</span> ParameterNamesModule());
        converters.add(<span class="hljs-keyword">new</span> MappingJackson2HttpMessageConverter(builder.build()));
        converters.add(<span class="hljs-keyword">new</span> MappingJackson2XmlHttpMessageConverter(builder.createXmlMapper(<span class="hljs-keyword">true</span>).build()));
    }
}
</code></pre>
<p>在上面的例子中，<a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/http/converter/json/Jackson2ObjectMapperBuilder.html"><code>Jackson2ObjectMapperBuilder</code></a> 用于为 <code>MappingJackson2HttpMessageConverter</code> 和<code>MappingJackson2XmlHttpMessageConverter</code> 转换器创建公共的配置，比如启用tab缩进、定制的日期格式，并注册了模块 <a href="https://github.com/FasterXML/jackson-module-parameter-names"><code>jackson-module-parameter-names</code></a>用于获取参数名（Java 8新增的特性）。</p>
<p>该builder会使用以下的默认属性对Jackson进行配置</p>
<ul>
<li>
<p><a href="https://fasterxml.github.io/jackson-databind/javadoc/2.6/com/fasterxml/jackson/databind/DeserializationFeature.html#FAIL_ON_UNKNOWN_PROPERTIES"><code>DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES</code></a> is disabled.</p>
</li>
<li>
<p><a href="https://fasterxml.github.io/jackson-databind/javadoc/2.6/com/fasterxml/jackson/databind/MapperFeature.html#DEFAULT_VIEW_INCLUSION"><code>MapperFeature.DEFAULT_VIEW_INCLUSION</code></a> is disabled.</p>
</li>
</ul>
<p>同时，如果检测到在classpath路径下存在这些模块，该builder也会自动地注册它们。</p>
<ul>
<li>
<p><a href="https://github.com/FasterXML/jackson-datatype-jdk7">jackson-datatype-jdk7</a>: Support for Java 7 types, such as <code>java.nio.file.Path</code>.</p>
</li>
<li>
<p><a href="https://github.com/FasterXML/jackson-datatype-joda">jackson-datatype-joda</a>: Support for Joda-Time types.</p>
</li>
<li>
<p><a href="https://github.com/FasterXML/jackson-datatype-jsr310">jackson-datatype-jsr310</a>: Support for Java 8 Date and Time API types.</p>
</li>
<li>
<p><a href="https://github.com/FasterXML/jackson-datatype-jdk8">jackson-datatype-jdk8</a>: Support for other Java 8 types, such as <code>Optional</code>.</p>
</li>
</ul>
<p>除了<a href="https://search.maven.org/#search%7Cga%7C1%7Ca%3A%22jackson-dataformat-xml%22"><code>jackson-dataformat-xml</code></a> 之外，要启用Jackson XML的tab缩进还需要<a href="https://search.maven.org/#search%7Cgav%7C1%7Cg%3A%22org.codehaus.woodstox%22%20AND%20a%3A%22woodstox-core-asl%22"><code>woodstox-core-asl</code></a>依赖。</p>
<p>还有其他有用的Jackson模块可以使用</p>
<ul>
<li>
<p><a href="https://github.com/zalando/jackson-datatype-money">jackson-datatype-money</a>: 提供了对<code>javax.money</code> 类型的支持（非官方模块）</p>
</li>
<li>
<p><a href="https://github.com/FasterXML/jackson-datatype-hibernate">jackson-datatype-hibernate</a>:提供了Hibernate相关的类型和属性支持（包含懒加载aspects）</p>
</li>
</ul>
<p>以下示例显示如何在XML中实现相同的配置：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:message-converters</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"objectMapper"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"objectMapper"</span>/&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.http.converter.xml.MappingJackson2XmlHttpMessageConverter"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"objectMapper"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"xmlMapper"</span>/&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:message-converters</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mvc:annotation-driven</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"objectMapper"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean"</span>
      <span class="hljs-attr">p:indentOutput</span>=<span class="hljs-string">"true"</span>
      <span class="hljs-attr">p:simpleDateFormat</span>=<span class="hljs-string">"yyyy-MM-dd"</span>
      <span class="hljs-attr">p:modulesToInstall</span>=<span class="hljs-string">"com.fasterxml.jackson.module.paramnames.ParameterNamesModule"</span>/&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"xmlMapper"</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">"objectMapper"</span> <span class="hljs-attr">p:createXmlMapper</span>=<span class="hljs-string">"true"</span>/&gt;</span>
</code></pre>
<p><a id="mvc-config-view-controller"></a></p>
<h4><a href="#mvc-config-view-controller"></a>1.10.8. 视图控制器</h4>
<p>以下的一段代码相当于定义<code>ParameterizableViewController</code> 视图控制器的快捷方式，该控制器会立即将请求转发（forwards）给视图。请确保仅在以下情景下才使用这个类：当控制器除了将视图渲染到响应中外不需要执行任何逻辑时。</p>
<p>以下Java配置示例将对 <code>/</code>的请求转发给名为<code>home</code>的视图:</p>
<pre><code class="language-java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@EnableWebMvc</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>{

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addViewControllers</span><span class="hljs-params">(ViewControllerRegistry registry)</span> </span>{
        registry.addViewController(<span class="hljs-string">"/"</span>).setViewName(<span class="hljs-string">"home"</span>);
    }
}
</code></pre>
<p>以下示例与前面的示例实现相同的功能，但使用XML，通过使用<code>&lt;mvc:view-controller&gt;</code>元素:</p>
<pre><code>&lt;mvc:view-controller path=&quot;/&quot; view-name=&quot;home&quot;/&gt;
</code></pre>
<p><a id="mvc-config-view-resolvers"></a></p>
<h4><a href="#mvc-config-view-resolvers"></a>1.10.9. 视图解析器</h4>
<p><a href="web-reactive.html#webflux-config-view-resolvers">Same as in Spring WebFlux</a></p>
<p>MVC提供的配置简化了视图解析器的注册工作</p>
<p>以下Java配置示例使用JSP和Jackson作为JSON呈现的默认视图来配置内容协商视图解析：</p>
<pre><code class="language-java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@EnableWebMvc</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>{

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configureViewResolvers</span><span class="hljs-params">(ViewResolverRegistry registry)</span> </span>{
        registry.enableContentNegotiation(<span class="hljs-keyword">new</span> MappingJackson2JsonView());
        registry.jsp();
    }
}
</code></pre>
<p>以下示例显示如何在XML中实现相同的配置：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:view-resolvers</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:content-negotiation</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">mvc:default-views</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.web.servlet.view.json.MappingJackson2JsonView"</span>/&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:default-views</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:content-negotiation</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:jsp</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mvc:view-resolvers</span>&gt;</span>
</code></pre>
<p>但请注意，FreeMarker，Tiles，Groovy Markup和脚本模板也需要配置底层视图技术。</p>
<p>MVC名称空间提供专用元素。 以下示例适用于FreeMarker：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:view-resolvers</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:content-negotiation</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">mvc:default-views</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.web.servlet.view.json.MappingJackson2JsonView"</span>/&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:default-views</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:content-negotiation</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:freemarker</span> <span class="hljs-attr">cache</span>=<span class="hljs-string">"false"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mvc:view-resolvers</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">mvc:freemarker-configurer</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:template-loader-path</span> <span class="hljs-attr">location</span>=<span class="hljs-string">"/freemarker"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mvc:freemarker-configurer</span>&gt;</span>
</code></pre>
<p>在Java配置中，您可以添加相应的<code>Configurer</code> bean，如以下示例所示：</p>
<pre><code class="language-java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@EnableWebMvc</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>{

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configureViewResolvers</span><span class="hljs-params">(ViewResolverRegistry registry)</span> </span>{
        registry.enableContentNegotiation(<span class="hljs-keyword">new</span> MappingJackson2JsonView());
        registry.freeMarker().cache(<span class="hljs-keyword">false</span>);
    }

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> FreeMarkerConfigurer <span class="hljs-title">freeMarkerConfigurer</span><span class="hljs-params">()</span> </span>{
        FreeMarkerConfigurer configurer = <span class="hljs-keyword">new</span> FreeMarkerConfigurer();
        configurer.setTemplateLoaderPath(<span class="hljs-string">"/freemarker"</span>);
        <span class="hljs-keyword">return</span> configurer;
    }
}
</code></pre>
<p><a id="mvc-config-static-resources"></a></p>
<h4><a href="#mvc-config-static-resources"></a>1.10.10. 静态资源</h4>
<p><a href="web-reactive.html#webflux-config-static-resources">Same as in Spring WebFlux</a></p>
<p>此选项提供了一种从 <a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/core/io/Resource.html"><code>资源</code></a>库位置列表中使用静态资源的便捷方法</p>
<p>在下面的示例中，给定以 <code>/resources</code>开头的请求，相对路径用于在Web应用程序根目录下或在或在<code>/static</code>下的类路径上查找和提供相对于<code>/public</code>的静态资源。 资源的有效期为1年，以确保最大程度地使用浏览器缓存，并减少浏览器发出的HTTP请求。如果返回 <code>304</code>状态代码，<code>Last-Modified</code> 头也会计算到。</p>
<p>以下清单显示了如何使用Java配置执行此操作:</p>
<pre><code class="language-java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@EnableWebMvc</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>{

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addResourceHandlers</span><span class="hljs-params">(ResourceHandlerRegistry registry)</span> </span>{
        registry.addResourceHandler(<span class="hljs-string">"/resources/**"</span>)
            .addResourceLocations(<span class="hljs-string">"/public"</span>, <span class="hljs-string">"classpath:/static/"</span>)
            .setCachePeriod(<span class="hljs-number">31556926</span>);
    }
}
</code></pre>
<p>以下示例显示如何在XML中实现相同的配置：</p>
<pre><code>&lt;mvc:resources mapping=&quot;/resources/**&quot;
    location=&quot;/public, classpath:/static/&quot;
    cache-period=&quot;31556926&quot; /&gt;
</code></pre>
<p>查看 <a href="#mvc-caching-static-resources">静态资源的HTTP缓存支持</a>.</p>
<p>资源处理还支持一系列 <a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/servlet/resource/ResourceResolver.html"><code>ResourceResolver</code></a> 实现 和 <a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/servlet/resource/ResourceTransformer.html"><code>ResourceTransformer</code></a> 实现, 可用于创建用于使用优化资源的工具</p>
<p><code>VersionResourceResolver</code>可用于基于内容、固定应用程序版本或其他的MD5哈希计算的版本化资源url。<code>ContentVersionStrategy</code>(MD5 hash)方法是一个很好的选择， 有一些值得注意的例外，例如与模块加载器一起使用的JavaScript资源。</p>
<p>以下示例显示如何在Java配置中使用 <code>VersionResourceResolver</code>：</p>
<pre><code class="language-java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@EnableWebMvc</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>{

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addResourceHandlers</span><span class="hljs-params">(ResourceHandlerRegistry registry)</span> </span>{
        registry.addResourceHandler(<span class="hljs-string">"/resources/**"</span>)
                .addResourceLocations(<span class="hljs-string">"/public/"</span>)
                .resourceChain(<span class="hljs-keyword">true</span>)
                .addResolver(<span class="hljs-keyword">new</span> VersionResourceResolver().addContentVersionStrategy(<span class="hljs-string">"/**"</span>));
    }
}
</code></pre>
<p>以下示例显示如何在XML中实现相同的配置：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:resources</span> <span class="hljs-attr">mapping</span>=<span class="hljs-string">"/resources/**"</span> <span class="hljs-attr">location</span>=<span class="hljs-string">"/public/"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:resource-chain</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">mvc:resource-cache</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">mvc:resolvers</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">mvc:version-resolver</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">mvc:content-version-strategy</span> <span class="hljs-attr">patterns</span>=<span class="hljs-string">"/**"</span>/&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:version-resolver</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:resolvers</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:resource-chain</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mvc:resources</span>&gt;</span>
</code></pre>
<p>您可以使用<code>ResourceUrlProvider</code>来重写URL并应用完整的解析器和转换器链，例如插入版本。MVC配置提供了 <code>ResourceUrlProvider</code> bean，因此可以将其注入到其他用户。 您还可以使用<code>ResourceUrlEncodingFilter</code> 的Thymeleaf、jsp、FreeMarker和其他依赖于<code>HttpServletResponse#encodeURL</code>的URL标记来做重写转换。</p>
<p>请注意，当同时使用<code>EncodedResourceResolver</code>（例如，用于提供gzipped或brotli编码的资源）和<code>VersionedResourceResolver</code>时，必须按此顺序注册它们。 这可确保始终基于未编码的文件可靠地计算基于内容的版本。</p>
<p><a href="http://www.webjars.org/documentation">WebJars</a>也支持使用<code>WebJarsResourceResolver</code>和自动注册，当 <code>org.webjars:webjars-locator</code>存在于类路径中时。解析器可以重写URL来包含jar的版本，也可以与传入的URL匹配，而不需要版本 。 例如， <code>/jquery/jquery.min.js</code> 到 <code>/jquery/1.2.0/jquery.min.js</code>。</p>
<p><a id="mvc-default-servlet-handler"></a></p>
<h4><a href="#mvc-default-servlet-handler"></a>1.10.11. 默认 Servlet</h4>
<p>这些配置允许将<code>DispatcherServlet</code>映射到<code>/</code>路径（也即覆盖了容器默认Servlet的映射），但依然保留容器默认的Servlet以处理静态资源的请求。这可以通过配置一个URL映射到 <code>/**</code> 的处理器<code>DefaultServletHttpRequestHandler</code>来实现，并且该处理器在其他所有URL映射关系中优先级应该是最低的。</p>
<p>该处理器会将所有请求转发（forward）到默认的Servlet，因此需要保证它在所有URL处理器映射<code>HandlerMappings</code>的最后。如果你是通过<code>&lt;mvc:annotation-driven&gt;</code>的方式进行配置， 或自定义 <code>HandlerMapping</code> 实例，那么需要确保该处理器<code>order</code>属性的值比<code>DefaultServletHttpRequestHandler</code>的次序值<code>Integer.MAX_VALUE</code>小。</p>
<p>以下示例显示如何使用默认设置启用该功能：</p>
<pre><code class="language-java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@EnableWebMvc</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>{

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configureDefaultServletHandling</span><span class="hljs-params">(DefaultServletHandlerConfigurer configurer)</span> </span>{
        configurer.enable();
    }
}
</code></pre>
<p>以下示例显示如何在XML中实现相同的配置：</p>
<pre><code>&lt;mvc:default-servlet-handler/&gt;
</code></pre>
<p>不过需要注意，覆写了<code>/</code>的Servlet映射后，默认Servlet的<code>RequestDispatcher</code>就必须通过名字而非路径来取得了。 <code>DefaultServletHttpRequestHandler</code>会尝试在容器初始化的时候自动检测默认Servlet， 这里它使用的是一份主流Servlet容器（包括Tomcat, Jetty, GlassFish, JBoss, Resin, WebLogic, and WebSphere）已知的名称列表。如果默认Servlet被配置了一个其他的名字，或者使用了一个列表里未提供默认Servlet名称的容器，那么默认Servlet的名称必须被显式指定，正如下面代码所示：</p>
<pre><code class="language-java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@EnableWebMvc</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>{

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configureDefaultServletHandling</span><span class="hljs-params">(DefaultServletHandlerConfigurer configurer)</span> </span>{
        configurer.enable(<span class="hljs-string">"myCustomDefaultServlet"</span>);
    }

}
</code></pre>
<p>以下示例显示如何在XML中实现相同的配置：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:default-servlet-handler</span> <span class="hljs-attr">default-servlet-name</span>=<span class="hljs-string">"myCustomDefaultServlet"</span>/&gt;</span>
</code></pre>
<p><a id="mvc-config-path-matching"></a></p>
<h4><a href="#mvc-config-path-matching"></a>1.10.12. 路径匹配</h4>
<p><a href="web-reactive.html#webflux-config-path-matching">Same as in Spring WebFlux</a></p>
<p>您可以自定义与路径匹配和URL处理相关的选项。 有关各个选项的详细信息，请参阅 <a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/servlet/config/annotation/PathMatchConfigurer.html"><code>PathMatchConfigurer</code></a> javadoc.</p>
<p>以下示例显示如何在Java配置中自定义路径匹配：</p>
<pre><code class="language-java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@EnableWebMvc</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>{

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configurePathMatch</span><span class="hljs-params">(PathMatchConfigurer configurer)</span> </span>{
        configurer
            .setUseSuffixPatternMatch(<span class="hljs-keyword">true</span>)
            .setUseTrailingSlashMatch(<span class="hljs-keyword">false</span>)
            .setUseRegisteredSuffixPatternMatch(<span class="hljs-keyword">true</span>)
            .setPathMatcher(antPathMatcher())
            .setUrlPathHelper(urlPathHelper())
            .addPathPrefix(<span class="hljs-string">"/api"</span>,
                    HandlerTypePredicate.forAnnotation(RestController<span class="hljs-class">.<span class="hljs-keyword">class</span>))</span>;
    }

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> UrlPathHelper <span class="hljs-title">urlPathHelper</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">//...</span>
    }

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> PathMatcher <span class="hljs-title">antPathMatcher</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">//...</span>
    }

}
</code></pre>
<p>以下示例显示如何在XML中实现相同的配置：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:path-matching</span>
        <span class="hljs-attr">suffix-pattern</span>=<span class="hljs-string">"true"</span>
        <span class="hljs-attr">trailing-slash</span>=<span class="hljs-string">"false"</span>
        <span class="hljs-attr">registered-suffixes-only</span>=<span class="hljs-string">"true"</span>
        <span class="hljs-attr">path-helper</span>=<span class="hljs-string">"pathHelper"</span>
        <span class="hljs-attr">path-matcher</span>=<span class="hljs-string">"pathMatcher"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mvc:annotation-driven</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"pathHelper"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.example.app.MyPathHelper"</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"pathMatcher"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.example.app.MyPathMatcher"</span>/&gt;</span>
</code></pre>
<p><a id="mvc-config-advanced-java"></a></p>
<h4><a href="#mvc-config-advanced-java"></a>1.10.13. 高级 Java 配置</h4>
<p><a href="web-reactive.html#webflux-config-advanced-java">Same as in Spring WebFlux</a></p>
<p><code>@EnableWebMvc</code> 导入 <code>DelegatingWebMvcConfiguration</code>, 其中:</p>
<ul>
<li>
<p>为Spring MVC应用程序提供了默认的Spring配置</p>
</li>
<li>
<p>检测到并委派到<code>WebMvcConfigurer</code>的自定义该配置</p>
</li>
</ul>
<p>对于高级模式，请删除<code>@EnableWebMvc</code>并直接从 <code>DelegatingWebMvcConfiguration</code>继承 ，而不是实现<code>WebMvcConfigurer</code>，如以下示例所示：</p>
<pre><code class="language-java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">DelegatingWebMvcConfiguration</span> </span>{

    <span class="hljs-comment">// ...</span>

}
</code></pre>
<p>可以在<code>WebConfig</code>中保留现有的方法，但现在也可以重写基类中的bean声明，并且在类路径上仍然可以有任意数量的其他<code>WebMvcConfigurer</code> 。</p>
<p><a id="mvc-config-advanced-xml"></a></p>
<h4><a href="#mvc-config-advanced-xml"></a>1.10.14. 高级 XML 配置</h4>
<p>MVC命名空间没有高级模式，如果需要自定义无法更改的bean上的属性，可以使用 <code>ApplicationContext</code>的<code>BeanPostProcessor</code>生命周期挂钩，如以下示例所示：</p>
<pre><code class="language-java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanPostProcessor</span> </span>{

    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String name)</span> <span class="hljs-keyword">throws</span> BeansException </span>{
        <span class="hljs-comment">// ...</span>
    }
}
</code></pre>
<p>请注意，<code>MyPostProcessor</code>需要用XML显式声明为bean，或通过 <code>&lt;component-scan/&gt;</code>声明检测。</p>
<p><a id="mvc-http2"></a></p>
<h3><a href="#mvc-http2"></a>1.11. HTTP/2</h3>
<p><a href="web-reactive.html#webflux-http2">Same as in Spring WebFlux</a></p>
<p>Servlet 4容器需要支持HTTP/2，Spring Framework 5与Servlet API 4兼容。从编程模型的角度来看，应用程序不需要特定的任何操作。 但是，存在与服务器配置相关的注意事项。 有关更多详细信息，请参阅 <a href="https://github.com/spring-projects/spring-framework/wiki/HTTP-2-support">HTTP/2 wiki 页面。</a></p>
<p>Servlet API确实公开了一个与HTTP/2相关的构造。 您可以使用<code>javax.servlet.http.PushBuilder</code> 主动将资源推送到客户端，并且它被支持作为 <code>@RequestMapping</code>方法的<a href="#mvc-ann-arguments">方法参数</a>。</p>
</div></section><footer class="footer-container"><div class="footer-body"><img src="/img/jcohy.png"/><div class="cols-container"><div class="col col-12"><p>jia_chao23@126.com</p><p>https://www.github.com/jiachao23</p></div><div class="col col-6"><dl><dt>Documentation</dt><dd><a href="/en-us/docs/springframework/demo.html" target="_self">Spring Framework</a></dd><dd><a href="/en-us/docs/springboot/demo.html" target="_self">SpringBoot</a></dd><dd><a href="/en-us/docs/dir/nginx/demo.html" target="_self">Nginx</a></dd><dd><a href="/en-us/docs/microservices/demo.html" target="_self">Microservices</a></dd></dl></div><div class="col col-6"><dl><dt>Resources</dt><dd><a href="/zh-cn/blog/index.html" target="_self">Blog</a></dd><dd><a href="/zh-cn/community/index.html" target="_self">Community</a></dd></dl></div></div><div class="copyright"><span>Copyright © 2018 www.jcohy.com</span></div></div></footer></div></div>
	<script src="https://f.alicdn.com/react/15.4.1/react-with-addons.min.js"></script>
	<script src="https://f.alicdn.com/react/15.4.1/react-dom.min.js"></script>
	<script>
		window.rootPath = '';
  </script>
	<script src="/build/documentation.js"></script>
</body>
</html>
